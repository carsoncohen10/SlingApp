import SwiftUI
import UIKit
import FirebaseFirestore
import Network
import PhotosUI

// MARK: - Custom Colors Extension
extension Color {
    static let slingBlue = Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0))
    static let slingPurple = Color(uiColor: UIColor(red: 0x4E/255, green: 0x46/255, blue: 0xE5/255, alpha: 1.0))
    static let slingGradient: LinearGradient = LinearGradient(
        colors: [Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)), 
                 Color(uiColor: UIColor(red: 0x4E/255, green: 0x46/255, blue: 0xEB/255, alpha: 1.0))],
        startPoint: .leading,
        endPoint: .trailing
    )
    static let slingLightBlue = Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)).opacity(0.1)
    static let slingLightPurple = Color(uiColor: UIColor(red: 0x4E/255, green: 0x46/255, blue: 0xE5/255, alpha: 1.0)).opacity(0.1)
    static let slingAccent = Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)).opacity(0.8)
}

// MARK: - View Extensions
extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
}

struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners

    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(
            roundedRect: rect,
            byRoundingCorners: corners,
            cornerRadii: CGSize(width: radius, height: radius)
        )
        return Path(path.cgPath)
    }
}

// MARK: - Unsplash Image Service
class UnsplashImageService: ObservableObject {
    private let accessKey = "9cI_wggikqQS5PKKH2wTc-xouLMPsJmL-xg0Ai4X7Zs"
    private let baseURL = "https://api.unsplash.com/search/photos"
    
    // Debug properties
    @Published var lastError: String?
    @Published var lastRequestURL: String?
    @Published var lastResponseStatus: Int?
    @Published var requestCount: Int = 0
    @Published var isNetworkAvailable: Bool = true
    
    private let networkMonitor = NWPathMonitor()
    private let networkQueue = DispatchQueue(label: "NetworkMonitor")
    
    init() {
        startNetworkMonitoring()
    }
    
    private func startNetworkMonitoring() {
        networkMonitor.pathUpdateHandler = { [weak self] path in
            DispatchQueue.main.async {
                self?.isNetworkAvailable = path.status == .satisfied
                if path.status != .satisfied {
                    self?.lastError = "❌ No network connection available"
                }
            }
        }
        networkMonitor.start(queue: networkQueue)
    }
    
    func getImageForBet(title: String, completion: @escaping (String?) -> Void) {
        // Check network connectivity first
        guard isNetworkAvailable else {
            let errorMessage = "❌ No network connection - check your internet"
            print(errorMessage)
            DispatchQueue.main.async {
                self.lastError = errorMessage
                completion(nil)
            }
            return
        }
        
        let enrichedQuery = enrichQuery(from: title)
        let encodedQuery = enrichedQuery.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? enrichedQuery
        
        guard let url = URL(string: "\(baseURL)?query=\(encodedQuery)&per_page=30&orientation=landscape") else {
            let errorMessage = "❌ Invalid URL created for query: \(enrichedQuery)"
            print(errorMessage)
            DispatchQueue.main.async {
                self.lastError = errorMessage
            completion(nil)
            }
            return
        }
        
        var request = URLRequest(url: url)
        request.setValue("Client-ID \(accessKey)", forHTTPHeaderField: "Authorization")
        request.timeoutInterval = 10.0 // Add timeout
        
        DispatchQueue.main.async {
            self.requestCount += 1
            self.lastRequestURL = url.absoluteString
            self.lastError = nil
        }
        


        
        URLSession.shared.dataTask(with: request) { data, response, error in
            // Log response details
            if let httpResponse = response as? HTTPURLResponse {
                print("📊 HTTP Status: \(httpResponse.statusCode)")
                DispatchQueue.main.async {
                    self.lastResponseStatus = httpResponse.statusCode
                }
                
                if httpResponse.statusCode != 200 {
                    let errorMessage = "❌ HTTP Error \(httpResponse.statusCode): \(HTTPURLResponse.localizedString(forStatusCode: httpResponse.statusCode))"
                    print(errorMessage)
                    
                    // Check for rate limiting
                    if httpResponse.statusCode == 403 {
                        print("🚫 Rate limit hit or invalid API key")
                    }
                    
                    DispatchQueue.main.async {
                        self.lastError = errorMessage
                    completion(nil)
                }
                return
                }
            }
            
            if let error = error {
                let errorMessage = "❌ Network Error: \(error.localizedDescription)"
                print(errorMessage)
                DispatchQueue.main.async {
                    self.lastError = errorMessage
                    completion(nil)
                }
                return
            }
            
            guard let data = data else {
                let errorMessage = "❌ No data received from Unsplash API"
                print(errorMessage)
                DispatchQueue.main.async {
                    self.lastError = errorMessage
                    completion(nil)
                }
                return
            }
            
            print("📦 Received \(data.count) bytes of data")
            
            do {
                let result = try JSONDecoder().decode(UnsplashResponse.self, from: data)
                
                print("✅ Successfully decoded Unsplash response with \(result.results.count) images")
                
                // Debug: Print first few image details
                if result.results.count > 0 {
                    let firstImage = result.results[0]
                    print("🔍 First image - ID: \(firstImage.id), Description: \(firstImage.description ?? "nil"), Alt: \(firstImage.alt_description ?? "nil")")
                }
                
                if result.results.isEmpty {
                    let errorMessage = "⚠️ No images found for query: \(enrichedQuery)"
                    print(errorMessage)
                    DispatchQueue.main.async {
                        self.lastError = errorMessage
                        completion(nil)
                    }
                    return
                }
                
                let bestImage = self.selectBestImage(from: result.results, for: title)
                if let imageURL = bestImage {
                    print("✅ Selected image URL: \(imageURL)")
                } else {
                    print("⚠️ No suitable image selected from results")
                }
                
                DispatchQueue.main.async {
                    self.lastError = bestImage == nil ? "No suitable image found" : nil
                    completion(bestImage)
                }
            } catch {
                let errorMessage = "❌ JSON Decode Error: \(error.localizedDescription)"
                print(errorMessage)
                
                // Print raw response for debugging
                if let responseString = String(data: data, encoding: .utf8) {
                    print("📄 Raw response: \(responseString.prefix(500))...")
                }
                
                // Print the specific decoding error details
                if let decodingError = error as? DecodingError {
                    switch decodingError {
                    case .keyNotFound(let key, let context):
                        print("🔑 Missing key: \(key.stringValue) at path: \(context.codingPath)")
                    case .typeMismatch(let type, let context):
                        print("🔄 Type mismatch: expected \(type) at path: \(context.codingPath)")
                    case .valueNotFound(let type, let context):
                        print("💨 Value not found: expected \(type) at path: \(context.codingPath)")
                    case .dataCorrupted(let context):
                        print("💥 Data corrupted at path: \(context.codingPath)")
                    @unknown default:
                        print("❓ Unknown decoding error")
                    }
                }
                
                DispatchQueue.main.async {
                    self.lastError = errorMessage
                    completion(nil)
                }
            }
        }.resume()
    }
    
    private func enrichQuery(from title: String) -> String {
        let lowercasedTitle = title.lowercased()
        var enrichedKeywords: [String] = []
        
        // Add original title words
        enrichedKeywords.append(contentsOf: title.components(separatedBy: " ").filter { $0.count > 2 })
        
        // Add contextual keywords based on themes
        if lowercasedTitle.contains("family") || lowercasedTitle.contains("dad") || lowercasedTitle.contains("mom") || lowercasedTitle.contains("thanksgiving") || lowercasedTitle.contains("dinner") {
            enrichedKeywords.append(contentsOf: ["family", "dinner", "holiday", "table", "celebration"])
        }
        
        if lowercasedTitle.contains("sport") || lowercasedTitle.contains("game") || lowercasedTitle.contains("team") || lowercasedTitle.contains("win") || lowercasedTitle.contains("score") {
            enrichedKeywords.append(contentsOf: ["sports", "game", "competition", "athletics"])
        }
        
        if lowercasedTitle.contains("weather") || lowercasedTitle.contains("rain") || lowercasedTitle.contains("sun") || lowercasedTitle.contains("snow") {
            enrichedKeywords.append(contentsOf: ["weather", "nature", "sky", "outdoors"])
        }
        
        if lowercasedTitle.contains("money") || lowercasedTitle.contains("price") || lowercasedTitle.contains("cost") || lowercasedTitle.contains("dollar") {
            enrichedKeywords.append(contentsOf: ["money", "finance", "business", "economics"])
        }
        
        if lowercasedTitle.contains("food") || lowercasedTitle.contains("eat") || lowercasedTitle.contains("restaurant") || lowercasedTitle.contains("cook") {
            enrichedKeywords.append(contentsOf: ["food", "cooking", "restaurant", "cuisine"])
        }
        
        if lowercasedTitle.contains("travel") || lowercasedTitle.contains("trip") || lowercasedTitle.contains("vacation") || lowercasedTitle.contains("flight") {
            enrichedKeywords.append(contentsOf: ["travel", "vacation", "adventure", "landscape"])
        }
        
        if lowercasedTitle.contains("movie") || lowercasedTitle.contains("film") || lowercasedTitle.contains("actor") || lowercasedTitle.contains("show") {
            enrichedKeywords.append(contentsOf: ["movie", "cinema", "entertainment", "film"])
        }
        
        if lowercasedTitle.contains("music") || lowercasedTitle.contains("song") || lowercasedTitle.contains("concert") || lowercasedTitle.contains("album") {
            enrichedKeywords.append(contentsOf: ["music", "concert", "performance", "art"])
        }
        
        if lowercasedTitle.contains("work") || lowercasedTitle.contains("job") || lowercasedTitle.contains("office") || lowercasedTitle.contains("meeting") {
            enrichedKeywords.append(contentsOf: ["work", "office", "business", "professional"])
        }
        
        if lowercasedTitle.contains("school") || lowercasedTitle.contains("study") || lowercasedTitle.contains("exam") || lowercasedTitle.contains("grade") {
            enrichedKeywords.append(contentsOf: ["education", "school", "study", "learning"])
        }
        
        // Remove duplicates and join
        let uniqueKeywords = Array(Set(enrichedKeywords))
        return uniqueKeywords.joined(separator: " ")
    }
    
    private func selectBestImage(from images: [UnsplashImage], for title: String) -> String? {
        guard !images.isEmpty else { return nil }
        
        let lowercasedTitle = title.lowercased()
        let titleWords = Set(lowercasedTitle.components(separatedBy: " ").filter { $0.count > 2 })
        
        var bestImage: UnsplashImage?
        var bestScore: Double = 0
        
        for image in images {
            var score: Double = 0
            
            // Description match
            let description = (image.description ?? "").lowercased()
            let altDescription = (image.alt_description ?? "").lowercased()
            
            for word in titleWords {
                if description.contains(word) { score += 2.0 }
                if altDescription.contains(word) { score += 1.5 }
            }
            
            // Tag match
            if let tags = image.tags {
                for tag in tags {
                    let tagName = tag.title.lowercased()
                    for word in titleWords {
                        if tagName.contains(word) { score += 1.0 }
                    }
                }
            }
            
            // Social bias for people-related content
            if lowercasedTitle.contains("family") || lowercasedTitle.contains("dad") || lowercasedTitle.contains("mom") || lowercasedTitle.contains("person") || lowercasedTitle.contains("people") {
                if description.contains("person") || description.contains("people") || description.contains("family") {
                    score += 0.5
                }
            }
            
            // Likes tiebreaker
            if let likes = image.likes {
                score += Double(likes) * 0.001
            }
            
            if score > bestScore {
                bestScore = score
                bestImage = image
            }
        }
        
        return bestImage?.urls.regular
    }
}

// MARK: - Unsplash Response Models
struct UnsplashResponse: Codable {
    let total: Int
    let total_pages: Int
    let results: [UnsplashImage]
}

struct UnsplashImage: Codable {
    let id: String
    let slug: String?
    let alternative_slugs: [String: String]?
    let created_at: String?
    let updated_at: String?
    let promoted_at: String?
    let width: Int?
    let height: Int?
    let color: String?
    let blur_hash: String?
    let description: String?
    let alt_description: String?
    let likes: Int?
    let urls: UnsplashURLs
    let tags: [UnsplashTag]?
    let user: UnsplashUser
}

struct UnsplashURLs: Codable {
    let regular: String
}

struct UnsplashTag: Codable {
    let title: String
}

struct UnsplashUser: Codable {
    let name: String
}

// MARK: - Bet Image View
struct BetImageView: View {
    let title: String
    let imageURL: String? // Direct image URL from Firestore
    let size: CGFloat
    @State private var hasError = false
    @State private var showImageFullscreen = false
    
    init(title: String, imageURL: String? = nil, size: CGFloat = 60) {
        self.title = title
        self.imageURL = imageURL
        self.size = size
    }
    
    var body: some View {
        Group {
            if let imageURL = imageURL, !imageURL.isEmpty {
                OptimizedAsyncImage(url: imageURL) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(width: size, height: size)
                        .clipped()
                        .cornerRadius(12)
                        .onTapGesture {
                            showImageFullscreen = true
                        }
                } placeholder: {
                    RoundedRectangle(cornerRadius: 12)
                        .fill(Color.gray.opacity(0.2))
                        .frame(width: size, height: size)
                        .overlay(
                            ProgressView()
                                .scaleEffect(0.8)
                        )
                }
            } else {
                // No image URL provided - show placeholder
                RoundedRectangle(cornerRadius: 12)
                    .fill(Color.gray.opacity(0.2))
                    .frame(width: size, height: size)
                    .overlay(
                        Image(systemName: "photo")
                            .foregroundColor(.gray)
                            .font(.system(size: size * 0.33))
                    )
            }
        }
        .onAppear {
            if imageURL != nil {
                // Image URL is available
            } else {
                // No image URL available
            }
        }
        .fullScreenCover(isPresented: $showImageFullscreen) {
            if let imageUrl = imageURL {
                FullscreenImageView(imageUrl: imageUrl, isPresented: $showImageFullscreen)
            }
        }
    }
}

// MARK: - Image Debug Console
struct ImageDebugConsole: View {
    @ObservedObject var imageService: UnsplashImageService
    @Binding var isPresented: Bool
    
    var body: some View {
        NavigationView {
            VStack(alignment: .leading, spacing: 16) {
                // Summary Stats
                VStack(alignment: .leading, spacing: 8) {
                    Text("Debug Summary")
                        .font(.headline)
                        .fontWeight(.semibold)
                    
                    HStack {
                        VStack(alignment: .leading) {
                            Text("Total Requests")
                                .font(.caption)
                                .foregroundColor(.gray)
                            Text("\(imageService.requestCount)")
                                .font(.title2)
                                .fontWeight(.bold)
                        }
                        
                        Spacer()
                        
                        VStack(alignment: .leading) {
                            Text("Network")
                                .font(.caption)
                                .foregroundColor(.gray)
                            HStack(spacing: 4) {
                                Circle()
                                    .fill(imageService.isNetworkAvailable ? .green : .red)
                                    .frame(width: 8, height: 8)
                                Text(imageService.isNetworkAvailable ? "Online" : "Offline")
                                    .font(.subheadline)
                                    .fontWeight(.bold)
                                    .foregroundColor(imageService.isNetworkAvailable ? .green : .red)
                            }
                        }
                        
                        Spacer()
                        
                        VStack(alignment: .leading) {
                            Text("Last Status")
                                .font(.caption)
                                .foregroundColor(.gray)
                            Text("\(imageService.lastResponseStatus ?? 0)")
                                .font(.title2)
                                .fontWeight(.bold)
                                .foregroundColor(statusColor(imageService.lastResponseStatus))
                        }
                    }
                    .padding()
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(8)
                }
                
                // Last Request Details
                if let lastURL = imageService.lastRequestURL {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Last Request")
                            .font(.headline)
                            .fontWeight(.semibold)
                        
                        ScrollView {
                            Text(lastURL)
                                .font(.caption)
                                .foregroundColor(Color.slingBlue)
                                .multilineTextAlignment(.leading)
                        }
                        .frame(maxHeight: 60)
                        .padding()
                        .background(Color.slingLightBlue)
                        .cornerRadius(8)
                    }
                }
                
                // Error Details
                if let lastError = imageService.lastError {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Last Error")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.red)
                        
                        ScrollView {
                            Text(lastError)
                                .font(.caption)
                                .foregroundColor(.red)
                                .multilineTextAlignment(.leading)
                        }
                        .frame(maxHeight: 80)
                        .padding()
                        .background(Color.red.opacity(0.1))
                        .cornerRadius(8)
                    }
                } else {
                    VStack(alignment: .leading, spacing: 8) {
                        Text("Status")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.green)
                        
                        Text("No errors detected")
                            .font(.subheadline)
                            .foregroundColor(.green)
                            .padding()
                            .background(Color.green.opacity(0.1))
                            .cornerRadius(8)
                    }
                }
                
                // Troubleshooting Tips
                VStack(alignment: .leading, spacing: 8) {
                    Text("Troubleshooting")
                        .font(.headline)
                        .fontWeight(.semibold)
                    
                    VStack(alignment: .leading, spacing: 4) {
                        Text("• Check internet connection")
                        Text("• Verify Unsplash API key is valid")
                        Text("• Look for HTTP status codes (403 = rate limit)")
                        Text("• Tap orange error icons to retry")
                    }
                    .font(.caption)
                    .foregroundColor(.gray)
                    .padding()
                    .background(Color.yellow.opacity(0.1))
                    .cornerRadius(8)
                }
                
                Spacer()
            }
            .padding()
            .navigationTitle("Image Debug")
            .navigationBarTitleDisplayMode(.inline)
            .navigationBarItems(trailing: Button("Done") {
                isPresented = false
            })
        }
    }
    
    private func statusColor(_ status: Int?) -> Color {
        guard let status = status else { return .gray }
        
        switch status {
        case 200...299:
            return .green
        case 400...499:
            return .orange
        case 500...599:
            return .red
        default:
            return .gray
        }
    }
}



// MARK: - Welcome Card

struct WelcomeCard: View {
    @ObservedObject var firestoreService: FirestoreService
    @State private var showingJoinCommunityModal = false
    @State private var showingCreateCommunityModal = false
    
    var body: some View {
        VStack(spacing: 20) {
            // Welcome Card with Blue Background
            VStack(spacing: 16) {
                Text("Welcome to Sling!")
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.white)
                
                Text("Get started by joining or creating your first community!")
                    .font(.subheadline)
                    .foregroundColor(.white.opacity(0.9))
                    .multilineTextAlignment(.center)
            
            // Action Buttons
            VStack(spacing: 12) {
                Button(action: {
                        showingCreateCommunityModal = true
                }) {
                    HStack(spacing: 8) {
                            Image(systemName: "plus")
                                .font(.subheadline)
                            Text("Create Community")
                                .font(.subheadline)
                                .fontWeight(.medium)
                        }
                        .foregroundColor(.white)
                        .padding(.horizontal, 20)
                        .padding(.vertical, 12)
                        .frame(maxWidth: .infinity)
                        .background(Color.white.opacity(0.2))
                        .cornerRadius(10)
                        .overlay(
                            RoundedRectangle(cornerRadius: 10)
                                .stroke(Color.white, lineWidth: 1)
                        )
                    }
                    
                    Button(action: {
                        showingJoinCommunityModal = true
                    }) {
                        HStack(spacing: 8) {
                            Image(systemName: "person.2")
                                .font(.subheadline)
                        Text("Join Community")
                                .font(.subheadline)
                                .fontWeight(.medium)
                    }
                    .foregroundColor(.blue)
                        .padding(.horizontal, 20)
                    .padding(.vertical, 12)
                    .frame(maxWidth: .infinity)
                        .background(Color.white)
                    .cornerRadius(10)
                    }
                }
            }
            .padding(24)
            .background(AnyShapeStyle(Color.slingGradient))
            .cornerRadius(16)
            
            // Join Community Prompt
            VStack(spacing: 12) {
                Image(systemName: "person.2")
                    .font(.system(size: 48))
                    .foregroundColor(.gray.opacity(0.6))
                
                Text("Join a Community to Start")
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                
                Text("You need to be part of a community to see or create prediction markets.")
                    .font(.subheadline)
                    .foregroundColor(.gray)
                    .multilineTextAlignment(.center)
                
                Button(action: {
                    showingJoinCommunityModal = true
                }) {
                    HStack(spacing: 8) {
                        Image(systemName: "person.2")
                            .font(.subheadline)
                        Text("Explore Communities")
                            .font(.subheadline)
                            .fontWeight(.medium)
                    }
                    .foregroundColor(.black)
                    .padding(.horizontal, 20)
                    .padding(.vertical, 12)
                    .frame(maxWidth: .infinity)
                    .background(Color.white)
                    .cornerRadius(10)
                    .overlay(
                        RoundedRectangle(cornerRadius: 10)
                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                    )
                }
            }
            .padding(.horizontal, 16)
        }
        .sheet(isPresented: $showingJoinCommunityModal) {
            JoinCommunityPage(firestoreService: firestoreService)
        }
        .sheet(isPresented: $showingCreateCommunityModal) {
            CreateCommunityPage(firestoreService: firestoreService)
        }
    }
}

// MARK: - Empty Bets Views

struct EmptyBetsView: View {
    let firestoreService: FirestoreService
    @State private var showingCreateBetModal = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Header with icon and title
            HStack(alignment: .top, spacing: 12) {
                // Blue square icon with clipboard
                RoundedRectangle(cornerRadius: 8)
                    .fill(AnyShapeStyle(Color.slingGradient))
                    .frame(width: 60, height: 60)
                    .overlay(
                        Image(systemName: "list.bullet.clipboard")
                            .font(.system(size: 24))
                            .foregroundColor(.white)
                    )
                
                VStack(alignment: .leading, spacing: 8) {
            Text("No Active Bets")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundColor(.black)
            
            Text("This community doesn't have any active bets yet.")
                .font(.subheadline)
                .foregroundColor(.gray)
                }
            
                Spacer()
            }
            
            // Create Bet Button
            Button(action: {
                showingCreateBetModal = true
            }) {
                HStack(spacing: 8) {
                    Image(systemName: "plus")
                        .font(.subheadline)
                        .foregroundColor(.white)
                    
                    Text("Create a Bet")
                        .font(.subheadline)
                        .fontWeight(.medium)
                .foregroundColor(.white)
                }
                .frame(maxWidth: .infinity)
                .frame(height: 44)
                .background(AnyShapeStyle(Color.slingGradient))
                .cornerRadius(10)
            }
            .buttonStyle(PlainButtonStyle())
        }
        .padding(16)
        .background(Color.white)
        .cornerRadius(16)
        .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
        .sheet(isPresented: $showingCreateBetModal) {
            CreateBetView(firestoreService: firestoreService, preSelectedCommunity: nil)
        }
    }
}

struct EmptyActiveBetsView: View {
    let firestoreService: FirestoreService
    @State private var showingCreateBetModal = false
    
    var body: some View {
        VStack(spacing: 20) {
            // Sample bet design showing how a recent bet would look
            VStack(spacing: 0) {
                // Sample bet card
                VStack(alignment: .leading, spacing: 0) {
                    // Header section with choice and trophy icon
                    HStack(alignment: .top) {
                        // Hero choice at the top
                        Text("Yes")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                            .frame(maxWidth: .infinity, alignment: .leading)
                        
                        // Trophy icon
                        Image(systemName: "trophy.fill")
                            .font(.caption)
                            .foregroundColor(.slingBlue)
                            .padding(4)
                            .background(Color.slingBlue.opacity(0.1))
                            .cornerRadius(6)
                    }
                    
                    // Bet title
                    Text("Will the stock market close higher tomorrow?")
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(.black)
                        .padding(.top, 8)
                        .lineLimit(2)
                    
                    // Status and wager info
                    HStack {
                        // Status badge
                        Text("Settled")
                            .font(.caption)
                            .fontWeight(.medium)
                            .foregroundColor(.white)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 4)
                            .background(Color.blue)
                            .cornerRadius(8)
                        
                        Spacer()
                        
                        // Wager amount
                        HStack(spacing: 4) {
                            Text("Wager:")
                                .font(.caption2)
                                .foregroundColor(.gray)
                            Image(systemName: "bolt.fill")
                                .font(.caption2)
                                .foregroundColor(.slingBlue)
                            Text("100")
                                .font(.caption2)
                                .foregroundColor(.gray)
                        }
                    }
                    .padding(.top, 8)
                }
                .padding(16)
                .frame(width: 160, height: 140)
                .background(Color.white)
                .cornerRadius(16)
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(Color.gray.opacity(0.1), lineWidth: 1)
                )
                .shadow(color: .black.opacity(0.06), radius: 8, x: 0, y: 2)
                .opacity(0.6) // Make it look like a placeholder
                
                // "No recent bets" message
                VStack(spacing: 8) {
                    Text("No Recent Bets")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundColor(.black)
            
                    Text("Your recent betting activity will appear here")
                .font(.subheadline)
                .foregroundColor(.gray)
                .multilineTextAlignment(.center)
                }
                .padding(.top, 16)
            }
            
            Button(action: {
                showingCreateBetModal = true
            }) {
                HStack(spacing: 8) {
                    Image(systemName: "chart.line.uptrend.xyaxis")
                        .font(.subheadline)
                    Text("Browse Markets")
                        .font(.subheadline)
                        .fontWeight(.medium)
                }
                .foregroundColor(.white)
                .padding(.horizontal, 20)
                .padding(.vertical, 12)
                .frame(maxWidth: .infinity)
                .background(Color.slingGradient)
                .cornerRadius(10)
            }
        }
        .padding(.horizontal, 16)
        .sheet(isPresented: $showingCreateBetModal) {
            CreateBetView(firestoreService: firestoreService, preSelectedCommunity: nil)
        }
    }
}

struct EmptyPastBetsView: View {
    let firestoreService: FirestoreService
    @State private var showingCreateBetModal = false
    
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "target")
                .font(.system(size: 48))
                .foregroundColor(.gray.opacity(0.6))
            
            Text("No past bets found")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundColor(.black)
            
            Text("You haven't completed any bets yet.")
                .font(.subheadline)
                .foregroundColor(.gray)
                .multilineTextAlignment(.center)
            
            Button(action: {
                showingCreateBetModal = true
            }) {
                HStack(spacing: 8) {
                    Image(systemName: "chart.line.uptrend.xyaxis")
                        .font(.subheadline)
                    Text("Browse Markets")
                        .font(.subheadline)
                        .fontWeight(.medium)
                }
                .foregroundColor(.white)
                .padding(.horizontal, 20)
                .padding(.vertical, 12)
                .frame(maxWidth: .infinity)
                .background(Color.slingGradient)
                .cornerRadius(10)
            }
        }
        .padding(.horizontal, 16)
        .sheet(isPresented: $showingCreateBetModal) {
            CreateBetView(firestoreService: firestoreService, preSelectedCommunity: nil)
        }
    }
}

struct EmptyCommunitiesView: View {
    let firestoreService: FirestoreService
    
    var body: some View {
        VStack(spacing: 0) {
            Spacer()
            
            VStack(spacing: 16) {
                Image(systemName: "person.2")
                    .font(.system(size: 48))
                    .foregroundColor(.gray.opacity(0.6))
                
                Text("No communities yet")
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                
                Text("Create your first community or join an existing one to get started.")
                    .font(.subheadline)
                    .foregroundColor(.gray)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, 32)
            }
            
            Spacer()
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 60)
    }
}

struct EmptyPointsView: View {
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "bolt")
                .font(.system(size: 48))
                .foregroundColor(.gray.opacity(0.6))
            
            Text("Join a community to track points owed")
                .font(.subheadline)
                .foregroundColor(.gray)
                .multilineTextAlignment(.center)
        }
        .padding(.vertical, 20)
        .padding(.horizontal, 16)
    }
}

// MARK: - Enhanced Bet Card View

struct EnhancedBetCardView: View {
    let bet: FirestoreBet
    let currentUserEmail: String?
    let firestoreService: FirestoreService
    let isCommunityNameClickable: Bool // Control whether community name is clickable
    @State private var showingJoinBet = false
    @State private var hasRemindedCreator = false
    @State private var showingBettingInterface = false
    @State private var selectedBettingOption = ""
    @State private var userFullNames: [String: String] = [:]
    @State private var countdownTimer: Timer?
    @State private var currentTime = Date()
    
    private var communityName: String {
        if let community = firestoreService.userCommunities.first(where: { $0.id == bet.community_id }) {
            return community.name
        }
        return "Community"
    }
    
    // Timer lifecycle
    private func startCountdownTimer() {
        countdownTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in
            currentTime = Date()
        }
    }
    
    private func stopCountdownTimer() {
        countdownTimer?.invalidate()
        countdownTimer = nil
    }
    
    // Get countdown info
    private var countdownInfo: (timeString: String, isUrgent: Bool, isExpired: Bool) {
        print("🔍 countdownInfo: Called for bet '\(bet.title)' with original deadline: \(bet.deadline)")
        
        // Check if bet title contains time information that should override the database deadline
        var effectiveDeadline = bet.deadline
        
        // Special case: "Going to expire at 408" should expire at 4:08 PM today
        if bet.title.contains("Going to expire at 408") {
            let calendar = Calendar.current
            let now = Date()
            if let todayAt408 = calendar.date(bySettingHour: 16, minute: 8, second: 0, of: now) {
                effectiveDeadline = todayAt408
                print("🚨 DEBUG: Overriding deadline for 'Going to expire at 408' to today at 4:08 PM: \(effectiveDeadline)")
                print("🚨 DEBUG: Current time: \(now)")
                print("🚨 DEBUG: Time until 4:08 PM: \(todayAt408.timeIntervalSince(now)) seconds")
            } else {
                print("🚨 DEBUG: Failed to create today at 4:08 PM date")
            }
        }
        
        let info = firestoreService.getCountdownTime(for: effectiveDeadline)
        print("⏰ EnhancedBetCardView: Bet '\(bet.title)' - Effective Deadline: \(effectiveDeadline) - Time: '\(info.timeString)', Urgent: \(info.isUrgent), Expired: \(info.isExpired)")
        
        return info
    }
    
    var body: some View {
        Button(action: {
            if bet.status.lowercased() == "open" {
                showingJoinBet = true
            }
        }) {
            VStack(alignment: .leading, spacing: 16) {
                // Header with image and title
                HStack(alignment: .top, spacing: 12) {
                    BetImageView(title: bet.title, imageURL: bet.image_url, size: 48)
                    
                    VStack(alignment: .leading, spacing: 4) {
                        Text(bet.title)
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                        
                        HStack(spacing: 4) {
                            Image(systemName: "person.2")
                                .font(.caption)
                                .foregroundColor(isCommunityNameClickable ? .slingBlue : .gray)
                            
                            // Community name - conditionally clickable
                            if isCommunityNameClickable {
                                Button(action: {
                                    // Navigate to community details
                                    // This would need to be handled by the parent view
                                }) {
                                    Text(communityName)
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                        .foregroundColor(.slingBlue)
                                }
                                .buttonStyle(.plain)
                            } else {
                                Text(communityName)
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                .foregroundColor(.gray)
                            }
                            
                            Text("• by \(currentUserEmail == bet.creator_email ? "You" : getUserFullName(from: bet.creator_email))")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }
                    }
                    
                    Spacer()
                    
                    // Status Badge
                    StatusBadge(status: bet.status)
                }
                
                // Options with Outcome Pills - clickable to place bets
                VStack(spacing: 8) {
                    ForEach(bet.options, id: \.self) { option in
                        Button(action: {
                            // 🐛 DEBUG: Bet Option Selection - COMPREHENSIVE
                            print("🎯 BET_OPTION_CLICK: ===== COMPREHENSIVE DEBUG START =====")
                            print("🎯 BET_OPTION_CLICK: User clicked on option: '\(option)'")
                            print("🎯 BET_OPTION_CLICK: Bet ID: \(bet.id ?? "nil")")
                            print("🎯 BET_OPTION_CLICK: Bet title: '\(bet.title)'")
                            print("🎯 BET_OPTION_CLICK: All bet options: \(bet.options)")
                            print("🎯 BET_OPTION_CLICK: Current selectedBettingOption: '\(selectedBettingOption)'")
                            print("🎯 BET_OPTION_CLICK: selectedBettingOption.isEmpty: \(selectedBettingOption.isEmpty)")
                            print("🎯 BET_OPTION_CLICK: showingBettingInterface current value: \(showingBettingInterface)")
                            
                            // Set the selected option
                            selectedBettingOption = option
                            
                            print("🎯 BET_OPTION_CLICK: After assignment - selectedBettingOption: '\(selectedBettingOption)'")
                            print("🎯 BET_OPTION_CLICK: After assignment - selectedBettingOption.isEmpty: \(selectedBettingOption.isEmpty)")
                            
                            // Trigger the betting interface
                            showingBettingInterface = true
                            
                            print("🎯 BET_OPTION_CLICK: After showingBettingInterface = true: \(showingBettingInterface)")
                            print("🎯 BET_OPTION_CLICK: ===== COMPREHENSIVE DEBUG END =====")
                        }) {
                            HStack {
                                Text(option)
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                    .foregroundColor(.black)
                                
                                Spacer()
                                
                                Text({
                                    // Check if current user has placed a bet on this option and use locked odds
                                    if let userEmail = firestoreService.currentUser?.email,
                                       let betId = bet.id,
                                       let lockedOdds = firestoreService.getLockedOddsForUserBet(betId: betId, userEmail: userEmail),
                                       let optionOdds = lockedOdds[option] {
                                        print("🎯 UI DISPLAY: ===== SHOWING LOCKED ODDS IN BET CARD =====")
                                        print("🎯 UI DISPLAY: Bet ID: \(betId)")
                                        print("🎯 UI DISPLAY: Option: \(option)")
                                        print("🎯 UI DISPLAY: Using LOCKED odds: \(optionOdds)")
                                        let formattedOdds = firestoreService.formatImpliedOdds(optionOdds)
                                        print("🎯 UI DISPLAY: Formatted locked odds: \(formattedOdds)")
                                        print("🎯 UI DISPLAY: ==========================================")
                                        return formattedOdds
                                    } else {
                                        // Use current odds for display
                                        let calculatedOdds = firestoreService.calculateImpliedOdds(for: bet)
                                        let optionOdds = calculatedOdds[option] ?? 0.5
                                        let formattedOdds = firestoreService.formatImpliedOdds(optionOdds)
                                        
                                        print("🎯 UI DISPLAY: ===== SHOWING CURRENT ODDS IN BET CARD =====")
                                        print("🎯 UI DISPLAY: Bet ID: \(bet.id ?? "nil")")
                                        print("🎯 UI DISPLAY: Option: \(option)")
                                        print("🎯 UI DISPLAY: Bet pool_by_option: \(bet.pool_by_option ?? [:])")
                                        print("🎯 UI DISPLAY: Bet total_pool: \(bet.total_pool ?? 0)")
                                        print("🎯 UI DISPLAY: Calculated odds dict: \(calculatedOdds)")
                                        print("🎯 UI DISPLAY: Option odds: \(optionOdds)")
                                        print("🎯 UI DISPLAY: Formatted odds: \(formattedOdds)")
                                        print("🎯 UI DISPLAY: ==========================================")
                                        
                                        return formattedOdds
                                    }
                                }())
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                    .foregroundColor(.black)
                            }
                            .padding(.horizontal, 16)
                            .padding(.vertical, 12)
                            .background(Color.slingLightBlue)
                            .cornerRadius(10)
                        }
                        .buttonStyle(.plain)
                    }
                }
                
                // Footer with Deadline and Action
                HStack {
                    VStack(alignment: .leading, spacing: 2) {
                        if countdownInfo.isUrgent && !countdownInfo.isExpired {
                            // Show countdown in deadline line with red background
                            let timeText = "Deadline: \(countdownInfo.timeString)"
                            
                            Text(timeText)
                                .font(.caption)
                                .fontWeight(.bold)
                                .foregroundColor(.red)
                                .padding(.horizontal, 6)
                                .padding(.vertical, 2)
                                .background(Color.red.opacity(0.1))
                                .cornerRadius(4)
                                .onAppear {
                                    print("🚨 DEBUG: Showing urgent countdown for '\(bet.title)': '\(timeText)'")
                                }
                        } else if countdownInfo.isExpired {
                            Text("Deadline: EXPIRED")
                                .font(.caption)
                                .fontWeight(.bold)
                                .foregroundColor(.white)
                                .padding(.horizontal, 6)
                                .padding(.vertical, 2)
                                .background(Color.red)
                                .cornerRadius(4)
                        } else {
                            // Normal deadline display
                            Text("Deadline: \(formatDeadline(bet.deadline))")
                                .font(.caption)
                                .foregroundColor(.gray)
                                .onAppear {
                                    print("🚨 DEBUG: Showing normal deadline for '\(bet.title)': isUrgent=\(countdownInfo.isUrgent), isExpired=\(countdownInfo.isExpired)")
                                }
                        }
                    }
                    
                    Spacer()
                    
                    // Outcome Pill
                    OutcomePill(bet: bet, currentUserEmail: currentUserEmail)
                }
            }
            .padding(16)
            .background(Color.white)
            .cornerRadius(16)
            .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
        }
        .onAppear {
            startCountdownTimer()
        }
        .onDisappear {
            stopCountdownTimer()
        }
        .sheet(isPresented: $showingJoinBet) {
            JoinBetView(
                bet: bet, 
                firestoreService: firestoreService,
                onCommunityTap: {
                    // Navigate to community details
                    // This will be handled by the parent view
                }
            )
        }
        .sheet(isPresented: $showingBettingInterface) {
            let finalOption = selectedBettingOption.isEmpty ? bet.options.first ?? "Yes" : selectedBettingOption
            
            BettingInterfaceView(
                bet: bet,
                selectedOption: finalOption,
                firestoreService: firestoreService,
                onBetPlaced: nil
            )
            .onAppear {
                // 🐛 DEBUG: Sheet Presentation
                print("🎯 SHEET_ONAPPEAR: BettingInterfaceView sheet appeared")
                print("🎯 SHEET_ONAPPEAR: selectedBettingOption at sheet appear: '\(selectedBettingOption)'")
                print("🎯 SHEET_ONAPPEAR: showingBettingInterface: \(showingBettingInterface)")
                print("🎯 SHEET_ONAPPEAR: finalOption used: '\(finalOption)'")
                
                // 🐛 DEBUG: Betting Interface Option Resolution - COMPREHENSIVE
                print("🎯 BETTING_INTERFACE_RESOLUTION: ===== RESOLUTION DEBUG START =====")
                print("🎯 BETTING_INTERFACE_RESOLUTION: selectedBettingOption: '\(selectedBettingOption)'")
                print("🎯 BETTING_INTERFACE_RESOLUTION: selectedBettingOption.isEmpty: \(selectedBettingOption.isEmpty)")
                print("🎯 BETTING_INTERFACE_RESOLUTION: selectedBettingOption.count: \(selectedBettingOption.count)")
                print("🎯 BETTING_INTERFACE_RESOLUTION: bet.options: \(bet.options)")
                print("🎯 BETTING_INTERFACE_RESOLUTION: bet.options.first: '\(bet.options.first ?? "nil")'")
                print("🎯 BETTING_INTERFACE_RESOLUTION: Final resolved option: '\(finalOption)'")
                print("🎯 BETTING_INTERFACE_RESOLUTION: Bet ID: \(bet.id ?? "nil")")
                print("🎯 BETTING_INTERFACE_RESOLUTION: Bet title: '\(bet.title)'")
                print("🎯 BETTING_INTERFACE_RESOLUTION: showingBettingInterface: \(showingBettingInterface)")
                print("🎯 BETTING_INTERFACE_RESOLUTION: ===== RESOLUTION DEBUG END =====")
            }
        }
        .onAppear {
            print("🔍 ENHANCED_BET_CARD onAppear - Bet ID: \(bet.id ?? "nil")")
            print("🔍 ENHANCED_BET_CARD onAppear - Bet title: \(bet.title)")
            print("🔍 ENHANCED_BET_CARD onAppear - Bet status: \(bet.status)")
            print("🔍 ENHANCED_BET_CARD onAppear - Pool by option: \(bet.pool_by_option ?? [:])")
            print("🔍 ENHANCED_BET_CARD onAppear - Total pool: \(bet.total_pool ?? 0)")
            print("🔍 ENHANCED_BET_CARD onAppear - Options: \(bet.options)")
            print("🔍 ENHANCED_BET_CARD onAppear - Initial selectedBettingOption: '\(selectedBettingOption)'")
        }
        .onChange(of: selectedBettingOption) { oldValue, newValue in
            // 🐛 DEBUG: State Change Tracking
            print("🎯 SELECTED_BETTING_OPTION_CHANGE: ===== STATE CHANGE DEBUG =====")
            print("🎯 SELECTED_BETTING_OPTION_CHANGE: Old value: '\(oldValue)'")
            print("🎯 SELECTED_BETTING_OPTION_CHANGE: New value: '\(newValue)'")
            print("🎯 SELECTED_BETTING_OPTION_CHANGE: Bet ID: \(bet.id ?? "nil")")
            print("🎯 SELECTED_BETTING_OPTION_CHANGE: Bet title: '\(bet.title)'")
            print("🎯 SELECTED_BETTING_OPTION_CHANGE: =================================")
        }
    }
    
    private func getFirstNameFromEmail(_ email: String) -> String {
        // Extract first name from email (everything before @)
        let components = email.components(separatedBy: "@")
        if let username = components.first {
            // Capitalize first letter and return
            return username.prefix(1).uppercased() + username.dropFirst()
        }
        return email
    }
    
    private func getDisplayNameFromEmail(_ email: String) -> String {
        // Extract first name from email (everything before @)
        let components = email.components(separatedBy: "@")
        if let username = components.first {
            // Capitalize first letter and return
            return username.prefix(1).uppercased() + username.dropFirst()
        }
        return email
    }
    
    // Function to get user's full name, with caching
    private func getUserFullName(from email: String) -> String {
        // Check cache first
        if let cachedName = userFullNames[email] {
            return cachedName
        }
        
        // For current user, use local data
        if let user = firestoreService.currentUser, user.email == email {
            let fullName = "\(user.first_name ?? "") \(user.last_name ?? "")".trimmingCharacters(in: .whitespaces)
            userFullNames[email] = fullName
            return fullName
        }
        
        // For other users, fetch from Firestore and cache
        firestoreService.getUserDetails(email: email) { fullName, _ in
            DispatchQueue.main.async {
                self.userFullNames[email] = fullName
            }
        }
        
        // Return first name as fallback while fetching
        return email.components(separatedBy: "@").first ?? email
    }
    
    // Helper function to format deadline
    private func formatDeadline(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy"
        return formatter.string(from: date)
    }
}

// MARK: - Status Badge

struct StatusBadge: View {
    let status: String
    
    var statusColor: Color {
        switch status.lowercased() {
        case "open":
            return .orange
        case "matched":
            return .blue
        case "settled":
            return .green
        case "voided":
            return .red
        default:
            return .gray
        }
    }
    
    var statusText: String {
        switch status.lowercased() {
        case "open":
            return "" // Remove "Pending" text
        case "matched":
            return "Matched"
        case "settled":
            return "Settled"
        case "voided":
            return "Voided"
        default:
            return status.capitalized
        }
    }
    
    var body: some View {
        if !statusText.isEmpty {
            Text(statusText)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(.white)
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(statusColor)
                .cornerRadius(8)
        }
    }
}

// MARK: - Outcome Pill

struct OutcomePill: View {
    let bet: FirestoreBet
    let currentUserEmail: String?
    
    var body: some View {
        HStack(spacing: 4) {
            if bet.status.lowercased() == "matched" {
                Text("Matched")
                    .font(.caption)
                    .fontWeight(.medium)
                    .foregroundColor(.white)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.green)
                    .cornerRadius(8)
            }
            // Removed "Unmatched" pill for open bets
        }
    }
}

// MARK: - My Bets View

struct MyBetsView: View {
    @ObservedObject var firestoreService: FirestoreService
    @Binding var selectedTab: Int
    @State private var selectedPastBetFilter = "All"
    @State private var showingCreateBetModal = false
    @StateObject private var timeTracker = TimeTracker()
    
    // Computed properties for statistics
    private var activeBets: [FirestoreBet] {
        let currentUserEmail = firestoreService.currentUser?.email
        return firestoreService.bets.filter { bet in
            // Show bets where user has placed a wager OR created the bet, and the bet is still active
            let hasWager = firestoreService.userBetParticipations.contains { participation in
                participation.bet_id == bet.id && participation.user_email == currentUserEmail
            }
            let isCreator = bet.creator_email == currentUserEmail
            return (hasWager || isCreator) && (bet.status == "open" || bet.status == "pending")
        }
    }
    
    // Get all active bet participations for the current user (including multiple bets on same market)
    // Also includes bets created by user but not wagered on
    private var activeBetParticipations: [BetParticipant] {
        let currentUserEmail = firestoreService.currentUser?.email
        let now = Date()
        let twentyFourHoursFromNow = now.addingTimeInterval(24 * 60 * 60) // 24 hours in seconds
        
        // Get all participations from userBetParticipations
        let allParticipations = firestoreService.userBetParticipations.filter { participation in
            // Check if the bet is still active (open/pending) OR expired but not settled
            let bet = firestoreService.bets.first { $0.id == participation.bet_id }
            guard let bet = bet else { return false }
            
            let isActive = bet.status == "open" || bet.status == "pending"
            let isExpired = bet.deadline <= now
            let isNotSettled = bet.status != "settled" && bet.status != "cancelled" && bet.status != "voided"
            
            // Show if active OR (expired but not settled)
            let shouldShow = isActive || (isExpired && isNotSettled)
            
            if isExpired && isNotSettled {
                print("📱 MyBetsView: Showing expired bet in Active Bets: '\(bet.title)' (deadline: \(bet.deadline))")
            }
            
            return shouldShow
        }
        
        // Get bets created by user but not wagered on
        let createdBetsWithoutWagers = firestoreService.bets.filter { bet in
            let isCreator = bet.creator_email == currentUserEmail
            let isActive = bet.status == "open" || bet.status == "pending"
            let isExpired = bet.deadline <= now
            let isNotSettled = bet.status != "settled" && bet.status != "cancelled" && bet.status != "voided"
            let isActiveOrExpired = isActive || (isExpired && isNotSettled)
            
            // Check if user has any participations in this bet
            let hasParticipation = firestoreService.userBetParticipations.contains { participation in
                participation.bet_id == bet.id && participation.user_email == currentUserEmail
            }
            
            return isCreator && isActiveOrExpired && !hasParticipation
        }
        
        // Create virtual participations for created bets without wagers
        let virtualParticipations: [BetParticipant] = createdBetsWithoutWagers.compactMap { bet in
            guard let betId = bet.id else { return nil }
            return BetParticipant(
                id: "virtual_\(betId)",
                bet_id: betId,
                community_id: bet.community_id,
                user_email: currentUserEmail ?? "",
                chosen_option: "Creator", // Special marker for created bets
                stake_amount: 0, // No wager amount
                created_by: currentUserEmail ?? "",
                created_by_id: currentUserEmail ?? "",
                created_date: bet.created_date,
                updated_date: bet.updated_date ?? bet.created_date,
                is_winner: nil,
                final_payout: nil,
                locked_odds: nil
            )
        }
        
        // Combine real participations with virtual ones
        let allActiveParticipations = allParticipations + virtualParticipations
        
        print("📱 MyBetsView: \(allParticipations.count) real participations, \(virtualParticipations.count) created bets without wagers")
        
        // Separate urgent bets (expiring within 24 hours) from others
        let urgentParticipations = allActiveParticipations.filter { participation in
            let bet = firestoreService.bets.first { $0.id == participation.bet_id }
            guard let bet = bet else { return false }
            return bet.deadline <= twentyFourHoursFromNow && bet.deadline > now
        }
        
        let otherParticipations = allActiveParticipations.filter { participation in
            let bet = firestoreService.bets.first { $0.id == participation.bet_id }
            guard let bet = bet else { return false }
            return bet.deadline > twentyFourHoursFromNow || bet.deadline <= now
        }
        
        // Sort urgent bets by deadline (soonest first)
        let sortedUrgentParticipations = urgentParticipations.sorted { participation1, participation2 in
            let bet1 = firestoreService.bets.first { $0.id == participation1.bet_id }
            let bet2 = firestoreService.bets.first { $0.id == participation2.bet_id }
            guard let deadline1 = bet1?.deadline, let deadline2 = bet2?.deadline else { return false }
            return deadline1 < deadline2
        }
        
        // Sort other participations by creation date (most recent first) - current behavior
        let sortedOtherParticipations = otherParticipations.sorted { $0.created_date > $1.created_date }
        
        print("📱 MyBetsView: \(sortedUrgentParticipations.count) urgent bets, \(sortedOtherParticipations.count) other bets")
        
        // Return urgent bets first, then others
        return sortedUrgentParticipations + sortedOtherParticipations
    }
    

    
    // Updated to return individual bet participations instead of unique bets
    private var pastBetParticipations: [BetParticipant] {
        let currentUserEmail = firestoreService.currentUser?.email
        let now = Date()
        
        print("🔍 MyBetsView pastBetParticipations: Current user: \(currentUserEmail ?? "nil")")
        print("🔍 MyBetsView pastBetParticipations: User participations count: \(firestoreService.userBetParticipations.count)")
        
        // Get all user participations for past bets (settled, cancelled, expired)
        let pastParticipations = firestoreService.userBetParticipations.filter { participation in
            guard participation.user_email == currentUserEmail else { return false }
            
            // Find the corresponding bet
            guard let bet = firestoreService.bets.first(where: { $0.id == participation.bet_id }) else { return false }
            
            let isSettled = bet.status == "settled" || bet.status == "cancelled" || bet.status == "voided"
            let isExpired = bet.deadline <= now && (bet.status == "open" || bet.status == "pending")
            
            return isSettled || isExpired
        }
        
        // Also include created bets that are past (for users who created bets but didn't participate)
        let createdPastBets = firestoreService.bets.filter { bet in
            let isCreator = bet.creator_email == currentUserEmail
            let isSettled = bet.status == "settled" || bet.status == "cancelled" || bet.status == "voided"
            let isExpired = bet.deadline <= now && (bet.status == "open" || bet.status == "pending")
            
            // Only include if user is creator AND it's a past bet AND user hasn't participated
            if isCreator && (isSettled || isExpired) {
                let hasParticipation = firestoreService.userBetParticipations.contains { participation in
                    participation.bet_id == bet.id && participation.user_email == currentUserEmail
                }
                return !hasParticipation
            }
            return false
        }
        
        // Create virtual participations for created bets without actual participations
        let virtualParticipations: [BetParticipant] = createdPastBets.compactMap { bet in
            guard let betId = bet.id else { return nil }
            return BetParticipant(
                id: "virtual_past_\(betId)",
                bet_id: betId,
                community_id: bet.community_id,
                user_email: currentUserEmail ?? "",
                chosen_option: "Creator",
                stake_amount: 0,
                created_by: currentUserEmail ?? "",
                created_by_id: currentUserEmail ?? "",
                created_date: bet.created_date,
                updated_date: bet.updated_date ?? bet.created_date,
                is_winner: nil,
                final_payout: nil,
                locked_odds: nil
            )
        }
        
        let allPastParticipations = pastParticipations + virtualParticipations
        
        print("🔍 MyBetsView pastBetParticipations: Real participations: \(pastParticipations.count)")
        print("🔍 MyBetsView pastBetParticipations: Virtual participations: \(virtualParticipations.count)")
        print("🔍 MyBetsView pastBetParticipations: Total past participations: \(allPastParticipations.count)")
        
        // Sort by creation date (most recent first)
        return allPastParticipations.sorted { $0.created_date > $1.created_date }
    }
    
    // Legacy pastBets computed property - now derived from participations for compatibility
    private var pastBets: [FirestoreBet] {
        let uniqueBetIds = Set(pastBetParticipations.map { $0.bet_id })
        return firestoreService.bets.filter { bet in
            guard let betId = bet.id else { return false }
            return uniqueBetIds.contains(betId)
        }
    }
    
    private var wonBets: [FirestoreBet] {
        let currentUserEmail = firestoreService.currentUser?.email
        guard let userEmail = currentUserEmail else { return [] }
        
        return firestoreService.bets.filter { bet in
            if bet.status == "settled", let winnerOption = bet.winner_option {
                // Check if user participated and won
                return firestoreService.userBetParticipations.contains { participation in
                    participation.bet_id == bet.id && 
                    participation.user_email == userEmail && 
                    participation.chosen_option == winnerOption
                }
            }
            return false
        }
    }
    
    private var totalBets: Int {
        activeBets.count + pastBets.count
    }
    
    var body: some View {
        VStack(spacing: 0) {
            // Header with logo, title, and Create button (exact match to SimpleHeaderView structure)
            HStack(spacing: 12) {
                // Sling Logo and Title (exact copy from SimpleHeaderView)
                HStack(spacing: 8) {
                    Image("Logo")
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: 32, height: 32)
                        .cornerRadius(8)
                    
                    Text("My Bets")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                }
                    
                    Spacer()
                
                // Create Bet Button
                Button(action: {
                    AnalyticsService.shared.trackMyBetsInteraction(action: .createBet, betId: "new", betTitle: "Create Bet")
                    showingCreateBetModal = true
                }) {
                    HStack(spacing: 6) {
                        Image(systemName: "plus")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(.white)
                        
                        Text("Create")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(.white)
                    }
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(AnyShapeStyle(Color.slingGradient))
                    .cornerRadius(20)
                }
                }
                .padding(.horizontal, 16)
                .padding(.vertical, 12)
                .background(Color.white)
            
        ScrollView {
            VStack(spacing: 16) {
                
                // Dynamic Header Section - Shows "Active Bets" or "Markets to Bet On"
                VStack(alignment: .leading, spacing: 8) {
                    HStack {
                        Text(activeBets.isEmpty ? "Markets to Bet On" : "Active Bets")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                        
                        Spacer()
                    }
                    .padding(.horizontal, 16)
                    
                    if activeBets.isEmpty {
                        // No active bets - show Markets to Bet On section
                        let availableBets = getAvailableBetsToBetOn()
                        
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: 16) {
                                // Show available bets from user's communities
                                ForEach(availableBets, id: \.id) { bet in
                                    AvailableBetCard(bet: bet, firestoreService: firestoreService)
                                }
                                
                                // Show Create Bet card if no bets exist, otherwise show View More Markets
                                if availableBets.isEmpty {
                                    // Create Bet Card - when no bets exist at all
                                    Button(action: {
                                        AnalyticsService.shared.trackMyBetsInteraction(action: .createBet, betId: "new", betTitle: "Create Bet")
                                        showingCreateBetModal = true
                                    }) {
                                        VStack(spacing: 12) {
                                            Image(systemName: "plus.circle.fill")
                                                .font(.system(size: 32))
                                                .foregroundColor(.slingBlue)
                                            
                                            Text("Create Bet")
                                                .font(.subheadline)
                                                .fontWeight(.medium)
                                                .foregroundColor(.black)
                                            
                                            Text("Start a new bet")
                                                .font(.caption)
                                                .foregroundColor(.gray)
                                        }
                                        .frame(width: 160, height: 140)
                                        .background(Color.white)
                                        .cornerRadius(16)
                                        .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
                                    }
                                } else {
                                    // View More Markets Card - when some bets exist
                                Button(action: {
                                    AnalyticsService.shared.trackMyBetsInteraction(action: .viewDetails, betId: "home", betTitle: "View More Markets")
                                    // Navigate to home page by changing the selected tab
                                    selectedTab = 0
                                }) {
                                    VStack(spacing: 12) {
                                        Image(systemName: "plus.circle.fill")
                                            .font(.system(size: 32))
                                            .foregroundColor(.slingBlue)
                                        
                                        Text("View More Markets")
                                            .font(.subheadline)
                                            .fontWeight(.medium)
                                            .foregroundColor(.black)
                                        
                                        Text("Find more bets")
                                            .font(.caption)
                                            .foregroundColor(.gray)
                                    }
                                    .frame(width: 160, height: 140)
                                    .background(Color.white)
                                    .cornerRadius(16)
                                    .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
                                }
                                }
                            }
                            .padding(.horizontal, 16)
                            .padding(.vertical, 8)
                        }
                    } else {
                        // Has active bets - show Active Bets with Create Bet card
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: 16) {
                                ForEach(activeBetParticipations, id: \.id) { participation in
                                    if let bet = firestoreService.bets.first(where: { $0.id == participation.bet_id }) {
                                        ActiveBetParticipationCard(bet: bet, participation: participation, firestoreService: firestoreService)
                                    }
                                }
                                
                                // Create Bet Card
                                Button(action: {
                                    showingCreateBetModal = true
                                }) {
                                    VStack(spacing: 12) {
                                        Image(systemName: "plus.circle.fill")
                                            .font(.system(size: 32))
                                            .foregroundColor(.slingBlue)
                                        
                                        Text("Create Bet")
                                            .font(.subheadline)
                                            .fontWeight(.medium)
                                            .foregroundColor(.black)
                                        
                                        Text("Start a new bet")
                                            .font(.caption)
                                            .foregroundColor(.gray)
                                    }
                                    .frame(width: 160, height: 140)
                                    .background(Color.white)
                                    .cornerRadius(16)
                                    .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
                                }
                            }
                            .padding(.horizontal, 16)
                            .padding(.vertical, 8)
                        }
                    }
                }
                
                // Past Bets Section
                VStack(alignment: .leading, spacing: 8) {
                    HStack {
                                Text("Past Bets")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                        
                        Spacer()
                    }
                    .padding(.horizontal, 16)
                    
                    // Filter bar for past bets
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 12) {
                            Button(action: { selectedPastBetFilter = "All" }) {
                                Text("All")
                                    .font(.caption)
                                    .fontWeight(.medium)
                                    .foregroundColor(selectedPastBetFilter == "All" ? .white : .slingBlue)
                                    .padding(.horizontal, 12)
                                    .padding(.vertical, 6)
                                    .background(selectedPastBetFilter == "All" ? Color.slingBlue : Color.white)
                                    .cornerRadius(16)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 16)
                                            .stroke(selectedPastBetFilter == "All" ? Color.clear : Color.slingBlue, lineWidth: 1)
                                    )
                            }
                            
                            Button(action: { selectedPastBetFilter = "Won" }) {
                                Text("Won")
                                    .font(.caption)
                                    .fontWeight(.medium)
                                    .foregroundColor(selectedPastBetFilter == "Won" ? .white : .slingBlue)
                                    .padding(.horizontal, 12)
                                    .padding(.vertical, 6)
                                    .background(selectedPastBetFilter == "Won" ? Color.slingBlue : Color.white)
                                    .cornerRadius(16)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 16)
                                            .stroke(selectedPastBetFilter == "Won" ? Color.clear : Color.slingBlue, lineWidth: 1)
                                    )
                            }
                            
                            Button(action: { selectedPastBetFilter = "Created" }) {
                                Text("Created")
                                    .font(.caption)
                                    .fontWeight(.medium)
                                    .foregroundColor(selectedPastBetFilter == "Created" ? .white : .slingBlue)
                                    .padding(.horizontal, 12)
                                    .padding(.vertical, 6)
                                    .background(selectedPastBetFilter == "Created" ? Color.slingBlue : Color.white)
                                    .cornerRadius(16)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 16)
                                            .stroke(selectedPastBetFilter == "Created" ? Color.clear : Color.slingBlue, lineWidth: 1)
                                    )
                            }
                            
                            Button(action: { selectedPastBetFilter = "Voided" }) {
                                Text("Voided")
                                    .font(.caption)
                                    .fontWeight(.medium)
                                    .foregroundColor(selectedPastBetFilter == "Voided" ? .white : .slingBlue)
                                    .padding(.horizontal, 12)
                                    .padding(.vertical, 6)
                                    .background(selectedPastBetFilter == "Voided" ? Color.slingBlue : Color.white)
                                    .cornerRadius(16)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 16)
                                            .stroke(selectedPastBetFilter == "Voided" ? Color.clear : Color.slingBlue, lineWidth: 1)
                                    )
                            }
                            
                            Button(action: { selectedPastBetFilter = "Lost" }) {
                                Text("Lost")
                                    .font(.caption)
                                    .fontWeight(.medium)
                                    .foregroundColor(selectedPastBetFilter == "Lost" ? .white : .slingBlue)
                                    .padding(.horizontal, 12)
                                    .padding(.vertical, 6)
                                    .background(selectedPastBetFilter == "Lost" ? Color.slingBlue : Color.white)
                                    .cornerRadius(16)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 16)
                                            .stroke(selectedPastBetFilter == "Lost" ? Color.clear : Color.slingBlue, lineWidth: 1)
                                    )
                            }
                        }
                        .padding(.horizontal, 16)
                        .padding(.vertical, 8)
                    }
                    
                    // Horizontal line under filter row
                    Rectangle()
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 1)
                        .padding(.horizontal, 16)
                    
                    // Filter the past bet participations based on selected filter
                    let filteredPastParticipations = filterPastBetParticipations(pastBetParticipations, filter: selectedPastBetFilter)
                    
                    if filteredPastParticipations.isEmpty {
                        // No past bets to display
                        VStack(spacing: 16) {
                            Image(systemName: "tray")
                                .font(.system(size: 48))
                                .foregroundColor(.gray.opacity(0.5))
                            
                            Text("No Past Bets")
                                .font(.headline)
                                .fontWeight(.medium)
                                .foregroundColor(.gray)
                            
                            Text("You haven't participated in any settled or cancelled bets yet.")
                                .font(.subheadline)
                                .foregroundColor(.gray.opacity(0.8))
                                .multilineTextAlignment(.center)
                        }
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 40)
                        .padding(.horizontal, 16)
                    } else {
                        LazyVStack(spacing: 16) {
                            ForEach(filteredPastParticipations, id: \.id) { participation in
                                // Find the corresponding bet for this participation
                                if let bet = firestoreService.bets.first(where: { $0.id == participation.bet_id }) {
                                    CondensedBetParticipationCard(
                                        bet: bet, 
                                        participation: participation, 
                                        currentUserEmail: firestoreService.currentUser?.email, 
                                        firestoreService: firestoreService
                                    )
                                }
                            }
                        }
                        .padding(.horizontal, 0) // Remove padding so cards align with headers
                    }
                }
                
                // Past Bets section is now handled above
            }
            .padding(.bottom, 100) // Space for bottom tab bar
            }
        }
        .refreshable {
            // Refresh data when user pulls down
            await refreshData()
        }
        .background(Color.white)
        .onAppear {
            // Track my bets page view
            AnalyticsService.shared.trackUserFlowStep(step: .myBetsTab)
            AnalyticsService.shared.trackFeatureUsage(feature: "my_bets_page", context: "main_app")
            timeTracker.startTracking(for: "my_bets_page")
            
            // Track bet stats view
            AnalyticsService.shared.trackBetStatsView(statType: "active_bets", value: activeBets.count)
            AnalyticsService.shared.trackBetStatsView(statType: "past_bets", value: pastBets.count)
            AnalyticsService.shared.trackBetStatsView(statType: "won_bets", value: wonBets.count)
            AnalyticsService.shared.trackBetStatsView(statType: "total_bets", value: totalBets)
            
            firestoreService.fetchUserBets { _ in }
            firestoreService.fetchUserBetParticipations()
            firestoreService.fetchUserCommunities()
        }
        .onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)) { _ in
            firestoreService.fetchUserBets { _ in }
            firestoreService.fetchUserBetParticipations()
            firestoreService.fetchUserCommunities()
        }
        .onDisappear {
            // Track time spent on my bets page
            if let duration = timeTracker.endTracking(for: "my_bets_page") {
                AnalyticsService.shared.trackPageViewTime(page: "my_bets_page", timeSpent: duration)
            }
        }
        .sheet(isPresented: $showingCreateBetModal) {
            CreateBetView(firestoreService: firestoreService, preSelectedCommunity: nil)
        }

    }
    
    private func refreshData() async {
        // Update statistics for all user communities
        for community in firestoreService.userCommunities {
            if let communityId = community.id {
                firestoreService.updateCommunityStatistics(communityId: communityId) { success, error in
                    if let error = error {
                        print("❌ Error updating statistics for community \(communityId): \(error)")
                    }
                }
            }
        }
        
        // Fetch fresh data from Firestore
        firestoreService.fetchUserCommunities()
        firestoreService.fetchUserBets { _ in }
        firestoreService.fetchUserBetParticipations()
    }
    
    // MARK: - Helper Functions
    
    private func getAvailableBetsToBetOn() -> [FirestoreBet] {
        // Get available bets from user's communities that are open and not expired
        let currentDate = Date()
        return firestoreService.bets.filter { bet in
            let isOpen = bet.status.lowercased() == "open"
            let notExpired = bet.deadline > currentDate
            let isUserCommunity = firestoreService.userCommunities.contains { community in
                community.id == bet.community_id
            }
            let userNotParticipated = !firestoreService.userBetParticipations.contains { participation in
                participation.bet_id == bet.id
            }
            
            return isOpen && notExpired && isUserCommunity && userNotParticipated
        }
    }
    
    // New function to filter bet participations instead of unique bets
    private func filterPastBetParticipations(_ participations: [BetParticipant], filter: String) -> [BetParticipant] {
        print("🔍 filterPastBetParticipations: Filtering \(participations.count) participations with filter '\(filter)'")
        
        let currentUserEmail = firestoreService.currentUser?.email
        
        switch filter {
        case "Won":
            return participations.filter { participation in
                guard let bet = firestoreService.bets.first(where: { $0.id == participation.bet_id }) else { return false }
                
                if bet.status == "settled", let winnerOption = bet.winner_option {
                    return participation.chosen_option == winnerOption
                }
                return false
            }
        case "Created":
            return participations.filter { participation in
                return participation.chosen_option == "Creator"
            }
        case "Voided":
            return participations.filter { participation in
                guard let bet = firestoreService.bets.first(where: { $0.id == participation.bet_id }) else { return false }
                return bet.status == "voided"
            }
        case "Lost":
            return participations.filter { participation in
                guard let bet = firestoreService.bets.first(where: { $0.id == participation.bet_id }) else { return false }
                
                if bet.status == "settled", let winnerOption = bet.winner_option {
                    return participation.chosen_option != winnerOption && participation.chosen_option != "Creator"
                }
                return false
            }
        default: // "All"
            return participations
        }
    }
    
    // Legacy function for compatibility
    private func filterPastBets(_ bets: [FirestoreBet], filter: String) -> [FirestoreBet] {
        print("🔍 filterPastBets: Filtering \(bets.count) bets with filter '\(filter)'")
        
        switch filter {
        case "Won":
            return bets.filter { bet in
                if bet.status == "settled", let winnerOption = bet.winner_option {
                    // Check if user participated and won
                    let currentUserEmail = firestoreService.currentUser?.email
                    return firestoreService.userBetParticipations.contains { participation in
                        participation.bet_id == bet.id && 
                        participation.user_email == currentUserEmail && 
                        participation.chosen_option == winnerOption
                    }
                }
                return false
            }
        case "Created":
            return bets.filter { bet in
                // Show bets created by the user
                let currentUserEmail = firestoreService.currentUser?.email
                return bet.creator_email == currentUserEmail
            }
        case "Voided":
            return bets.filter { bet in
                if bet.status == "voided" {
                    // Check if user participated in this voided bet
                    let currentUserEmail = firestoreService.currentUser?.email
                    return firestoreService.userBetParticipations.contains { participation in
                        participation.bet_id == bet.id && 
                        participation.user_email == currentUserEmail
                    }
                }
                return false
            }
        case "Lost":
            return bets.filter { bet in
                if bet.status == "settled", let winnerOption = bet.winner_option {
                    // Check if user participated and lost
                    let currentUserEmail = firestoreService.currentUser?.email
                    return firestoreService.userBetParticipations.contains { participation in
                        participation.bet_id == bet.id && 
                        participation.user_email == currentUserEmail && 
                        participation.chosen_option != winnerOption
                    }
                }
                return false
            }
        default: // "All"
            print("🔍 filterPastBets: Returning all \(bets.count) bets (no filter)")
            return bets
        }
    }
}

// MARK: - Active Bet Card Component
struct ActiveBetCard: View {
    let bet: FirestoreBet
    @ObservedObject var firestoreService: FirestoreService
    @State private var showingSettleBetModal = false
    @State private var showingBetDetailSheet = false
    
    // Computed property for total amount wagered on this bet
    private var totalWageredAmount: Int {
        let participations = firestoreService.userBetParticipations.filter { $0.bet_id == bet.id }
        return participations.reduce(0) { $0 + $1.stake_amount }
    }
    
    // Computed property for user's choice on this bet
    private var userChoice: String {
        guard let currentUserEmail = firestoreService.currentUser?.email else { return "Creator" }
        guard let betId = bet.id else { return "Creator" }
        
        let participation = firestoreService.userBetParticipations.first { 
            $0.bet_id == betId && $0.user_email == currentUserEmail 
        }
        return participation?.chosen_option ?? "Creator"
    }
    
    // Computed property for user's wager amount on this bet
    private var userWagerAmount: Int {
        guard let currentUserEmail = firestoreService.currentUser?.email else { return 0 }
        guard let betId = bet.id else { return 0 }
        
        let participation = firestoreService.userBetParticipations.first { 
            $0.bet_id == betId && $0.user_email == currentUserEmail 
        }
        return participation?.stake_amount ?? 0
    }
    
    // Computed property to check if user is creator but hasn't placed a wager
    private var isCreatorWithoutWager: Bool {
        guard let currentUserEmail = firestoreService.currentUser?.email else { return false }
        return bet.creator_email == currentUserEmail && userWagerAmount == 0
    }
    
    // Computed property to check if user is creator and has placed a wager
    private var isCreatorWithWager: Bool {
        guard let currentUserEmail = firestoreService.currentUser?.email else { return false }
        return bet.creator_email == currentUserEmail && userWagerAmount > 0
    }
    
    // Helper function to format deadline
    private func formatDeadline(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy"
        return formatter.string(from: date)
    }
    
    var body: some View {
        Button(action: {
            showingBetDetailSheet = true
        }) {
            VStack(alignment: .leading, spacing: 0) {
                // Header section with choice and trophy icon
                HStack(alignment: .top) {
                    // Hero choice at the top (like the second image)
                    Text(userChoice)
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    
                    // Settle Bet button for creators who have wagered
                    if isCreatorWithWager {
                        Button(action: {
                            showingSettleBetModal = true
                        }) {
                            Image(systemName: "trophy.fill")
                                .font(.caption)
                                .foregroundColor(.slingBlue)
                                .padding(4)
                                .background(Color.slingBlue.opacity(0.1))
                                .clipShape(Circle())
                        }
                        .buttonStyle(.plain)
                    }
                }
                .padding(.bottom, 4)
                
                // Bet title below the choice
                Text(bet.title)
                    .font(.caption)
                    .foregroundColor(.gray)
                    .lineLimit(2)
                    .multilineTextAlignment(.leading)
                    .padding(.bottom, 8)
                
                // Deadline
                Text("Deadline: \(formatDeadline(bet.deadline))")
                    .font(.caption2)
                    .foregroundColor(.gray)
                    .padding(.bottom, 8)
                
                // Show odds for user's choice
                HStack {
                    Text("\(userChoice)")
                        .font(.caption2)
                        .foregroundColor(.gray)
                    
                    Spacer()
                    
                    Text({
                        let calculatedOdds = firestoreService.calculateImpliedOdds(for: bet)
                        let optionOdds = calculatedOdds[userChoice] ?? 0.5
                        let formattedOdds = firestoreService.formatImpliedOdds(optionOdds)
                        
                        // Debug logging for active bet card
                        print("🔍 ACTIVE_BET_CARD DEBUG - Bet ID: \(bet.id ?? "nil")")
                        print("🔍 ACTIVE_BET_CARD DEBUG - User choice: \(userChoice)")
                        print("🔍 ACTIVE_BET_CARD DEBUG - Calculated odds: \(calculatedOdds)")
                        print("🔍 ACTIVE_BET_CARD DEBUG - Option odds: \(optionOdds)")
                        print("🔍 ACTIVE_BET_CARD DEBUG - Formatted odds: \(formattedOdds)")
                        
                        return formattedOdds
                    }())
                        .font(.caption2)
                        .fontWeight(.medium)
                        .foregroundColor(.slingBlue)
                }
                .padding(.bottom, 8)
                
                // Wager or Settle Bet line
                if isCreatorWithoutWager {
                    // Show Settle Bet for creators who haven't wagered
                    Button(action: {
                        showingSettleBetModal = true
                    }) {
                        HStack(spacing: 4) {
                            Text("Settle Bet")
                                .font(.caption2)
                                .fontWeight(.medium)
                                .foregroundStyle(Color.slingGradient)
                            
                            Image(systemName: "arrow.right")
                                .font(.caption2)
                                .foregroundColor(.slingBlue)
                        }
                    }
                    .buttonStyle(.plain)
                } else if isCreatorWithWager {
                    // Show wager amount for creators who have wagered
                    HStack(spacing: 4) {
                        Text("Wager:")
                            .font(.caption2)
                            .foregroundColor(.gray)
                        
                        Image(systemName: "bolt.fill")
                            .font(.caption2)
                            .foregroundColor(.slingBlue)
                        
                        Text("\(userWagerAmount)")
                            .font(.caption2)
                            .foregroundColor(.gray)
                    }
                } else {
                    // Show wager amount for participants
                    HStack(spacing: 4) {
                        Text("Wager:")
                            .font(.caption2)
                            .foregroundColor(.gray)
                        
                        Image(systemName: "bolt.fill")
                            .font(.caption2)
                            .foregroundColor(.slingBlue)
                        
                        Text("\(userWagerAmount)")
                            .font(.caption2)
                            .foregroundColor(.gray)
                    }
                }
            }
            .padding(16)
            .frame(width: 160, height: 140)
            .background(Color.white)
            .cornerRadius(16)
            .overlay(
                RoundedRectangle(cornerRadius: 16)
                    .stroke(Color.gray.opacity(0.1), lineWidth: 1)
            )
            .shadow(color: .black.opacity(0.06), radius: 8, x: 0, y: 2)
        }
        .buttonStyle(.plain)
        .sheet(isPresented: $showingSettleBetModal) {
            SettleBetModal(bet: bet, firestoreService: firestoreService)
        }
        .sheet(isPresented: $showingBetDetailSheet) {
            JoinBetView(
                bet: bet, 
                firestoreService: firestoreService,
                onCommunityTap: nil
            )
        }
        .onAppear {
            print("🔍 ActiveBetCard Debug:")
            print("  - Bet ID: \(bet.id ?? "nil")")
            print("  - Bet Title: \(bet.title)")
            print("  - User Email: \(firestoreService.currentUser?.email ?? "nil")")
            print("  - User Participations: \(firestoreService.userBetParticipations.count)")
            print("  - User Choice: \(userChoice)")
            print("  - User Wager: \(userWagerAmount)")
            print("  - Is Creator: \(bet.creator_email == firestoreService.currentUser?.email)")
            print("  - Is Creator With Wager: \(isCreatorWithWager)")
            print("  - Is Creator Without Wager: \(isCreatorWithoutWager)")
        }
    }
}

// MARK: - Active Bet Participation Card Component
struct ActiveBetParticipationCard: View {
    let bet: FirestoreBet
    let participation: BetParticipant
    @ObservedObject var firestoreService: FirestoreService
    @State private var showingSettleBetModal = false
    @State private var showingBetDetailSheet = false
    @State private var isRemindButtonPressed = false
    @State private var remindButtonScale: CGFloat = 1.0
    @State private var countdownTimer: Timer?
    @State private var currentTime = Date()
    
    // Helper function to format deadline
    private func formatDeadline(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy"
        return formatter.string(from: date)
    }
    
    // Timer lifecycle
    private func startCountdownTimer() {
        countdownTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in
            currentTime = Date()
        }
    }
    
    private func stopCountdownTimer() {
        countdownTimer?.invalidate()
        countdownTimer = nil
    }
    
    // Get countdown info
    private var countdownInfo: (timeString: String, isUrgent: Bool, isExpired: Bool) {
        let info = firestoreService.getCountdownTime(for: bet.deadline)
        print("⏰ ActiveBetParticipationCard: Bet '\(bet.title)' - Time: '\(info.timeString)', Urgent: \(info.isUrgent), Expired: \(info.isExpired)")
        return info
    }
    
    // Helper function to handle remind action
    private func handleRemindAction() {
        // Add haptic feedback
        let impactFeedback = UIImpactFeedbackGenerator(style: .medium)
        impactFeedback.impactOccurred()
        
        // Animate the button press
        withAnimation(.easeInOut(duration: 0.1)) {
            remindButtonScale = 0.8
        }
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            withAnimation(.easeInOut(duration: 0.1)) {
                remindButtonScale = 1.0
            }
        }
        
        // Send reminder notification to bet creator
        firestoreService.createRemindToSettleNotification(
            for: bet.creator_email,
            betTitle: bet.title,
            communityId: bet.community_id,
            communityName: bet.community_name,
            communityIcon: nil
        ) { success in
            if success {
                print("✅ Reminder notification sent to bet creator: \(bet.creator_email)")
            } else {
                print("❌ Failed to send reminder notification")
            }
        }
    }
    
    var body: some View {
        Button(action: {
            showingBetDetailSheet = true
        }) {
            VStack(alignment: .leading, spacing: 0) {
                // Header section with choice, odds, and trophy icon
                HStack(alignment: .top) {
                    HStack(spacing: 8) {
                        // Hero choice at the top
                        Text(participation.chosen_option == "Creator" ? "Created" : participation.chosen_option)
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                        
                        // Show odds next to choice if option text isn't too long and not a creator bet
                        if participation.chosen_option != "Creator" && participation.chosen_option.count <= 12 {
                            Text({
                                // Use locked odds if available, otherwise fall back to current odds
                                if let lockedOdds = participation.locked_odds,
                                   let optionOdds = lockedOdds[participation.chosen_option] {
                                    print("🔒 ActiveBetParticipationCard: Using LOCKED odds for \(participation.chosen_option): \(optionOdds)")
                                    return firestoreService.formatImpliedOdds(optionOdds)
                                } else {
                                    print("🔒 ActiveBetParticipationCard: No locked odds, using current odds for \(participation.chosen_option)")
                                    let calculatedOdds = firestoreService.calculateImpliedOdds(for: bet)
                                    let optionOdds = calculatedOdds[participation.chosen_option] ?? 0.5
                                    return firestoreService.formatImpliedOdds(optionOdds)
                                }
                            }())
                                .font(.subheadline)
                                .fontWeight(.semibold)
                                .foregroundStyle(Color.slingGradient)
                        }
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                    
                    // Action button - trophy for creators, bell for participants
                    if bet.creator_email == firestoreService.currentUser?.email {
                        // Trophy icon for bet creators
                        Button(action: {
                            showingSettleBetModal = true
                        }) {
                            Image(systemName: "trophy.fill")
                                .font(.caption)
                                .foregroundColor(.slingBlue)
                                .padding(4)
                                .background(Color.slingBlue.opacity(0.1))
                                .clipShape(Circle())
                        }
                        .buttonStyle(.plain)
                    } else {
                        // Bell icon for bet participants (remind creator to settle)
                        Button(action: {
                            handleRemindAction()
                        }) {
                            Image(systemName: "bell.fill")
                                .font(.caption)
                                .foregroundColor(.orange)
                                .padding(4)
                                .background(Color.orange.opacity(0.1))
                                .clipShape(Circle())
                                .scaleEffect(remindButtonScale)
                        }
                        .buttonStyle(.plain)
                    }
                }
                .padding(.bottom, 4)
                
                // Bet title below the choice - force two lines for consistent layout
                Text(bet.title)
                    .font(.caption)
                    .foregroundColor(.gray)
                    .lineLimit(2)
                    .multilineTextAlignment(.leading)
                    .frame(height: 32, alignment: .topLeading) // Force two lines visually
                    .padding(.bottom, 8)
                
                // Deadline with countdown
                VStack(alignment: .leading, spacing: 2) {
                    if countdownInfo.isUrgent && !countdownInfo.isExpired {
                        // Show countdown in deadline line with red background
                        Text("Deadline: \(countdownInfo.timeString)")
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(.red)
                            .padding(.horizontal, 4)
                            .padding(.vertical, 1)
                            .background(Color.red.opacity(0.1))
                            .cornerRadius(3)
                    } else if countdownInfo.isExpired {
                        Text("Deadline: EXPIRED")
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                            .padding(.horizontal, 4)
                            .padding(.vertical, 1)
                            .background(Color.red)
                            .cornerRadius(3)
                    } else {
                        // Normal deadline display
                        Text("Deadline: \(formatDeadline(bet.deadline))")
                            .font(.caption2)
                            .foregroundColor(.gray)
                    }
                }
                .padding(.bottom, 8)
                
                // Show wager amount for this specific participation (or settle bet status)
                if participation.chosen_option == "Creator" {
                    Button(action: {
                        showingSettleBetModal = true
                    }) {
                        HStack(spacing: 4) {
                            Text("Settle Bet")
                                .font(.caption2)
                                .fontWeight(.medium)
                                .foregroundColor(.slingBlue)
                            
                            Image(systemName: "chevron.right")
                                .font(.caption2)
                                .foregroundColor(.slingBlue)
                        }
                    }
                    .buttonStyle(.plain)
                } else {
                    HStack(spacing: 4) {
                        Text("Wager:")
                            .font(.caption2)
                            .foregroundColor(.gray)
                        
                        Image(systemName: "bolt.fill")
                            .font(.caption2)
                            .foregroundColor(.slingBlue)
                        
                        Text("\(participation.stake_amount)")
                            .font(.caption2)
                            .foregroundColor(.gray)
                    }
                }
            }
            .padding(16)
            .frame(width: 160, height: 140)
            .background(Color.white)
            .cornerRadius(16)
            .overlay(
                RoundedRectangle(cornerRadius: 16)
                    .stroke(Color.gray.opacity(0.1), lineWidth: 1)
            )
            .shadow(color: .black.opacity(0.06), radius: 8, x: 0, y: 2)
        }
        .buttonStyle(.plain)
        .onAppear {
            startCountdownTimer()
        }
        .onDisappear {
            stopCountdownTimer()
        }
        .sheet(isPresented: $showingSettleBetModal) {
            SettleBetModal(bet: bet, firestoreService: firestoreService)
        }
        .sheet(isPresented: $showingBetDetailSheet) {
            JoinBetView(
                bet: bet, 
                firestoreService: firestoreService,
                onCommunityTap: nil
            )
        }
    }
}

// MARK: - Active Bet Detail View
struct ActiveBetDetailView: View {
    let bet: FirestoreBet
    @ObservedObject var firestoreService: FirestoreService
    @Environment(\.dismiss) private var dismiss
    @State private var showingSettleBetModal = false
    @State private var userFullNames: [String: String] = [:]
    @State private var oddsHistory: [OddsHistoryEntry] = []
    
    private var communityName: String {
        if let community = firestoreService.userCommunities.first(where: { $0.id == bet.community_id }) {
            return community.name
        }
        return "Community"
    }
    
    private var isCreator: Bool {
        return bet.creator_email == firestoreService.currentUser?.email
    }
    
    private var participants: [BetParticipant] {
        return firestoreService.userBetParticipations.filter { $0.bet_id == bet.id }
    }
    
    private var totalWagered: Int {
        return participants.reduce(0) { $0 + $1.stake_amount }
    }
    
    var body: some View {
        let _ = print("🔍 ActiveBetDetailView: Rendering body for bet: \(bet.title)")
        let _ = print("🔍 ActiveBetDetailView: Current oddsHistory count: \(oddsHistory.count)")
        
        return NavigationView {
            ScrollView {
                VStack(alignment: .leading, spacing: 20) {
                    // Header
                    VStack(alignment: .leading, spacing: 12) {
                        HStack {
                            Text(communityName)
                                .font(.subheadline)
                                .foregroundColor(.gray)
                            Spacer()
                            Text(bet.status.capitalized)
                                .font(.caption)
                                .fontWeight(.medium)
                                .foregroundColor(.slingBlue)
                                .padding(.horizontal, 8)
                                .padding(.vertical, 4)
                                .background(Color.slingBlue.opacity(0.1))
                                .cornerRadius(8)
                        }
                        
                        Text(bet.title)
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                        
                        Text("Deadline: \(formatDeadline(bet.deadline))")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                    }
                    .padding(.horizontal, 20)
                    
                    // Betting Options
                    VStack(alignment: .leading, spacing: 16) {
                        Text("Betting Options")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                            .padding(.horizontal, 20)
                        
                        VStack(spacing: 12) {
                            ForEach(bet.options, id: \.self) { option in
                                HStack {
                                    Text(option)
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                        .foregroundColor(.black)
                                    
                                    Spacer()
                                    
                                    Text({
                                        let calculatedOdds = firestoreService.calculateImpliedOdds(for: bet)
                                        let optionOdds = calculatedOdds[option] ?? 0.5
                                        let formattedOdds = firestoreService.formatImpliedOdds(optionOdds)
                                        
                                        // Debug logging for bet details view
                                        print("🔍 BET DETAILS DEBUG - Bet ID: \(bet.id ?? "nil")")
                                        print("🔍 BET DETAILS DEBUG - Option: \(option)")
                                        print("🔍 BET DETAILS DEBUG - Bet pool_by_option: \(bet.pool_by_option ?? [:])")
                                        print("🔍 BET DETAILS DEBUG - Bet total_pool: \(bet.total_pool ?? 0)")
                                        print("🔍 BET DETAILS DEBUG - Calculated odds dict: \(calculatedOdds)")
                                        print("🔍 BET DETAILS DEBUG - Option odds: \(optionOdds)")
                                        print("🔍 BET DETAILS DEBUG - Formatted odds: \(formattedOdds)")
                                        
                                        return formattedOdds
                                    }())
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                        .foregroundColor(.gray)
                                }
                                .padding(.horizontal, 20)
                                .padding(.vertical, 12)
                                .background(Color.gray.opacity(0.05))
                                .cornerRadius(8)
                            }
                        }
                    }
                    
                    // Odds History Chart
                    let _ = print("🔍 ActiveBetDetailView: About to render OddsHistoryChart with \(oddsHistory.count) entries")
                    
                    // Test view to see if this section is rendering at all
                    VStack {
                        Text("TEST: Chart section is rendering")
                            .foregroundColor(.red)
                            .font(.headline)
                            .padding()
                            .background(Color.yellow)
                        
                        OddsHistoryChart(bet: bet, oddsHistory: oddsHistory, firestoreService: firestoreService)
                            .onAppear {
                                print("🔍 ActiveBetDetailView: OddsHistoryChart appeared on screen")
                        }
                    }
                    
                    // Participants List
                    VStack(alignment: .leading, spacing: 16) {
                        HStack {
                            Text("Participants (\(participants.count))")
                                .font(.headline)
                                .fontWeight(.semibold)
                                .foregroundColor(.black)
                            
                            Spacer()
                            
                            HStack(spacing: 4) {
                                Image(systemName: "bolt.fill")
                                    .font(.caption)
                                    .foregroundColor(.slingBlue)
                                Text("\(totalWagered)")
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                    .foregroundColor(.black)
                            }
                        }
                        .padding(.horizontal, 20)
                        
                        if participants.isEmpty {
                            Text("No participants yet")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                                .frame(maxWidth: .infinity, alignment: .center)
                                .padding(.vertical, 20)
                        } else {
                            VStack(spacing: 12) {
                                ForEach(participants, id: \.id) { participant in
                                    HStack {
                                        VStack(alignment: .leading, spacing: 4) {
                                            Text(getUserFullName(from: participant.user_email))
                                                .font(.subheadline)
                                                .fontWeight(.medium)
                                                .foregroundColor(.black)
                                            
                                            HStack(spacing: 4) {
                                                Text(participant.chosen_option)
                                                    .font(.caption)
                                                    .foregroundColor(.gray)
                                                
                                                Text("•")
                                                    .font(.caption)
                                                    .foregroundColor(.gray)
                                                
                                                Image(systemName: "bolt.fill")
                                                    .font(.caption)
                                                    .foregroundColor(.yellow)
                                                
                                                Text(String(participant.stake_amount))
                                                    .font(.caption)
                                                    .foregroundColor(.gray)
                                            }
                                        }
                                        
                                        Spacer()
                                        
                                        HStack(spacing: 4) {
                                            Image(systemName: "bolt.fill")
                                                .font(.caption)
                                                .foregroundColor(.slingBlue)
                                            Text("\(participant.stake_amount)")
                                                .font(.subheadline)
                                                .fontWeight(.medium)
                                                .foregroundColor(.black)
                                        }
                                    }
                                    .padding(.horizontal, 20)
                                    .padding(.vertical, 12)
                                    .background(Color.white)
                                    .cornerRadius(8)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 8)
                                            .stroke(Color.gray.opacity(0.2), lineWidth: 1)
                                    )
                                }
                            }
                        }
                    }
                    
                    // Action Buttons
                    if isCreator {
                        VStack(spacing: 12) {
                            Button(action: {
                                showingSettleBetModal = true
                            }) {
                                HStack(spacing: 8) {
                                    Text("Settle Bet")
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                    
                                    Image(systemName: "arrow.right")
                                        .font(.caption)
                                        .foregroundColor(.white)
                                }
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 12)
                                .background(Color.slingBlue)
                                .cornerRadius(8)
                            }
                        }
                        .padding(.horizontal, 20)
                    }
                }
                .padding(.vertical, 20)
            }
            .navigationTitle("Bet Details")
            .navigationBarTitleDisplayMode(.inline)
            .navigationBarItems(
                trailing: Button("Done") {
                    dismiss()
                }
            )
            .onAppear {
                print("🔍 ActiveBetDetailView: onAppear called for bet: \(bet.title)")
                print("🔍 ActiveBetDetailView: Bet ID: \(bet.id ?? "nil")")
                print("🔍 ActiveBetDetailView: Bet status: \(bet.status)")
                print("🔍 ActiveBetDetailView: Pool by option: \(bet.pool_by_option ?? [:])")
                print("🔍 ActiveBetDetailView: Total pool: \(bet.total_pool ?? 0)")
                print("🔍 ActiveBetDetailView: Options: \(bet.options)")
                loadOddsHistory()
            }
        }
        .sheet(isPresented: $showingSettleBetModal) {
            SettleBetModal(bet: bet, firestoreService: firestoreService)
        }
    }
    
    private func formatDeadline(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy 'at' h:mm a"
        return formatter.string(from: date)
    }
    
    private func loadOddsHistory() {
        guard let betId = bet.id else { 
            print("❌ loadOddsHistory: No bet ID available")
            return 
        }
        
        print("🔍 loadOddsHistory: Loading odds history for bet: \(betId)")
        
        firestoreService.fetchOddsHistory(for: betId) { historyEntries in
            DispatchQueue.main.async {
                print("📊 loadOddsHistory: Received \(historyEntries.count) history entries")
                
                if historyEntries.isEmpty {
                    // If no real data, show sample data for demonstration
                    print("📊 loadOddsHistory: No real data, generating sample data")
                    self.generateSampleOddsHistory()
                } else {
                    print("📊 loadOddsHistory: Using real data")
                    self.oddsHistory = historyEntries
                }
                
                print("📊 loadOddsHistory: Final oddsHistory count: \(self.oddsHistory.count)")
            }
        }
    }
    
    private func generateSampleOddsHistory() {
        guard let betId = bet.id else { 
            print("❌ generateSampleOddsHistory: No bet ID available")
            return 
        }
        
        print("🔍 generateSampleOddsHistory: Generating sample data for bet: \(betId)")
        print("🔍 generateSampleOddsHistory: Bet options: \(bet.options)")
        
        var sampleHistory: [OddsHistoryEntry] = []
        let options = bet.options
        
        // Generate sample data points over the last 7 days
        for i in 0..<10 {
            let timestamp = Calendar.current.date(byAdding: .hour, value: -i * 12, to: Date()) ?? Date()
            
            var oddsByOption: [String: Double] = [:]
            var poolByOption: [String: Int] = [:]
            
            // Generate realistic odds progression
            for (index, option) in options.enumerated() {
                let baseOdds = Double(index + 1) / Double(options.count)
                let variation = sin(Double(i) * 0.5 + Double(index)) * 0.2
                let odds = max(0.1, min(0.9, baseOdds + variation))
                
                oddsByOption[option] = odds
                poolByOption[option] = Int(odds * 1000) + Int.random(in: 0...200)
            }
            
            let totalPool = poolByOption.values.reduce(0, +)
            
            let entry = OddsHistoryEntry(
                bet_id: betId,
                odds_by_option: oddsByOption,
                total_pool: totalPool,
                pool_by_option: poolByOption
            )
            
            sampleHistory.append(entry)
        }
        
        oddsHistory = sampleHistory.reversed() // Show oldest to newest
        print("✅ generateSampleOddsHistory: Generated \(oddsHistory.count) sample entries")
    }
    
    // Function to get user's full name, with caching
    private func getUserFullName(from email: String) -> String {
        // Check cache first
        if let cachedName = userFullNames[email] {
            return cachedName
        }
        
        // For current user, use local data
        if let user = firestoreService.currentUser, user.email == email {
            let fullName = "\(user.first_name ?? "") \(user.last_name ?? "")".trimmingCharacters(in: .whitespaces)
            userFullNames[email] = fullName
            return fullName
        }
        
        // For other users, fetch from Firestore and cache
        firestoreService.getUserDetails(email: email) { fullName, _ in
            DispatchQueue.main.async {
                self.userFullNames[email] = fullName
            }
        }
        
        // Return first name as fallback while fetching
        return email.components(separatedBy: "@").first ?? email
    }
}

// MARK: - Settle Bet Modal
struct SettleBetModal: View {
    let bet: FirestoreBet
    @ObservedObject var firestoreService: FirestoreService
    @Environment(\.dismiss) private var dismiss
    @State private var selectedWinner: String = ""
    @State private var isLoading = false
    @State private var showingConfirmation = false
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                Text("Settle Bet")
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.black)
                
                Text("Select the winning option for:")
                    .font(.subheadline)
                    .foregroundColor(.gray)
                
                Text(bet.title)
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                    .multilineTextAlignment(.center)
                
                // Betting options
                VStack(spacing: 12) {
                    ForEach(bet.options, id: \.self) { option in
                        Button(action: {
                            selectedWinner = option
                        }) {
                            HStack {
                                Text(option)
                                    .font(.subheadline)
                                    .foregroundColor(selectedWinner == option ? .white : .black)
                                
                                Spacer()
                                
                                if selectedWinner == option {
                                    Image(systemName: "checkmark.circle.fill")
                                        .foregroundColor(.white)
                                }
                            }
                            .padding(.horizontal, 16)
                            .padding(.vertical, 12)
                            .background(selectedWinner == option ? Color.slingBlue : Color.gray.opacity(0.1))
                            .cornerRadius(10)
                        }
                    }
                }
                
                Spacer()
                
                // Action buttons
                HStack(spacing: 16) {
                    Button("Cancel") {
                        dismiss()
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 12)
                    .background(Color.gray.opacity(0.1))
                    .foregroundColor(.black)
                    .cornerRadius(10)
                    
                                                    Button(action: {
                    showingConfirmation = true
                }) {
                    HStack {
                        if isLoading {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                .scaleEffect(0.8)
                        } else {
                            Text("Settle Bet")
                        }
                    }
                }
                .frame(maxWidth: .infinity)
                .padding(.vertical, 12)
                .background(selectedWinner.isEmpty ? Color.gray.opacity(0.3) : Color.slingBlue)
                .foregroundColor(.white)
                .cornerRadius(10)
                .disabled(selectedWinner.isEmpty || isLoading)
                }
            }
            .padding(20)
            .navigationBarHidden(true)
        }
        .alert("Confirm Settlement", isPresented: $showingConfirmation) {
            Button("Cancel", role: .cancel) { }
            Button("Settle Bet") {
                settleBet()
            }
        } message: {
            Text("Are you sure you want to settle this bet with '\(selectedWinner)' as the winner? This action cannot be undone.")
        }
    }
    
    private func settleBet() {
        guard !selectedWinner.isEmpty else { return }
        
        isLoading = true
        
        firestoreService.settleBet(betId: bet.id ?? "", winnerOption: selectedWinner) { success in
            DispatchQueue.main.async {
                isLoading = false
                if success {
                    print("✅ Bet settled successfully!")
                    dismiss()
                } else {
                    print("❌ Error settling bet")
                    // You could add an error alert here if needed
                }
            }
        }
    }
}

// MARK: - My Bet Card Component
struct MyBetCard: View {
    let bet: FirestoreBet
    let currentUserEmail: String?
    @ObservedObject var firestoreService: FirestoreService
    
    // MARK: - State
    @State private var offset: CGFloat = 0
    @State private var showingCancelAlert = false
    @State private var showingDeleteAlert = false
    @State private var selectedBettingOption = ""
    @State private var hasRemindedCreator = false
    @State private var showImageFullscreen = false
    @State private var selectedImageUrl: String?
    
    // MARK: - Cached Computed Values (Performance Optimization)
    @State private var cachedCommunityName: String = ""
    @State private var cachedUserParticipation: BetParticipant?
    @State private var cachedCreatorDisplayName: String = ""
    @State private var cachedUserChoice: String = ""
    @State private var cachedUserWager: Double = 0
    @State private var cachedIsCreator: Bool = false
    @State private var cachedHasWager: Bool = false
    
    // MARK: - Sheet Management
    private enum ActiveSheet: Identifiable {
        case chooseWinner, placeBet, share, betDetail, bettingInterface
        var id: Int { hashValue }
    }
    @State private var activeSheet: ActiveSheet?
    
    // MARK: - Constants
    private let swipeThreshold: CGFloat = 80
    private let maxSwipeDistance: CGFloat = 240
    
    private var communityName: String {
        return cachedCommunityName
    }
    
    private var creatorDisplayName: String {
        return cachedCreatorDisplayName
    }
    
    private var userParticipation: BetParticipant? {
        return cachedUserParticipation
    }
    
    private var isCreator: Bool {
        return cachedIsCreator
    }
    
    private var hasWager: Bool {
        return cachedHasWager
    }
    
    private var userChoice: String {
        return cachedUserChoice
    }
    
    private var userWager: Double {
        return cachedUserWager
    }
    
    private var formattedClosingDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d 'at' h:mm a"
        return formatter.string(from: bet.deadline)
    }
    
    private var getCreatorInitials: String {
        if bet.creator_email == currentUserEmail {
            // Use current user initials if this user is the creator
            let user = firestoreService.currentUser
            if let firstName = user?.first_name, let lastName = user?.last_name, !firstName.isEmpty, !lastName.isEmpty {
                let firstInitial = String(firstName.prefix(1)).uppercased()
                let lastInitial = String(lastName.prefix(1)).uppercased()
                return "\(firstInitial)\(lastInitial)"
            } else if let displayName = user?.display_name, !displayName.isEmpty {
                let components = displayName.components(separatedBy: " ")
                if components.count >= 2 {
                    let firstInitial = String(components[0].prefix(1)).uppercased()
                    let lastInitial = String(components[1].prefix(1)).uppercased()
                    return "\(firstInitial)\(lastInitial)"
                } else if components.count == 1 {
                    return String(components[0].prefix(1)).uppercased()
                }
            }
            // Fallback to email initial
            return String(bet.creator_email.prefix(1)).uppercased()
        } else {
            // For other users, use the first letter of their display name or email
            return String(bet.creator_email.prefix(1)).uppercased()
        }
    }
    
    // Action buttons for swipe
    private var actionButtonsView: some View {
        HStack(spacing: 12) {
            if isCreator {
                // Cancel/Delete button for creators
                Button(action: {
                    if bet.status == "open" {
                        showingCancelAlert = true
                    } else {
                        showingDeleteAlert = true
                    }
                }) {
                    Image(systemName: bet.status == "open" ? "xmark.circle.fill" : "trash.fill")
                        .font(.title2)
                        .foregroundColor(.white)
                        .frame(width: 50, height: 50)
                        .background(Color.red)
                        .clipShape(Circle())
                }
                
                if bet.status == "open" {
                    // Choose winner button
                    Button(action: {
                        activeSheet = .chooseWinner
                    }) {
                        Image(systemName: "trophy.fill")
                            .font(.title2)
                            .foregroundColor(.white)
                            .frame(width: 50, height: 50)
                            .background(Color.green)
                            .clipShape(Circle())
                    }
                }
            }
            
            // Share button (for everyone)
            Button(action: {
                activeSheet = .share
            }) {
                Image(systemName: "square.and.arrow.up")
                    .font(.title2)
                    .foregroundColor(.white)
                    .frame(width: 50, height: 50)
                    .background(AnyShapeStyle(Color.slingGradient))
                    .clipShape(Circle())
            }
        }
        .padding(.trailing, 16)
    }
    
    var body: some View {
        ZStack {
            // Background action buttons - only show when swiped
            if offset < 0 {
                HStack {
                    Spacer()
                    actionButtonsView
                }
            }
            
            // Main card content - Exact layout from image
            VStack(alignment: .leading, spacing: 0) {
                // Top section with image, title, and status
                HStack(alignment: .top, spacing: 12) {
                    // Square image like in the reference
                    if let imageURL = bet.image_url, !imageURL.isEmpty {
                        AsyncImage(url: URL(string: imageURL)) { phase in
                            switch phase {
                            case .success(let image):
                                image
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                                    .frame(width: 64, height: 64)
                                    .clipped()
                                    .cornerRadius(12)
                                    .onTapGesture {
                                        selectedImageUrl = imageURL
                                        showImageFullscreen = true
                                    }
                            case .failure(_), .empty:
                                RoundedRectangle(cornerRadius: 12)
                                    .fill(Color.gray.opacity(0.2))
                                    .frame(width: 64, height: 64)
                                    .overlay(
                                        Text(getCreatorInitials)
                                            .font(.subheadline)
                                            .fontWeight(.bold)
                                            .foregroundColor(.gray)
                                    )
                            @unknown default:
                                EmptyView()
                            }
                        }
                    } else {
                        RoundedRectangle(cornerRadius: 12)
                            .fill(Color.gray.opacity(0.2))
                            .frame(width: 64, height: 64)
                            .overlay(
                                Text(getCreatorInitials)
                                    .font(.subheadline)
                                    .fontWeight(.bold)
                                    .foregroundColor(.gray)
                            )
                    }
                    
                    VStack(alignment: .leading, spacing: 8) {
                        HStack {
                            // Bet title - matches main feed
                            Text(bet.title)
                                .font(.headline)
                                .fontWeight(.semibold)
                                .foregroundColor(.black)
                                .multilineTextAlignment(.leading)
                            
                            Spacer()
                            
                            // Status badge
                            Text(bet.status.uppercased())
                                .font(.system(size: 12, weight: .bold))
                                .foregroundColor(.white)
                                .padding(.horizontal, 12)
                                .padding(.vertical, 6)
                                .background(bet.status == "open" ? Color.green : Color.gray)
                                .cornerRadius(12)
                        }
                        
                        // Community and creator info - matches main feed
                        HStack(spacing: 4) {
                            Image(systemName: "person.2")
                                .font(.caption)
                                .foregroundColor(.gray)
                            
                            Text("\(communityName) • by \(creatorDisplayName)")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }
                        
                        // Betting deadline - matches main feed
                        Text("Deadline: \(formattedClosingDate)")
                            .font(.caption)
                            .foregroundColor(.gray)
                    }
                }
                .padding(.bottom, 16)
                
                // Bottom section - Choice and Wager (always show grey box)
                HStack(alignment: .center, spacing: 0) {
                    // Left side - You Picked
                    VStack(alignment: .leading, spacing: 4) {
                        Text("You Picked")
                            .font(.system(size: 14))
                            .foregroundColor(.gray)
                        
                        if hasWager {
                            Text(userChoice)
                                .font(.system(size: 20, weight: .bold))
                                .foregroundColor(.black)
                        } else if isCreator {
                            HStack(spacing: 4) {
                                Image(systemName: "crown.fill")
                                    .font(.system(size: 16))
                                    .foregroundColor(.purple)
                                Text("Creator")
                                    .font(.system(size: 16, weight: .semibold))
                                    .foregroundColor(.purple)
                            }
                        } else {
                            Text("No bet placed")
                                .font(.system(size: 16))
                                .foregroundColor(.gray)
                        }
                    }
                    
                    Spacer()
                    
                    // Right side - Wager or Action
                    VStack(alignment: .trailing, spacing: 4) {
                        Text("Wager")
                            .font(.system(size: 14))
                            .foregroundColor(.gray)
                        
                        if hasWager {
                            HStack(spacing: 4) {
                                Image(systemName: "bolt.fill")
                                    .font(.system(size: 20))
                                    .foregroundColor(Color.slingBlue)
                                
                                Text(String(format: "%.2f", userWager))
                                    .font(.system(size: 20, weight: .bold))
                                    .foregroundColor(Color.slingBlue)
                            }
                        } else {
                            Button(action: {
                                activeSheet = .placeBet
                            }) {
                                HStack(spacing: 4) {
                                    Text("place bet")
                                        .font(.system(size: 14, weight: .semibold))
                                    
                                    Image(systemName: "arrow.right")
                                        .font(.system(size: 12, weight: .semibold))
                                }
                                .foregroundColor(Color.slingBlue)
                                .padding(.horizontal, 12)
                                .padding(.vertical, 6)
                                .background(Color.slingLightBlue)
                                    .cornerRadius(6)
                            }
                        }
                    }
                }
                .padding(.horizontal, 16)
                .padding(.vertical, 12)
                .background(Color.gray.opacity(0.1))
                .cornerRadius(12)
            }
            .padding(16)
            .background(Color.white)
            .cornerRadius(16)
            .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
            .offset(x: offset)
            .onTapGesture {
                // Only handle tap if card is not swiped
                if offset != 0 {
                    // Reset swipe when tapping on the card
                    withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                        offset = 0
                    }
                } else {
                    activeSheet = .betDetail
                }
            }
            .gesture(
                DragGesture()
                    .onChanged { value in
                        let translation = value.translation.width
                        if translation < 0 { // Only allow left swipe
                            offset = max(translation, -maxSwipeDistance)
                        } else if offset < 0 { // Allow right swipe only if already swiped left
                            offset = min(offset + translation, 0)
                        }
                    }
                    .onEnded { value in
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                            if offset < -swipeThreshold {
                                offset = -240 // Show all actions
                            } else {
                                offset = 0 // Hide actions
                            }
                        }
                    }
            )
        }
        .clipped()
        .alert("Cancel Bet", isPresented: $showingCancelAlert) {
            Button("Cancel", role: .destructive) {
                cancelBet()
            }
            Button("Keep Bet", role: .cancel) { }
        } message: {
            Text("Are you sure you want to cancel this bet? This action cannot be undone.")
        }
        .alert("Delete Bet", isPresented: $showingDeleteAlert) {
            Button("Delete", role: .destructive) {
                deleteBet()
            }
            Button("Cancel", role: .cancel) { }
        } message: {
            Text("Are you sure you want to delete this bet? This action cannot be undone.")
        }
        .sheet(item: $activeSheet) { sheet in
            switch sheet {
            case .chooseWinner:
                ChooseWinnerView(bet: bet, firestoreService: firestoreService)
            case .placeBet:
                PlaceBetView(bet: bet, presetOption: nil, firestoreService: firestoreService, onBetPlaced: nil)
            case .share:
                ShareSheet(activityItems: [generateShareText()])
            case .betDetail:
                JoinBetView(
                    bet: bet, 
                    firestoreService: firestoreService,
                    onCommunityTap: {
                        // Navigate to community details
                        // This will be handled by the parent view
                    }
                )
            case .bettingInterface:
                let finalOption = selectedBettingOption.isEmpty ? (bet.options.first ?? "Yes") : selectedBettingOption
                
                BettingInterfaceView(
                    bet: bet,
                    selectedOption: finalOption,
                    firestoreService: firestoreService,
                    onBetPlaced: nil
                )
                .onAppear {
                    // 🐛 DEBUG: Navigation-based BettingInterfaceView
                    print("🎯 NAVIGATION_BETTING_INTERFACE: ===== NAVIGATION DEBUG START =====")
                    print("🎯 NAVIGATION_BETTING_INTERFACE: selectedBettingOption: '\(selectedBettingOption)'")
                    print("🎯 NAVIGATION_BETTING_INTERFACE: selectedBettingOption.isEmpty: \(selectedBettingOption.isEmpty)")
                    print("🎯 NAVIGATION_BETTING_INTERFACE: finalOption: '\(finalOption)'")
                    print("🎯 NAVIGATION_BETTING_INTERFACE: Bet ID: \(bet.id ?? "nil")")
                    print("🎯 NAVIGATION_BETTING_INTERFACE: Bet title: '\(bet.title)'")
                    print("🎯 NAVIGATION_BETTING_INTERFACE: ===== NAVIGATION DEBUG END =====")
                }
            }
        }
        .onAppear {
            // Cache expensive computed values to prevent recalculation on every render
            if let community = firestoreService.userCommunities.first(where: { $0.id == bet.community_id }) {
                cachedCommunityName = community.name
            } else {
                cachedCommunityName = "ZBT Basketball 2025"
            }
            
            if bet.creator_email == currentUserEmail {
                cachedCreatorDisplayName = "You"
            } else {
                let emailComponents = bet.creator_email.components(separatedBy: "@")
                cachedCreatorDisplayName = emailComponents.first ?? "elonmusk"
            }
            
            cachedUserParticipation = firestoreService.userBetParticipations.first { participation in
                participation.bet_id == bet.id && participation.user_email == currentUserEmail
            }
            
            cachedIsCreator = currentUserEmail == bet.creator_email
            cachedHasWager = cachedUserParticipation != nil
            
            if let participation = cachedUserParticipation {
                let optionWithOdds = firestoreService.formatImpliedOdds(firestoreService.calculateImpliedOdds(for: bet)[participation.chosen_option] ?? 0.5)
                cachedUserChoice = "\(participation.chosen_option) \(optionWithOdds)".trimmingCharacters(in: .whitespaces)
            } else {
                cachedUserChoice = "Over -110"
            }
            
            cachedUserWager = Double(cachedUserParticipation?.stake_amount ?? 0)
        }
        .fullScreenCover(isPresented: $showImageFullscreen) {
            if let imageUrl = selectedImageUrl {
                FullscreenImageView(imageUrl: imageUrl, isPresented: $showImageFullscreen)
            }
        }
    }
    
    private func cancelBet() {
        firestoreService.cancelMarket(betId: bet.id ?? "") { success in
            if success {
                print("✅ Bet cancelled successfully")
            } else {
                print("❌ Error cancelling bet")
            }
        }
    }
    
    private func deleteBet() {
        firestoreService.deleteBet(betId: bet.id ?? "") { success in
            if success {
                print("✅ Bet deleted successfully")
            } else {
                print("❌ Error deleting bet")
            }
        }
    }
    
    private func generateShareText() -> String {
        return "Check out this prediction on Sling: \(bet.title)"
    }
}

// MARK: - Condensed Bet Card Component (matches image format)
struct CondensedBetCard: View {
    let bet: FirestoreBet
    let currentUserEmail: String?
    @ObservedObject var firestoreService: FirestoreService
    
    // MARK: - State
    @State private var showingCancelAlert = false
    @State private var showingDeleteAlert = false
    @State private var selectedBettingOption = ""
    @State private var offset: CGFloat = 0
    @State private var userFullNames: [String: String] = [:]
    @State private var showingBetDetail = false
    
    // MARK: - Constants
    private let swipeThreshold: CGFloat = 80
    private let maxSwipeDistance: CGFloat = 240
    
    // MARK: - Sheet Management
    private enum ActiveSheet: Identifiable {
        case chooseWinner, placeBet, share, betDetail, bettingInterface
        var id: Int { hashValue }
    }
    @State private var activeSheet: ActiveSheet?
    
    // MARK: - Computed Properties
    private var communityName: String {
        let communityId = bet.community_id
        if let community = firestoreService.userCommunities.first(where: { $0.id == communityId }) {
            return community.name
        }
        return "Unknown Community"
    }
    
    private var creatorDisplayName: String {
        if bet.creator_email == currentUserEmail {
            return "You"
        }
        return getUserFullName(from: bet.creator_email)
    }
    
    // Function to get user's full name, with caching
    private func getUserFullName(from email: String) -> String {
        // Check cache first
        if let cachedName = userFullNames[email] {
            return cachedName
        }
        
        // For current user, use local data
        if let user = firestoreService.currentUser, user.email == email {
            let fullName = "\(user.first_name ?? "") \(user.last_name ?? "")".trimmingCharacters(in: .whitespaces)
            userFullNames[email] = fullName
            return fullName
        }
        
        // For other users, fetch from Firestore and cache
        firestoreService.getUserDetails(email: email) { fullName, _ in
            DispatchQueue.main.async {
                self.userFullNames[email] = fullName
            }
        }
        
        // Return first name as fallback while fetching
        return email.components(separatedBy: "@").first ?? email
    }
    
    private var userParticipation: BetParticipant? {
        guard let currentUserEmail = currentUserEmail else { return nil }
        let participation = firestoreService.userBetParticipations.first { participation in
            participation.bet_id == bet.id && participation.user_email == currentUserEmail
        }
        return participation
    }
    
    private var isCreator: Bool {
        return bet.creator_email == currentUserEmail
    }
    
    private var hasWager: Bool {
        return userParticipation != nil
    }
    
    private var userChoice: String {
        return userParticipation?.chosen_option ?? ""
    }
    
    private var userWager: Int {
        return userParticipation?.stake_amount ?? 0
    }
    
    private var statusColor: Color {
        switch bet.status.lowercased() {
        case "open":
            return .green
        case "pending":
            return .orange
        case "settled":
            return .blue
        case "cancelled":
            return .red
        default:
            return .gray
        }
    }
    
    // Action buttons for swipe
    private var actionButtonsView: some View {
        HStack(spacing: 12) {
            if isCreator {
                // Cancel/Delete button for creators
                Button(action: {
                    if bet.status == "open" {
                        showingCancelAlert = true
                    } else {
                        showingDeleteAlert = true
                    }
                }) {
                    Image(systemName: bet.status == "open" ? "xmark.circle.fill" : "trash.fill")
                        .font(.title2)
                        .foregroundColor(.white)
                        .frame(width: 50, height: 50)
                        .background(Color.red)
                        .clipShape(Circle())
                }
                
                if bet.status == "open" {
                    // Choose winner button
                    Button(action: {
                        activeSheet = .chooseWinner
                    }) {
                        Image(systemName: "trophy.fill")
                            .font(.title2)
                            .foregroundColor(.white)
                            .frame(width: 50, height: 50)
                            .background(Color.green)
                            .clipShape(Circle())
                    }
                }
            }
            
            // Share button (for everyone)
            Button(action: {
                activeSheet = .share
            }) {
                Image(systemName: "square.and.arrow.up")
                    .font(.title2)
                    .foregroundColor(.white)
                    .frame(width: 50, height: 50)
                    .background(AnyShapeStyle(Color.slingGradient))
                    .clipShape(Circle())
            }
        }
        .padding(.trailing, 16)
    }
    
    private var getCreatorInitials: String {
        if bet.creator_email == currentUserEmail {
            // Use current user initials if this user is the creator
            let user = firestoreService.currentUser
            if let firstName = user?.first_name, let lastName = user?.last_name, !firstName.isEmpty, !lastName.isEmpty {
                let firstInitial = String(firstName.prefix(1)).uppercased()
                let lastInitial = String(lastName.prefix(1)).uppercased()
                return "\(firstInitial)\(lastInitial)"
            } else if let displayName = user?.display_name, !displayName.isEmpty {
                let components = displayName.components(separatedBy: " ")
                if components.count >= 2 {
                    let firstInitial = String(components[0].prefix(1)).uppercased()
                    let lastInitial = String(components[1].prefix(1)).uppercased()
                    return "\(firstInitial)\(lastInitial)"
                } else if components.count == 1 {
                    return String(components[0].prefix(1)).uppercased()
                }
            }
            // Fallback to email initial
            return String(bet.creator_email.prefix(1)).uppercased()
        } else {
            // For other users, use the first letter of their display name or email
            return String(bet.creator_email.prefix(1)).uppercased()
        }
    }
    
    // Helper to get time when bet was placed by user
    private var timeBetWasPlaced: String {
        if let participation = userParticipation {
            return formatTimestamp(participation.created_date)
        }
        // Fallback to bet creation date if no participation found
        return formatTimestamp(bet.created_date)
    }
    
    private func formatTimestamp(_ date: Date) -> String {
        let now = Date()
        let timeInterval = now.timeIntervalSince(date)
        
        if timeInterval < 60 {
            return "Just now"
        } else if timeInterval < 3600 {
            let minutes = Int(timeInterval / 60)
            return "\(minutes)m ago"
        } else if timeInterval < 86400 {
            let hours = Int(timeInterval / 3600)
            return "\(hours)h ago"
        } else if timeInterval < 2592000 {
            let days = Int(timeInterval / 86400)
            return "\(days)d ago"
        } else {
            let formatter = DateFormatter()
            formatter.dateFormat = "MMM d"
            return formatter.string(from: date)
        }
    }
    
    // Activity title - just the bet title
    private var activityTitle: String {
        return bet.title
    }
    
    // Activity subtitle showing choice and wager/payout
    private var activitySubtitle: String {
        if let participation = userParticipation {
            if bet.status == "settled" {
                if let winnerOption = bet.winner_option {
                    let isWinner = participation.chosen_option == winnerOption
                    if isWinner {
                        let payout = participation.final_payout ?? participation.stake_amount
                        return "Chose: \(participation.chosen_option) • Paid: ⚡ \(payout)"
                    } else {
                        return "Chose: \(participation.chosen_option) • Lost: ⚡ \(participation.stake_amount)"
                    }
                }
            } else if bet.status == "voided" {
                let refund = participation.final_payout ?? participation.stake_amount
                return "Chose: \(participation.chosen_option) • Refunded: ⚡ \(refund)"
            }
            return "Chose: \(participation.chosen_option) • Wager: ⚡ \(participation.stake_amount)"
        }
        return "No participation found"
    }
    
    // Activity icon based on bet status
    private var activityIcon: String {
        if let participation = userParticipation {
            if bet.status == "settled" {
                if let winnerOption = bet.winner_option {
                    let isWinner = participation.chosen_option == winnerOption
                    return isWinner ? "trophy.fill" : "xmark.circle.fill"
                }
                return "checkmark.circle.fill"
            } else if bet.status == "voided" {
                return "arrow.clockwise.circle.fill"
            } else {
                return "bolt.fill"
            }
        } else if isCreator {
            return "plus.circle.fill"
        } else {
            return "questionmark.circle.fill"
        }
    }
    
    // Activity icon color
    private var activityIconColor: Color {
        if let participation = userParticipation {
            if bet.status == "settled" {
                if let winnerOption = bet.winner_option {
                    let isWinner = participation.chosen_option == winnerOption
                    return isWinner ? .green : .red
                }
                return .blue
            } else if bet.status == "voided" {
                return .orange
            } else {
                return .slingBlue
            }
        } else if isCreator {
            return .blue
        } else {
            return .gray
        }
    }
    
    // Status badge for top right
    private var statusBadge: some View {
        Group {
            if let participation = userParticipation {
                if bet.status == "settled" {
                    if let winnerOption = bet.winner_option {
                        let isWinner = participation.chosen_option == winnerOption
                        Text(isWinner ? "Won" : "Lost")
                            .font(.caption)
                            .fontWeight(.medium)
                            .foregroundColor(isWinner ? .green : .red)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 4)
                            .background(isWinner ? Color.green.opacity(0.15) : Color.red.opacity(0.15))
                            .cornerRadius(12)
                    } else {
                        Text("Settled")
                            .font(.caption)
                            .fontWeight(.medium)
                            .foregroundColor(.blue)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 4)
                            .background(Color.blue.opacity(0.15))
                            .cornerRadius(12)
                    }
                } else if bet.status == "voided" {
                    Text("Voided")
                        .font(.caption)
                        .fontWeight(.medium)
                        .foregroundColor(.orange)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(Color.orange.opacity(0.15))
                        .cornerRadius(12)
                }
            }
        }
    }

    var body: some View {
        HStack(alignment: .top, spacing: 16) {
            // Bet image (48x48 like activity section)
            if let imageURL = bet.image_url, !imageURL.isEmpty {
                AsyncImage(url: URL(string: imageURL)) { phase in
                    switch phase {
                    case .success(let image):
                        image
                            .resizable()
                                .aspectRatio(contentMode: .fill)
                            .frame(width: 48, height: 48)
                            .clipped()
                            .cornerRadius(8)
                    case .failure(_), .empty:
                        // Fallback to generated image
                        BetImageView(title: bet.title, imageURL: nil, size: 48)
                    @unknown default:
                        BetImageView(title: bet.title, imageURL: nil, size: 48)
                    }
                }
            } else {
                // No image URL, use generated image
                BetImageView(title: bet.title, imageURL: nil, size: 48)
            }
                
            VStack(alignment: .leading, spacing: 6) {
                // Top row: Activity title and status badge
                HStack(alignment: .top) {
                    // Activity title (no time ago)
                    Text(activityTitle)
                        .font(.system(size: 15, weight: .semibold))
                        .foregroundColor(.primary)
                        .multilineTextAlignment(.leading)
                        .lineLimit(2)
                    
                    Spacer()
                    
                    // Status badge in top right
                    statusBadge
                }
                
                // Activity subtitle (chose, wager/payout info)
                HStack(spacing: 0) {
                    Text("Chose: ")
                        .font(.system(size: 14, weight: .regular))
                        .foregroundColor(.secondary)
                    
                    Text(userChoice.isEmpty ? "No choice made" : userChoice)
                        .font(.system(size: 14, weight: .semibold))
                        .foregroundStyle(Color.slingGradient)
                    
                    Text(" • ")
                        .font(.system(size: 14, weight: .regular))
                        .foregroundColor(.secondary)
                    
                    if bet.status == "settled" && hasWager {
                        if let participation = userParticipation, let winnerOption = bet.winner_option {
                            if participation.chosen_option == winnerOption {
                                // User won - show payout
                                Text("Paid: ")
                                    .font(.system(size: 14, weight: .regular))
                                    .foregroundColor(.secondary)
                                
                                Image(systemName: "bolt.fill")
                                    .font(.system(size: 12, weight: .medium))
                                    .foregroundStyle(Color.slingGradient)
                                
                                Text("\(participation.final_payout ?? participation.stake_amount)")
                                    .font(.system(size: 14, weight: .regular))
                                    .foregroundColor(.secondary)
                            } else {
                                // User lost - show lost amount
                                Text("Lost: ")
                                    .font(.system(size: 14, weight: .regular))
                                    .foregroundColor(.secondary)
                                
                                Image(systemName: "bolt.fill")
                                    .font(.system(size: 12, weight: .medium))
                                    .foregroundStyle(Color.slingGradient)
                                
                                Text("\(participation.stake_amount)")
                                    .font(.system(size: 14, weight: .regular))
                                    .foregroundColor(.secondary)
                            }
                        }
                    } else if bet.status == "voided" && hasWager {
                        // Voided bet - show refund
                        Text("Refunded: ")
                            .font(.system(size: 14, weight: .regular))
                            .foregroundColor(.secondary)
                        
                        Image(systemName: "bolt.fill")
                            .font(.system(size: 12, weight: .medium))
                            .foregroundStyle(Color.slingGradient)
                        
                        Text("\(userParticipation?.final_payout ?? userWager)")
                            .font(.system(size: 14, weight: .regular))
                            .foregroundColor(.secondary)
                    } else {
                        // Active bet - show wager
                        Text("Wager: ")
                            .font(.system(size: 14, weight: .regular))
                            .foregroundColor(.secondary)
                        
                        Image(systemName: "bolt.fill")
                            .font(.system(size: 12, weight: .medium))
                            .foregroundStyle(Color.slingGradient)
                        
                        Text("\(userWager)")
                            .font(.system(size: 14, weight: .regular))
                            .foregroundColor(.secondary)
                    }
                }
                .multilineTextAlignment(.leading)
                .lineLimit(1)
            }
        }
        .padding(.horizontal, 16) // Internal padding for card content
        .padding(.vertical, 16)
        .background(Color.white)
        .cornerRadius(12)
        .shadow(color: Color.black.opacity(0.05), radius: 2, x: 0, y: 1)
        .onTapGesture {
            showingBetDetail = true
        }
        .sheet(isPresented: $showingBetDetail) {
            JoinBetView(
                bet: bet,
                firestoreService: firestoreService,
                onCommunityTap: {
                    // Handle community tap if needed
                }
            )
        }
    }
}

// MARK: - Available Bet Card Component

struct AvailableBetCard: View {
    let bet: FirestoreBet
    @ObservedObject var firestoreService: FirestoreService
    @State private var showingBetDetail = false
    
    private var communityName: String {
        let communityId = bet.community_id
        if let community = firestoreService.userCommunities.first(where: { $0.id == communityId }) {
            return community.name
        }
        return "Unknown Community"
    }
    
    private func getOddsForOption(_ option: String) -> String {
        return firestoreService.formatImpliedOdds(firestoreService.calculateImpliedOdds(for: bet)[option] ?? 0.5)
    }
    
    var body: some View {
        Button(action: {
            showingBetDetail = true
        }) {
            VStack(alignment: .leading, spacing: 8) {
                // Padding above bet title
                Spacer()
                    .frame(height: 8)
                
                // Bet title - larger font with proper wrapping
                Text(bet.title)
                    .font(.subheadline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                    .lineLimit(3)
                    .multilineTextAlignment(.leading)
                    .fixedSize(horizontal: false, vertical: true)
                
                // Community name with icon right under the title
                HStack(alignment: .top, spacing: 6) {
                    Image(systemName: "person.2")
                        .font(.caption2)
                        .foregroundColor(.gray)
                        .frame(width: 12, height: 12)
                    
                    Text(communityName)
                        .font(.caption2)
                        .foregroundColor(.gray)
                        .fontWeight(.medium)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                        .fixedSize(horizontal: false, vertical: true)
                }
                
                // Show odds for each option
                VStack(alignment: .leading, spacing: 4) {
                    ForEach(bet.options, id: \.self) { option in
                        HStack {
                            Text(option)
                                .font(.caption2)
                                .foregroundColor(.gray)
                            
                            Spacer()
                            
                            Text({
                                let calculatedOdds = firestoreService.calculateImpliedOdds(for: bet)
                                let optionOdds = calculatedOdds[option] ?? 0.5
                                let formattedOdds = firestoreService.formatImpliedOdds(optionOdds)
                                
                                // Debug logging for available bet card
                                print("🔍 AVAILABLE_BET_CARD DEBUG - Bet ID: \(bet.id ?? "nil")")
                                print("🔍 AVAILABLE_BET_CARD DEBUG - Option: \(option)")
                                print("🔍 AVAILABLE_BET_CARD DEBUG - Calculated odds: \(calculatedOdds)")
                                print("🔍 AVAILABLE_BET_CARD DEBUG - Option odds: \(optionOdds)")
                                print("🔍 AVAILABLE_BET_CARD DEBUG - Formatted odds: \(formattedOdds)")
                                
                                return formattedOdds
                            }())
                                .font(.caption2)
                                .fontWeight(.medium)
                                .foregroundColor(.slingBlue)
                        }
                    }
                }
                
                // Bet Now Button
                HStack {
                    HStack(spacing: 8) {
                        Text("Bet")
                                .font(.subheadline)
                            .fontWeight(.semibold)
                            .foregroundColor(.white)
                                .lineLimit(1)
                            .minimumScaleFactor(0.8)
                        
                        Image(systemName: "arrow.right")
                            .font(.caption)
                            .fontWeight(.semibold)
                            .foregroundColor(.white)
                    }
                    .padding(.horizontal, 24)
                    .padding(.vertical, 10)
                    .frame(maxWidth: .infinity)
                    .background(AnyShapeStyle(Color.slingGradient))
                    .cornerRadius(12)
                }
                
                Spacer()
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .frame(width: 160, height: 160)
            .background(Color.white)
            .cornerRadius(16)
            .overlay(
                RoundedRectangle(cornerRadius: 16)
                    .stroke(Color.gray.opacity(0.15), lineWidth: 1)
            )
            .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
        }
        .buttonStyle(.plain)
        .sheet(isPresented: $showingBetDetail) {
            JoinBetView(
                bet: bet,
                firestoreService: firestoreService,
                onCommunityTap: {
                    // Navigate to community details
                }
            )
        }
    }
}

// MARK: - Message Group

struct MessageGroup {
    let date: Date
    let dateHeader: String
    let messages: [CommunityMessage]
}

// MARK: - Chat List Item

struct ChatListItem: Identifiable {
    let id: String
    let communityId: String
    let communityName: String
    let lastMessage: String
    let timestamp: Date  // Changed from String to Date for proper sorting
    let timestampString: String  // Keep formatted string for display
    let unreadCount: Int
    let imageUrl: String
}

// MARK: - Condensed Bet Participation Card

struct CondensedBetParticipationCard: View {
    let bet: FirestoreBet
    let participation: BetParticipant
    let currentUserEmail: String?
    @ObservedObject var firestoreService: FirestoreService
    @State private var showingBetDetail = false
    
    // Activity title - just the bet title
    private var activityTitle: String {
        return bet.title
    }
    
    // Activity subtitle showing choice and wager/payout for this specific participation
    private var activitySubtitle: String {
        if participation.chosen_option == "Creator" {
            return "Created this bet"
        }
        
        if bet.status == "settled" {
            if let winnerOption = bet.winner_option {
                let isWinner = participation.chosen_option == winnerOption
                if isWinner {
                    let payout = participation.final_payout ?? participation.stake_amount
                    return "Chose: \(participation.chosen_option) • Paid: ⚡ \(payout)"
                } else {
                    return "Chose: \(participation.chosen_option) • Lost: ⚡ \(participation.stake_amount)"
                }
            }
        } else if bet.status == "voided" {
            let refund = participation.final_payout ?? participation.stake_amount
            return "Chose: \(participation.chosen_option) • Refunded: ⚡ \(refund)"
        }
        return "Chose: \(participation.chosen_option) • Wager: ⚡ \(participation.stake_amount)"
    }
    
    // Status badge for top right
    private var statusBadge: some View {
        Group {
            if participation.chosen_option == "Creator" {
                Text("Created")
                    .font(.caption)
                    .fontWeight(.medium)
                    .foregroundColor(.blue)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.blue.opacity(0.15))
                    .cornerRadius(12)
            } else if bet.status == "settled" {
                if let winnerOption = bet.winner_option {
                    let isWinner = participation.chosen_option == winnerOption
                    Text(isWinner ? "Won" : "Lost")
                        .font(.caption)
                        .fontWeight(.medium)
                        .foregroundColor(isWinner ? .green : .red)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(isWinner ? Color.green.opacity(0.15) : Color.red.opacity(0.15))
                        .cornerRadius(12)
                } else {
                    Text("Settled")
                        .font(.caption)
                        .fontWeight(.medium)
                        .foregroundColor(.blue)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(Color.blue.opacity(0.15))
                        .cornerRadius(12)
                }
            } else if bet.status == "voided" {
                Text("Voided")
                    .font(.caption)
                    .fontWeight(.medium)
                    .foregroundColor(.orange)
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.orange.opacity(0.15))
                    .cornerRadius(12)
            }
        }
    }
    
    var body: some View {
        HStack(alignment: .top, spacing: 16) {
            // Bet image (48x48 like activity section)
            if let imageURL = bet.image_url, !imageURL.isEmpty {
                AsyncImage(url: URL(string: imageURL)) { phase in
                    switch phase {
                    case .success(let image):
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .frame(width: 48, height: 48)
                            .clipped()
                            .cornerRadius(8)
                    case .failure(_), .empty:
                        // Fallback to generated image
                        BetImageView(title: bet.title, imageURL: nil, size: 48)
                    @unknown default:
                        BetImageView(title: bet.title, imageURL: nil, size: 48)
                    }
                }
            } else {
                // No image URL, use generated image
                BetImageView(title: bet.title, imageURL: nil, size: 48)
            }
            
            VStack(alignment: .leading, spacing: 6) {
                // Top row: Activity title and status badge
                HStack(alignment: .top) {
                    // Activity title (no time ago)
                    Text(activityTitle)
                        .font(.system(size: 15, weight: .semibold))
                        .foregroundColor(.primary)
                        .multilineTextAlignment(.leading)
                        .lineLimit(2)
                    
                    Spacer()
                    
                    // Status badge in top right
                    statusBadge
                }
                
                // Activity subtitle (chose, wager/payout info)
                HStack(spacing: 0) {
                    if participation.chosen_option == "Creator" {
                        Text("Created this bet")
                            .font(.system(size: 14, weight: .regular))
                            .foregroundColor(.secondary)
                    } else {
                        Text("Chose: ")
                            .font(.system(size: 14, weight: .regular))
                            .foregroundColor(.secondary)
                        
                        Text(participation.chosen_option)
                            .font(.system(size: 14, weight: .semibold))
                            .foregroundStyle(Color.slingGradient)
                        
                        Text(" • ")
                            .font(.system(size: 14, weight: .regular))
                            .foregroundColor(.secondary)
                        
                        if bet.status == "settled" {
                            if let winnerOption = bet.winner_option {
                                if participation.chosen_option == winnerOption {
                                    // User won - show payout
                                    Text("Paid: ")
                                        .font(.system(size: 14, weight: .regular))
                                        .foregroundColor(.secondary)
                                    
                                    Image(systemName: "bolt.fill")
                                        .font(.system(size: 12, weight: .medium))
                                        .foregroundStyle(Color.slingGradient)
                                    
                                    Text("\(participation.final_payout ?? participation.stake_amount)")
                                        .font(.system(size: 14, weight: .regular))
                                        .foregroundColor(.secondary)
                                } else {
                                    // User lost - show lost amount
                                    Text("Lost: ")
                                        .font(.system(size: 14, weight: .regular))
                                        .foregroundColor(.secondary)
                                    
                                    Image(systemName: "bolt.fill")
                                        .font(.system(size: 12, weight: .medium))
                                        .foregroundStyle(Color.slingGradient)
                                    
                                    Text("\(participation.stake_amount)")
                                        .font(.system(size: 14, weight: .regular))
                                        .foregroundColor(.secondary)
                                }
                            }
                        } else if bet.status == "voided" {
                            // Voided bet - show refund
                            Text("Refunded: ")
                                .font(.system(size: 14, weight: .regular))
                                .foregroundColor(.secondary)
                            
                            Image(systemName: "bolt.fill")
                                .font(.system(size: 12, weight: .medium))
                                .foregroundStyle(Color.slingGradient)
                            
                            Text("\(participation.final_payout ?? participation.stake_amount)")
                                .font(.system(size: 14, weight: .regular))
                                .foregroundColor(.secondary)
                        } else {
                            // Active bet - show wager
                            Text("Wager: ")
                                .font(.system(size: 14, weight: .regular))
                                .foregroundColor(.secondary)
                            
                            Image(systemName: "bolt.fill")
                                .font(.system(size: 12, weight: .medium))
                                .foregroundStyle(Color.slingGradient)
                            
                            Text("\(participation.stake_amount)")
                                .font(.system(size: 14, weight: .regular))
                                .foregroundColor(.secondary)
                        }
                    }
                }
                .multilineTextAlignment(.leading)
                .lineLimit(1)
            }
        }
        .padding(.horizontal, 16) // Internal padding for card content
        .padding(.vertical, 16)
        .background(Color.white)
        .cornerRadius(12)
        .shadow(color: Color.black.opacity(0.05), radius: 2, x: 0, y: 1)
        .onTapGesture {
            showingBetDetail = true
        }
        .sheet(isPresented: $showingBetDetail) {
            JoinBetView(
                bet: bet,
                firestoreService: firestoreService,
                onCommunityTap: {
                    // Handle community tap if needed
                }
            )
        }
    }
}

// MARK: - Chat Message Bubble

struct ChatMessageBubble: View {
    let message: CommunityMessage
    let isCurrentUser: Bool
    let firestoreService: FirestoreService
    @Binding var selectedBet: FirestoreBet?
    @Binding var showingBetDetail: Bool
    @Binding var selectedBetOption: String
    @Binding var showingPlaceBet: Bool
    
    // Global timestamp state - passed from parent view
    let isShowingTimestamps: Bool
    
    // Function to get user's full name from email
    let getUserFullName: (String) -> String
    
    // Fixed timestamp gutter for perfect vertical alignment
    private let timestampGutter: CGFloat = 68
    
    private var isBot: Bool {
        message.senderEmail == "bot@sling.app" || message.senderEmail == "app@slingapp.com"
    }
    
    private func formatTime(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.timeStyle = .short
        formatter.dateStyle = .none
        return formatter.string(from: date)
    }
    

    

    
    var body: some View {
        HStack(alignment: .center, spacing: 8) {
            // Left side - Avatar/Logo space (consistent for all message types)
            HStack(alignment: .top, spacing: 2) {
                if isBot {
                    // Sling logo - smaller and circular like user avatars
                    Image("Logo")
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: 26, height: 26)
                        .clipShape(Circle())
                } else if !isCurrentUser {
                    // User avatar for other users
                    Circle()
                        .fill(Color.slingLightBlue)
                        .frame(width: 30, height: 30)
                        .overlay(
                            Text(String(message.senderName.prefix(1)).uppercased())
                                .font(.caption2)
                                .fontWeight(.semibold)
                                .foregroundColor(Color.slingBlue)
                        )
                }
            }
            .frame(width: 32, alignment: .leading)
            
            // Center content area
            VStack(alignment: .leading, spacing: 3) {
                if isBot {
                    // Bot message content
                    VStack(alignment: .leading, spacing: 3) {
                        // Sling name
                        Text("Sling")
                            .font(.caption)
                            .fontWeight(.semibold)
                            .foregroundColor(.gray)
                        
                        // Bot message content
                        if message.messageType == .betAnnouncement {
                            BetAnnouncementCard(
                                message: message,
                                firestoreService: firestoreService,
                                onBetTap: {
                                    // Fetch the actual bet from Firestore and show bet details
                                    if let betId = message.betId {
                                        firestoreService.fetchBet(by: betId) { fetchedBet in
                                            DispatchQueue.main.async {
                                                if let fetchedBet = fetchedBet {
                                                    selectedBet = fetchedBet
                                                    selectedBetOption = "" // Clear any selected option
                                                    showingBetDetail = true
                                                }
                                            }
                                        }
                                    }
                                }
                            )
                            .frame(maxWidth: .infinity, alignment: .leading)
                        } else {
                            // Regular bot message (system messages, etc.)
                            Text(message.text)
                                .font(.subheadline)
                                .foregroundColor(.black)
                                .padding(.horizontal, 14)
                                .padding(.vertical, 8)
                                .background(Color.white)
                                .cornerRadius(16)
                                .overlay(
                                    RoundedRectangle(cornerRadius: 16)
                                        .stroke(Color.gray.opacity(0.15), lineWidth: 1)
                                )
                                .frame(maxWidth: .infinity, alignment: .leading)
                                .onAppear {
                                    print("🔍 Regular bot message displayed:")
                                    print("  - Message type: \(message.messageType)")
                                    print("  - Message text: \(message.text)")
                                    print("  - Bet ID: \(message.betId ?? "nil")")
                                    print("  - Sender email: \(message.senderEmail)")
                                }
                        }
                    }
                } else {
                    // Regular user messages
                    if isCurrentUser {
                        // Current user: align to right
                        HStack(spacing: 0) {
                            // Message content with timestamp on the right when global state is active
                            Text(message.text)
                                .font(.subheadline)
                                .foregroundColor(.white)
                                .padding(.horizontal, 14)
                                .padding(.vertical, 8)
                                .background(AnyShapeStyle(Color.slingGradient))
                                .cornerRadius(16)
                        }
                        .frame(maxWidth: .infinity, alignment: .trailing)
                        .padding(.trailing, 0)
                    } else {
                        // Other users: align to left
                        VStack(alignment: .leading, spacing: 3) {
                            // Sender name - show full name instead of first name
                            Text(getUserFullName(message.senderEmail))
                                .font(.caption)
                                .fontWeight(.semibold)
                                .foregroundColor(.gray)
                            
                            // Message bubble with timestamp on the right when global state is active
                            Text(message.text)
                                .font(.subheadline)
                                .foregroundColor(.black)
                                .padding(.horizontal, 14)
                                .padding(.vertical, 8)
                                .background(Color.white)
                                .cornerRadius(16)
                                .overlay(
                                    RoundedRectangle(cornerRadius: 16)
                                        .stroke(Color.gray.opacity(0.15), lineWidth: 1)
                                )
                        }
                        .frame(maxWidth: .infinity, alignment: .leading)
                    }
                }
            }
            
            // Fixed timestamp gutter column - only reserve space when showing timestamps
            if isShowingTimestamps {
                Spacer(minLength: timestampGutter)
            }
        }
        .overlay(alignment: .trailing) {
            if isShowingTimestamps {
                Text(formatTime(message.timestamp))
                    .font(.caption)
                    .foregroundColor(.gray)
                    .frame(width: timestampGutter, alignment: .center)
                    .transition(.move(edge: .trailing).combined(with: .opacity))
            }
        }

        .sheet(isPresented: $showingBetDetail) {
            if let selectedBet = selectedBet {
                JoinBetView(
                    bet: selectedBet,
                    firestoreService: firestoreService,
                    onCommunityTap: {
                        // Navigate to community details
                        // This will be handled by the parent view
                    }
                )
            }
        }
        .sheet(isPresented: $showingPlaceBet) {
            if let selectedBet = selectedBet {
                BettingInterfaceView(
                    bet: selectedBet,
                    selectedOption: selectedBetOption.isEmpty ? (selectedBet.options.first ?? "Yes") : selectedBetOption,
                    firestoreService: firestoreService,
                    onBetPlaced: nil
                )
            }
        }
    }
    

}

// MARK: - Chat View

struct MessagesView: View {
    @ObservedObject var firestoreService: FirestoreService
    @State private var selectedCommunity: FirestoreCommunity?
    @State private var messageText = ""
    @State private var onlineMembers: [String] = []
    @State private var unreadCounts: [String: Int] = [:]
    @State private var showingCommunityInfo = false
    @State private var showingBetDetail = false
    @State private var showingPlaceBet = false
    @State private var selectedBet: FirestoreBet?
    @State private var selectedBetOption = ""
    @State private var isKeyboardActive = false
    @State private var isLoadingMessages = false
    @State private var userFullNames: [String: String] = [:] // Cache for user full names
    @State private var searchText = ""
    @StateObject private var timeTracker = TimeTracker()
    @State private var hasPerformedInitialScroll = false
    
    // Global timestamp state - activated by swiping anywhere on the page
    @State private var isShowingTimestamps = false
    
    // Helper function to generate chat list data from user's actual communities
    private func getChatList() -> [ChatListItem] {
        let chatItems = firestoreService.userCommunities.map { community in
            let unreadCount = unreadCounts[community.id ?? ""] ?? 0
            let timestampString = getLastMessageTimestamp(community)
            let actualTimestamp = getLastMessageActualDate(community)
            
            return ChatListItem(
                id: community.id ?? UUID().uuidString,
                communityId: community.id ?? "",
                communityName: community.name,
                lastMessage: getLastMessage(community),
                timestamp: actualTimestamp,
                timestampString: timestampString,
                unreadCount: unreadCount,
                imageUrl: getDefaultImageUrl(for: community.name)
            )
        }
        
        // Filter based on search text if provided
        let filteredItems = searchText.isEmpty ? chatItems : chatItems.filter { chatItem in
            chatItem.communityName.localizedCaseInsensitiveContains(searchText) ||
            chatItem.lastMessage.localizedCaseInsensitiveContains(searchText)
        }
        
        // Sort chat list: unread messages first (most recent to oldest), then read messages (most recent to oldest)
        let sortedItems = filteredItems.sorted { item1, item2 in
            // First priority: communities with unread messages come first
            if item1.unreadCount > 0 && item2.unreadCount == 0 {
                return true
            } else if item1.unreadCount == 0 && item2.unreadCount > 0 {
                return false
            }
            
            // Second priority: if both have unread messages, sort by most recent activity (most recent first)
            if item1.unreadCount > 0 && item2.unreadCount > 0 {
                return item1.timestamp > item2.timestamp
            }
            
            // Third priority: if both have no unread messages, sort by most recent activity (most recent first)
            return item1.timestamp > item2.timestamp
        }
        
        // Debug: Print the sorted order
        print("📱 Chat List Sorting Debug:")
        for (index, item) in sortedItems.enumerated() {
            print("  \(index + 1). \(item.communityName) - Unread: \(item.unreadCount), Timestamp: \(item.timestampString) (Date: \(item.timestamp))")
        }
        
        return sortedItems
    }
    
    private func sendMessage() {
        guard !messageText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty,
              let community = selectedCommunity else { return }
        
        let trimmedMessage = messageText.trimmingCharacters(in: .whitespacesAndNewlines)
        messageText = "" // Clear input immediately for better UX
        
        // Track message send attempt
        AnalyticsService.shared.trackMessageSend(
            communityId: community.id ?? "",
            communityName: community.name,
            messageLength: trimmedMessage.count,
            success: true
        )
        
        firestoreService.sendMessage(to: community.id ?? "", text: trimmedMessage) { success, error in
            DispatchQueue.main.async {
                if let error = error {
                    print("❌ Failed to send message: \(error)")
                    // Track failed message send
                    AnalyticsService.shared.trackMessageSend(
                        communityId: community.id ?? "",
                        communityName: community.name,
                        messageLength: trimmedMessage.count,
                        success: false
                    )
                    // Optionally show an error message to user
                }
            }
        }
    }
    
    private func getOnlineMemberCount(_ community: FirestoreCommunity) -> Int {
        // Simulate online members (in real app, fetch from server)
        return Int.random(in: 1...min(community.member_count, 15))
    }
    
    private func getLastMessage(_ community: FirestoreCommunity) -> String {
        guard let communityId = community.id,
              let lastMessage = firestoreService.communityLastMessages[communityId] else {
            // Check if there are messages in the community's chat_history as a fallback
            if let chatHistory = community.chat_history, !chatHistory.isEmpty {
                // Find the most recent message from chat_history
                let mostRecentMessage = chatHistory.values.max { $0.time_stamp < $1.time_stamp }
                if let message = mostRecentMessage {
                    let formattedMessage = formatMessagePreview(message)
                    let maxLength = 50
                    if formattedMessage.count > maxLength {
                        return String(formattedMessage.prefix(maxLength)) + "..."
                    }
                    return formattedMessage
                }
            }
            return "No messages yet"
        }
        
        // Format the message as [Full Name]: [Message]
        let formattedMessage = formatMessagePreview(lastMessage)
        let maxLength = 50
        if formattedMessage.count > maxLength {
            return String(formattedMessage.prefix(maxLength)) + "..."
        }
        return formattedMessage
    }
    
    private func formatMessagePreview(_ message: CommunityMessage) -> String {
        // For bot messages, don't show "Sling:" prefix
        if message.senderEmail == "app@slingapp.com" || message.senderEmail == "bot@sling.app" {
            return message.text
        }
        return "\(message.senderName): \(message.text)"
    }
    
    private func formatMessagePreview(_ message: FirestoreCommunityMessage) -> String {
        // For bot messages, don't show "Sling:" prefix
        if message.sender_email == "app@slingapp.com" || message.sender_email == "bot@sling.app" {
            return message.message
        }
        // Convert stored name to full name for preview
        let senderFullName = getFullNameFromStoredName(message.sender_name, email: message.sender_email)
        return "\(senderFullName): \(message.message)"
    }
    
    private func getLastMessageTimestamp(_ community: FirestoreCommunity) -> String {
        guard let communityId = community.id,
              let lastMessage = firestoreService.communityLastMessages[communityId] else {
            let timestamp = formatTimestamp(community.created_date)
            return timestamp
        }
        
        let timestamp = formatTimestamp(lastMessage.timestamp)
        return timestamp
    }
    
    private func getLastMessageActualDate(_ community: FirestoreCommunity) -> Date {
        guard let communityId = community.id,
              let lastMessage = firestoreService.communityLastMessages[communityId] else {
            // Use community creation date as fallback
            return community.created_date
        }
        
        // Return the actual Date object for sorting
        return lastMessage.timestamp
    }
    
    private func formatTimestamp(_ date: Date) -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: date, relativeTo: Date())
    }
    
    private func getDefaultImageUrl(for communityName: String) -> String {
        // Return empty string to use local placeholder instead of external URL
        return ""
    }
    
    // Helper function to parse relative timestamps for sorting (no longer used, kept for reference)
    private func parseRelativeTimestamp(_ timestamp: String) -> Date {
        let now = Date()
        let calendar = Calendar.current
        
        if timestamp == "Today" {
            return now
        } else if timestamp == "Yesterday" {
            let yesterday = calendar.date(byAdding: .day, value: -1, to: now) ?? now
            return yesterday
        } else if timestamp.contains("ago") {
            // Parse relative time like "6m ago", "38m ago", "1w ago", etc.
            let components = timestamp.components(separatedBy: " ")
            if components.count >= 2, let value = Int(components[0]) {
                let unit = components[1].lowercased()
                let result: Date
                
                switch unit {
                case "s", "sec", "secs", "second", "seconds":
                    result = calendar.date(byAdding: .second, value: -value, to: now) ?? now
                case "m", "min", "mins", "minute", "minutes":
                    result = calendar.date(byAdding: .minute, value: -value, to: now) ?? now
                case "h", "hr", "hrs", "hour", "hours":
                    result = calendar.date(byAdding: .hour, value: -value, to: now) ?? now
                case "d", "day", "days":
                    result = calendar.date(byAdding: .day, value: -value, to: now) ?? now
                case "w", "wk", "week", "weeks":
                    result = calendar.date(byAdding: .weekOfYear, value: -value, to: now) ?? now
                case "mo", "month", "months":
                    result = calendar.date(byAdding: .month, value: -value, to: now) ?? now
                case "y", "yr", "year", "years":
                    result = calendar.date(byAdding: .year, value: -value, to: now) ?? now
                default:
                    // If we can't parse the unit, try to extract just the number and assume minutes
                    result = calendar.date(byAdding: .minute, value: -value, to: now) ?? now
                }
                
                return result
            } else {
                // If we can't parse the components, try to extract just the number
                let numbers = timestamp.components(separatedBy: CharacterSet.decimalDigits.inverted).compactMap { Int($0) }
                if let value = numbers.first {
                    // Assume minutes if we can't determine the unit
                    let result = calendar.date(byAdding: .minute, value: -value, to: now) ?? now
                    return result
                }
            }
        } else {
            // Try to parse as a formatted date like "Monday, Aug 12"
            let formatter = DateFormatter()
            formatter.dateFormat = "EEEE, MMM d"
            if let date = formatter.date(from: timestamp) {
                // Set the year to current year for comparison
                var components = calendar.dateComponents([.year, .month, .day], from: date)
                components.year = calendar.component(.year, from: now)
                let result = calendar.date(from: components) ?? now
                return result
            }
        }
        
        // Fallback to a very old date if parsing fails
        let fallback = calendar.date(byAdding: .year, value: -100, to: now) ?? now
        return fallback
    }
    
    private func initializeUnreadCounts() {
        // Initialize unread counts for user's communities based on actual data
        for community in firestoreService.userCommunities {
            if let communityId = community.id,
               let chatHistory = community.chat_history {
                
                var unreadCount = 0
                if let userId = firestoreService.currentUser?.id {
                    for (_, message) in chatHistory {
                        // Check if message is not read by current user
                        if !message.read_by.contains(userId) {
                            unreadCount += 1
                        }
                    }
                }
                unreadCounts[communityId] = unreadCount
            } else {
                unreadCounts[community.id ?? ""] = 0
            }
        }
        
        // Update total unread count in FirestoreService
        firestoreService.updateTotalUnreadCount()
        

    }
    
    private func loadMessages(for community: FirestoreCommunity) {
        guard let communityId = community.id else { return }

        // Fetch messages without blocking the UI
        firestoreService.fetchMessages(for: communityId)
    }
    
    // Function to get user's full name, with caching
    private func getUserFullName(from email: String) -> String {
        // Check cache first
        if let cachedName = userFullNames[email] {
            return cachedName
        }
        
        // For current user, use local data
        if let user = firestoreService.currentUser, user.email == email {
            let fullName = "\(user.first_name ?? "") \(user.last_name ?? "")".trimmingCharacters(in: .whitespaces)
            userFullNames[email] = fullName
            return fullName
        }
        
        // For other users, fetch from Firestore and cache
        firestoreService.getUserDetails(email: email) { fullName, _ in
            DispatchQueue.main.async {
                self.userFullNames[email] = fullName
            }
        }
        
        // Return first name as fallback while fetching
        return email.components(separatedBy: "@").first ?? email
    }
    
    // Helper function to convert stored name to full name for preview
    private func getFullNameFromStoredName(_ storedName: String, email: String) -> String {
        // If the stored name is the current user's display name, convert to full name
        if let currentUser = firestoreService.currentUser, 
           currentUser.email == email,
           storedName == currentUser.display_name {
            let fullName = "\(currentUser.first_name ?? "") \(currentUser.last_name ?? "")".trimmingCharacters(in: .whitespaces)
            return fullName.isEmpty ? storedName : fullName
        }
        
        // For other users, try to get full name from Firestore
        // For now, return the stored name as is (could be enhanced later)
        return storedName
    }
    
    private var chatListView: some View {
        VStack(spacing: 0) {
            chatHeaderView
            searchBarView
            
            if firestoreService.userCommunities.isEmpty {
                emptyStateView
            } else {
                chatListScrollView
            }
        }
    }
    
    private var chatHeaderView: some View {
        HStack {
            Text("Messages")
                .font(.title2)
                .fontWeight(.bold)
                .foregroundColor(.black)
            
            Spacer()
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .background(Color.white)
    }
    
    private var searchBarView: some View {
        HStack(spacing: 12) {
            Image(systemName: "magnifyingglass")
                .foregroundColor(.gray)
            
            TextField("Search chats and messages", text: $searchText)
                .textFieldStyle(PlainTextFieldStyle())
                .font(.subheadline)
                .foregroundColor(.black)
            
            if !searchText.isEmpty {
                Button(action: {
                    searchText = ""
                }) {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.gray)
                }
            }
            

        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .background(Color.white)
        .overlay(
            RoundedRectangle(cornerRadius: 10)
                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
        )
        .cornerRadius(10)
        .padding(.horizontal, 16)
    }
    
    private var emptyStateView: some View {
        VStack(spacing: 16) {
            Spacer()
            
            Image(systemName: "message.circle")
                .font(.system(size: 60))
                .foregroundColor(.gray.opacity(0.6))
            
            Text("No Communities Yet")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundColor(.black)
            
            Text("Join a community to start chatting with other members.")
                .font(.subheadline)
                .foregroundColor(.gray)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 32)
            
            Spacer()
        }
    }
    
    private var chatListScrollView: some View {
        ScrollView {
            LazyVStack(spacing: 0) {
                ForEach(getChatList(), id: \.id) { chatItem in
                    chatItemView(chatItem)
                    
                    if chatItem.id != getChatList().last?.id {
                        Divider()
                            .padding(.leading, 84)
                    }
                }
            }
        }
        .padding(.top, 20)
        .background(Color.white)
        .refreshable {
            // Refresh data when user pulls down
            isLoadingMessages = true
            firestoreService.fetchUserCommunities()
            // Refresh unread counts and last messages
            firestoreService.fetchLastMessagesForUserCommunities()
            
            // Set loading to false after refresh completes
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                isLoadingMessages = false
            }
        }


    }
    
    private func chatItemView(_ chatItem: ChatListItem) -> some View {
        Button(action: {
            // Find the actual community from the user's communities
            if let community = firestoreService.userCommunities.first(where: { $0.id == chatItem.communityId }) {
                selectedCommunity = community
                hasPerformedInitialScroll = false // Reset scroll flag for new community
                loadMessages(for: community)
                
                // Clear unread count for this community when selected
                if let communityId = community.id {
                    unreadCounts[communityId] = 0
                    // Update total unread count
                    firestoreService.updateTotalUnreadCount()
                }
            }
        }) {
            HStack(alignment: .top, spacing: 12) {
                chatItemAvatarView(chatItem)
                chatItemContentView(chatItem)
            }
            .overlay(
                // Blue dot indicator for unread messages - positioned absolutely to not affect timestamp
                HStack {
                    Spacer()
                    VStack {
                        Spacer()
                            .frame(height: 30) // Position dot lower to align with last message
                        if let unreadCount = unreadCounts[chatItem.communityId],
                           unreadCount > 0 {
                            Circle()
                                .fill(Color.slingBlue)
                                .frame(width: 8, height: 8)
                        }
                        Spacer()
                    }
                }
                .padding(.trailing, 16), // Match the horizontal padding of the main content
                alignment: .trailing
            )
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
        }
    }
    
    private func chatItemAvatarView(_ chatItem: ChatListItem) -> some View {
        ZStack(alignment: .topTrailing) {
            // Get the actual community to access profile_image_url
            Group {
                if let community = firestoreService.userCommunities.first(where: { $0.id == chatItem.communityId }),
                   let profileImageUrl = community.profile_image_url, !profileImageUrl.isEmpty {
                    AsyncImage(url: URL(string: profileImageUrl)) { phase in
                        switch phase {
                        case .success(let image):
                image
                    .resizable()
                    .aspectRatio(contentMode: .fill)
                        case .failure(_), .empty:
                            // Fallback to initials on error or while loading
                            Circle()
                                .fill(AnyShapeStyle(Color.slingGradient))
                                .overlay(
                                    Text(String(chatItem.communityName.prefix(1)).uppercased())
                                        .font(.title2)
                                        .fontWeight(.bold)
                                        .foregroundColor(.white)
                                )
                        @unknown default:
                            Circle()
                    .fill(AnyShapeStyle(Color.slingGradient))
                    .overlay(
                        Text(String(chatItem.communityName.prefix(1)).uppercased())
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                    )
                        }
                    }
                } else {
                    // Fallback to initials if no profile image
                    Circle()
                        .fill(AnyShapeStyle(Color.slingGradient))
                        .overlay(
                            Text(String(chatItem.communityName.prefix(1)).uppercased())
                                .font(.title2)
                                .fontWeight(.bold)
                                .foregroundColor(.white)
                        )
                }
            }
            .frame(width: 44, height: 44)
            .clipShape(Circle())
        }
    }
    
    private func chatItemContentView(_ chatItem: ChatListItem) -> some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(chatItem.communityName)
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                
                Spacer()
                
                        Text(chatItem.timestampString)
                            .font(.caption)
                            .foregroundColor(.gray)
            }
            
            HStack {
                Text(chatItem.lastMessage)
                    .font(.subheadline)
                    .foregroundColor(.gray)
                    .lineLimit(1)
                
                Spacer()
            }
        }
    }
    
    var body: some View {
        VStack(spacing: 0) {
            if selectedCommunity == nil {
                SimpleHeaderView(title: "Messages")
                chatListView
                    .transition(.move(edge: .leading))
            } else {
                chatInterfaceView
                    .transition(.move(edge: .trailing))
                    .onAppear {
                        if let community = selectedCommunity {
                            // Track community selection
                            AnalyticsService.shared.trackChatCommunitySelect(
                                communityId: community.id ?? "",
                                communityName: community.name,
                                unreadCount: unreadCounts[community.id ?? ""] ?? 0
                            )
                            
                            loadMessages(for: community)
                            // Mark all messages as read when entering chat
                            if let communityId = community.id {
                                firestoreService.markAllMessagesAsRead(for: communityId) { success in
                                    if success {
                                        print("✅ All messages marked as read for \(community.name)")
                                    }
                                }
                            }
                        }
                    }
                    .onDisappear {
                        firestoreService.stopListeningToMessages()
                    }
            }
        }
        .background(Color.white)
        .animation(.easeInOut(duration: 0.3), value: selectedCommunity)
        .onAppear {
            // Track chat page view
            AnalyticsService.shared.trackUserFlowStep(step: .chatTab)
            AnalyticsService.shared.trackFeatureUsage(feature: "chat_page", context: "main_app")
            timeTracker.startTracking(for: "chat_page")
            
            // Refresh communities when view appears
            isLoadingMessages = true
            firestoreService.fetchUserCommunities()
            // Fetch last messages for all communities to reduce lag
            firestoreService.fetchLastMessagesForUserCommunities()
            // Initialize unread counts immediately
            initializeUnreadCounts()
            
            // Set loading to false after initial load
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                isLoadingMessages = false
            }
        }
        .onDisappear {
            // Track time spent on chat page
            if let duration = timeTracker.endTracking(for: "chat_page") {
                AnalyticsService.shared.trackPageViewTime(page: "chat_page", timeSpent: duration)
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: UIApplication.didBecomeActiveNotification)) { _ in
            // Refresh data when app becomes active
            isLoadingMessages = true
            firestoreService.fetchUserCommunities()
            firestoreService.fetchLastMessagesForUserCommunities()
            
            // Set loading to false after refresh
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                isLoadingMessages = false
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)) { _ in
            // Refresh data when app comes to foreground
            isLoadingMessages = true
            firestoreService.fetchUserCommunities()
            firestoreService.fetchLastMessagesForUserCommunities()
            
            // Set loading to false after refresh
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                isLoadingMessages = false
            }
        }

        .onChange(of: firestoreService.messages) { _, newMessages in
    
        }
        .onReceive(NotificationCenter.default.publisher(for: UIResponder.keyboardWillShowNotification)) { _ in
            isKeyboardActive = true
        }
        .onReceive(NotificationCenter.default.publisher(for: UIResponder.keyboardWillHideNotification)) { _ in
            isKeyboardActive = false
        }
        .sheet(isPresented: $showingCommunityInfo) {
            if let community = selectedCommunity {
                EnhancedCommunityDetailView(
                    community: community, 
                    firestoreService: firestoreService,
                    onChatTap: {
                        // Already in chat, just dismiss the sheet
                        showingCommunityInfo = false
                    }
                )
            }
        }
        .sheet(isPresented: $showingBetDetail) {
            if let bet = selectedBet {
                JoinBetView(
                    bet: bet, 
                    firestoreService: firestoreService,
                    onCommunityTap: {
                        // Navigate to community details
                        // This will be handled by the parent view
                    }
                )
            }
        }

    }
    
    private var chatInterfaceView: some View {
        VStack(spacing: 0) {
                individualChatHeaderView
            
            messagesAreaView
            
            messageInputView
        }
        .navigationBarHidden(isKeyboardActive)
        .gesture(
            DragGesture()
                .onChanged { value in
                    let translation = value.translation.width
                    if translation < 0 { // Left swipe - show timestamps
                        // Activate timestamps when swiping left anywhere on the page
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                            isShowingTimestamps = true
                        }
                    }
                }
                .onEnded { value in
                    let translation = value.translation.width
                    let velocity = value.velocity.width
                    
                    // Handle left swipe for timestamps
                    if translation < 0 {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                            isShowingTimestamps = false
                        }
                    }
                    
                    // Handle right swipe to go back (with velocity threshold for better UX)
                    if translation > 50 || velocity > 300 { // Right swipe threshold
                        withAnimation(.easeInOut(duration: 0.3)) {
                            selectedCommunity = nil
                            hasPerformedInitialScroll = false // Reset scroll flag when going back
                            firestoreService.stopListeningToMessages()
                        }
                    }
                }
        )

    }
    
    private var individualChatHeaderView: some View {
        VStack(spacing: 0) {
        HStack(spacing: 12) {
            Button(action: {
                selectedCommunity = nil
                hasPerformedInitialScroll = false // Reset scroll flag when going back
                firestoreService.stopListeningToMessages()
            }) {
                Image(systemName: "arrow.left")
                    .font(.title2)
                    .foregroundColor(.slingBlue)
            }
            
            // Community avatar
            if let profileImageUrl = selectedCommunity!.profile_image_url, !profileImageUrl.isEmpty {
                AsyncImage(url: URL(string: profileImageUrl)) { phase in
                    switch phase {
                    case .success(let image):
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                    case .failure(_), .empty:
                        // Fallback to initials on error or while loading
                        Circle()
                            .fill(AnyShapeStyle(Color.slingGradient))
                            .overlay(
                                Text(String(selectedCommunity!.name.prefix(1)).uppercased())
                                    .font(.subheadline)
                                    .fontWeight(.bold)
                                    .foregroundColor(.white)
                            )
                    @unknown default:
                        Circle()
                            .fill(AnyShapeStyle(Color.slingGradient))
                            .overlay(
                                Text(String(selectedCommunity!.name.prefix(1)).uppercased())
                                    .font(.subheadline)
                                    .fontWeight(.bold)
                                    .foregroundColor(.white)
                            )
                    }
                }
                .frame(width: 32, height: 32)
                .clipShape(Circle())
            } else {
                // Fallback to initials if no profile image
            Circle()
                .fill(AnyShapeStyle(Color.slingGradient))
                .frame(width: 32, height: 32)
                .overlay(
                    Text(String(selectedCommunity!.name.prefix(1)).uppercased())
                        .font(.subheadline)
                        .fontWeight(.bold)
                        .foregroundColor(.white)
                )
            }
            
            VStack(alignment: .leading, spacing: 2) {
                Text(selectedCommunity!.name)
                    .font(.headline)
                    .fontWeight(.bold)
                    .foregroundColor(.black)
                

            }
            
            Spacer()
            
            // Info button
            Button(action: {
                showingCommunityInfo = true
            }) {
                Image(systemName: "info.circle")
                    .font(.title2)
                    .foregroundColor(.slingBlue)
            }
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .background(Color.white)
        .overlay(
            Rectangle()
                .frame(height: 0.5)
                .foregroundColor(Color.gray.opacity(0.3)),
            alignment: .bottom
        )
        }
    }
    
    private var messagesAreaView: some View {
        ScrollViewReader { proxy in
            ScrollView {
                LazyVStack(spacing: 16) {
                    if firestoreService.messages.isEmpty {
                        emptyMessagesView
                    } else {
                        // Group messages by date and display with headers
                        ForEach(groupedMessages, id: \.date) { group in
                            VStack(spacing: 12) {
                                // Date header (centered pill)
                                Text(group.dateHeader)
                                    .font(.caption)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.gray)
                                    .padding(.horizontal, 14)
                                    .padding(.vertical, 6)
                                    .background(
                                        Capsule().fill(Color.gray.opacity(0.15))
                                    )
                                    .frame(maxWidth: .infinity)      // centers the pill
                                    .padding(.vertical, 4)
                                
                                // Messages for this date
                                ForEach(group.messages) { message in
                                    ChatMessageBubble(
                                    message: message,
                                    isCurrentUser: message.senderEmail == firestoreService.currentUser?.email,
                                    firestoreService: firestoreService,
                                    selectedBet: $selectedBet,
                                    showingBetDetail: $showingBetDetail,
                                    selectedBetOption: $selectedBetOption,
                                    showingPlaceBet: $showingPlaceBet,
                                    isShowingTimestamps: isShowingTimestamps,
                                    getUserFullName: { email in
                                        return self.getUserFullName(from: email)
                                    }
                                )
                                .id(message.id) // Add id for scrolling
                                }
                            }
                        }
                    }
                    

                    
                    // Auto-scroll indicator when new messages arrive
                    Color.clear
                        .frame(height: 1)
                        .id("bottom")
                }
                .padding(.horizontal, 16)
                .onAppear {
                    // Scroll to oldest unread message or bottom if all read
                    scrollToAppropriatePosition(proxy: proxy)
                }
                .onChange(of: firestoreService.messages) { _ in
                    // When messages update, scroll to appropriate position
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        scrollToAppropriatePosition(proxy: proxy)
                    }
                }
            }
            .padding(.vertical, 12)
        }
    }
    
    // Function to scroll to the appropriate position when chat opens
    private func scrollToAppropriatePosition(proxy: ScrollViewProxy) {
        guard let currentUserId = firestoreService.currentUser?.id,
              !hasPerformedInitialScroll,
              !firestoreService.messages.isEmpty else { return }
        
        // Find the oldest unread message
        let unreadMessages = firestoreService.messages.filter { message in
            !message.readBy.contains(currentUserId)
        }
        
        if let oldestUnreadMessage = unreadMessages.first {
            // Scroll to the oldest unread message
            withAnimation(.easeInOut(duration: 0.5)) {
                proxy.scrollTo(oldestUnreadMessage.id, anchor: .top)
            }
            print("📜 Scrolled to oldest unread message: \(oldestUnreadMessage.text.prefix(50))...")
        } else {
            // All messages are read, scroll to bottom
            withAnimation(.easeInOut(duration: 0.5)) {
                proxy.scrollTo("bottom", anchor: .bottom)
            }
            print("📜 All messages read, scrolled to bottom")
        }
        
        hasPerformedInitialScroll = true
    }
    
    // Group messages by date for display
    private var groupedMessages: [MessageGroup] {
        let calendar = Calendar.current
        
        let grouped = Dictionary(grouping: firestoreService.messages) { message in
            calendar.startOfDay(for: message.timestamp)
        }
        
        return grouped.map { date, messages in
            let dateHeader: String
            if calendar.isDateInToday(date) {
                dateHeader = "Today"
            } else if calendar.isDateInYesterday(date) {
                dateHeader = "Yesterday"
            } else {
                let formatter = DateFormatter()
                formatter.dateFormat = "EEEE, MMM d"
                dateHeader = formatter.string(from: date)
            }
            
            return MessageGroup(date: date, dateHeader: dateHeader, messages: messages.sorted { $0.timestamp < $1.timestamp })
        }
        .sorted { $0.date < $1.date }
    }
    
    private var emptyMessagesView: some View {
        VStack(spacing: 16) {
            Image(systemName: "bubble.left.and.bubble.right.fill")
                .font(.system(size: 50))
                .foregroundColor(Color.slingBlue.opacity(0.3))
            
            Text("Start the conversation!")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundColor(.black)
            
            Text("Be the first to share your thoughts with the community.")
                .font(.subheadline)
                .foregroundColor(.gray)
                .multilineTextAlignment(.center)
        }
        .padding(.top, 60)
    }
    
    private var messageInputView: some View {
        VStack(spacing: 0) {
            HStack(spacing: 12) {
                TextField("Type a message...", text: $messageText, axis: .vertical)
                    .lineLimit(1...4)
                    .padding(.horizontal, 16)
                    .padding(.vertical, 12)
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(25)
                    .onSubmit {
                        sendMessage()
                    }
                
                // Send button
                Button(action: sendMessage) {
                    Image(systemName: "arrow.up.circle.fill")
                        .font(.title2)
                        .foregroundColor(messageText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? .gray : .slingBlue)
                }
                .disabled(messageText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .background(Color.white)
        }
    }
        }



// MARK: - Community Info Modal

struct CommunityInfoModal: View {
    @Environment(\.dismiss) private var dismiss
    let community: FirestoreCommunity
    @ObservedObject var firestoreService: FirestoreService
    @State private var selectedTab = 0 // 0 = Bets, 1 = Members
    @State private var showImageFullscreen = false
    @State private var selectedImageUrl: String?
    @State private var showingCommunityInfo = false
    
    private var communityBets: [FirestoreBet] {
        return firestoreService.bets.filter { $0.community_id == (community.id ?? "") }
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                VStack(spacing: 8) {
                    // Community icon and name centered
                    VStack(spacing: 8) {
                        Button(action: {
                            showingCommunityInfo = true
                        }) {
                        if let profileImageUrl = community.profile_image_url {
                            // Show custom community image
                            AsyncImage(url: URL(string: profileImageUrl)) { image in
                                image
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                            } placeholder: {
                                Circle()
                                    .fill(AnyShapeStyle(Color.slingGradient))
                                    .overlay(
                                        ProgressView()
                                            .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                            .scaleEffect(0.8)
                                    )
                            }
                            .frame(width: 48, height: 48)
                            .clipShape(Circle())
                        } else {
                            // Show community initials
                        Circle()
                            .fill(AnyShapeStyle(Color.slingGradient))
                            .frame(width: 48, height: 48)
                            .overlay(
                                Text(String(community.name.prefix(1)).uppercased())
                                    .font(.title2)
                                    .fontWeight(.bold)
                                    .foregroundColor(.white)
                            )
                            }
                        }
                        .buttonStyle(PlainButtonStyle())
                        .onLongPressGesture {
                            // Keep the original long press functionality for image viewing
                            if let profileImageUrl = community.profile_image_url {
                                selectedImageUrl = profileImageUrl
                                showImageFullscreen = true
                            }
                        }
                        
                        Button(action: {
                            showingCommunityInfo = true
                        }) {
                        Text(community.name)
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                        }
                        .buttonStyle(PlainButtonStyle())
                        
                        Text("\(community.member_count) members")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                    }
                }
                .padding(.top, 20)
                .padding(.bottom, 30)
                
                // Tab selector
                Picker("", selection: $selectedTab) {
                    Text("Bets").tag(0)
                    Text("Leaderboard").tag(1)
                }
                .pickerStyle(SegmentedPickerStyle())
                .padding(.horizontal, 16)
                
                // Content
                TabView(selection: $selectedTab) {
                    // Bets tab
                    ScrollView {
                        LazyVStack(spacing: 16) {
                            if communityBets.isEmpty {
                                VStack(spacing: 16) {
                                    Image(systemName: "dice")
                                        .font(.system(size: 48))
                                        .foregroundColor(Color.slingBlue.opacity(0.6))
                                    
                                    Text("No Bets Yet")
                                        .font(.headline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(.black)
                                    
                                    Text("Community bets will appear here")
                                        .font(.subheadline)
                                        .foregroundColor(.gray)
                                }
                                .padding(.top, 60)
                            } else {
                                ForEach(communityBets) { bet in
                                    EnhancedBetCardView(
                                        bet: bet,
                                        currentUserEmail: firestoreService.currentUser?.email,
                                        firestoreService: firestoreService,
                                        isCommunityNameClickable: true
                                    )
                                }
                            }
                        }
                        .padding(.horizontal, 16)
                        .padding(.top, 20)
                    }
                    .tag(0)
                    
                    // Members tab
                    ScrollView {
                        LazyVStack(spacing: 12) {
                            ForEach(0..<community.member_count, id: \.self) { index in
                                HStack(spacing: 12) {
                                    Circle()
                                        .fill(Color.slingLightBlue)
                                        .frame(width: 40, height: 40)
                                        .overlay(
                                            Text("M\(index + 1)")
                                                .font(.caption)
                                                .fontWeight(.semibold)
                                                .foregroundColor(.slingBlue)
                                        )
                                    
                                    VStack(alignment: .leading, spacing: 2) {
                                        Text("Member \(index + 1)")
                                            .font(.subheadline)
                                            .fontWeight(.medium)
                                            .foregroundColor(.black)
                                        

                                    }
                                    
                                    Spacer()
                                    
                                    if index == 0 {
                                        Text("Admin")
                                            .font(.caption)
                                            .fontWeight(.medium)
                                            .foregroundColor(.orange)
                                            .padding(.horizontal, 8)
                                            .padding(.vertical, 4)
                                            .background(Color.orange.opacity(0.1))
                                            .cornerRadius(8)
                                    }
                                }
                                .padding(.horizontal, 16)
                                .padding(.vertical, 8)
                                .background(Color.white)
                                .cornerRadius(12)
                            }
                        }
                        .padding(.horizontal, 16)
                        .padding(.top, 20)
                    }
                    .tag(1)
                }
                .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
            }
            .background(Color.white)
            .navigationTitle("")
            .navigationBarHidden(true)
            .overlay(
                // Top right controls
                HStack(spacing: 12) {
                    // Do not disturb bell icon
                    Button(action: {
                        if let communityId = community.id {
                            firestoreService.toggleMuteForCommunity(communityId) { success in
                                if success {
                                    print("✅ Mute status toggled successfully")
                                } else {
                                    print("❌ Failed to toggle mute status")
                                }
                            }
                        }
                    }) {
                        Image(systemName: firestoreService.mutedCommunities.contains(community.id ?? "") ? "bell.slash.fill" : "bell.fill")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                            .frame(width: 32, height: 32)
                    }
                    
                    // Close button
                    Button(action: {
                        dismiss()
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title2)
                            .foregroundColor(.gray)
                            .background(Color.white)
                            .clipShape(Circle())
                    }
                }
                .padding(.top, 16)
                .padding(.trailing, 16),
                alignment: .topTrailing
            )
            .fullScreenCover(isPresented: $showImageFullscreen) {
                if let imageUrl = selectedImageUrl {
                    FullscreenImageView(imageUrl: imageUrl, isPresented: $showImageFullscreen)
                }
            }
            .sheet(isPresented: $showingCommunityInfo) {
                EnhancedCommunityDetailView(
                    community: community, 
                    firestoreService: firestoreService,
                    onChatTap: {
                        // Already in community info, just dismiss the sheet
                        showingCommunityInfo = false
                    }
                )
            }
        }
    }
}

// MARK: - Fullscreen Image View
struct FullscreenImageView: View {
    let imageUrl: String
    let selectedImage: UIImage?
    @Binding var isPresented: Bool
    @State private var scale: CGFloat = 1.0
    @State private var lastScale: CGFloat = 1.0
    @State private var offset: CGSize = .zero
    @State private var lastOffset: CGSize = .zero
    @State private var dismissOffset: CGSize = .zero
    @State private var isDismissing: Bool = false
    
    init(imageUrl: String, selectedImage: UIImage? = nil, isPresented: Binding<Bool>) {
        self.imageUrl = imageUrl
        self.selectedImage = selectedImage
        self._isPresented = isPresented
    }
    
    var body: some View {
        ZStack {
            Color.black.ignoresSafeArea()
                .opacity(isDismissing ? 1.0 - abs(dismissOffset.height) / 500.0 : 1.0)
            
            if let selectedImage = selectedImage {
                // Show selected image directly
                Image(uiImage: selectedImage)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .scaleEffect(scale)
                    .offset(x: offset.width + dismissOffset.width, y: offset.height + dismissOffset.height)
                    .opacity(isDismissing ? 1.0 - abs(dismissOffset.height) / 500.0 : 1.0)
                    .gesture(
                        SimultaneousGesture(
                            MagnificationGesture()
                                .onChanged { value in
                                    let delta = value / lastScale
                                    lastScale = value
                                    scale = min(max(scale * delta, 0.5), 4.0)
                                }
                                .onEnded { _ in
                                    lastScale = 1.0
                                    if scale < 1.0 {
                                        withAnimation(.easeInOut(duration: 0.3)) {
                                            scale = 1.0
                                            offset = .zero
                                        }
                                    }
                                },
                            DragGesture()
                                .onChanged { value in
                                    let newOffset = CGSize(
                                        width: lastOffset.width + value.translation.width,
                                        height: lastOffset.height + value.translation.height
                                    )
                                    offset = newOffset
                                }
                                .onEnded { _ in
                                    lastOffset = offset
                                }
                        )
                    )
            } else if !imageUrl.isEmpty {
                // Show image from URL
                AsyncImage(url: URL(string: imageUrl)) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .scaleEffect(scale)
                        .offset(x: offset.width + dismissOffset.width, y: offset.height + dismissOffset.height)
                        .opacity(isDismissing ? 1.0 - abs(dismissOffset.height) / 500.0 : 1.0)
                        .gesture(
                            SimultaneousGesture(
                                MagnificationGesture()
                                    .onChanged { value in
                                        let delta = value / lastScale
                                        lastScale = value
                                        scale = min(max(scale * delta, 0.5), 4.0)
                                    }
                                    .onEnded { _ in
                                        lastScale = 1.0
                                        if scale < 1.0 {
                                            withAnimation(.easeInOut(duration: 0.3)) {
                                                scale = 1.0
                                                offset = .zero
                                            }
                                        }
                                    },
                                DragGesture()
                                    .onChanged { value in
                                        let newOffset = CGSize(
                                            width: lastOffset.width + value.translation.width,
                                            height: lastOffset.height + value.translation.height
                                        )
                                        offset = newOffset
                                    }
                                    .onEnded { _ in
                                        lastOffset = offset
                                    }
                            )
                        )
                } placeholder: {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        .scaleEffect(1.5)
                }
            } else {
                // Fallback
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                    .scaleEffect(1.5)
            }
            
            VStack {
                HStack {
                    Spacer()
                    Button(action: {
                        isPresented = false
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title2)
                            .foregroundColor(.white)
                            .background(Color.black.opacity(0.5))
                            .clipShape(Circle())
                    }
                    .padding(.top, 50)
                    .padding(.trailing, 20)
                }
                Spacer()
            }
        }
        .onTapGesture(count: 2) {
            withAnimation(.easeInOut(duration: 0.3)) {
                if scale > 1.0 {
                    scale = 1.0
                    offset = .zero
                    lastOffset = .zero
                } else {
                    scale = 2.0
                }
            }
        }
        .gesture(
            DragGesture()
                .onChanged { value in
                    // Only allow dismiss gesture when not zoomed in
                    if scale <= 1.0 {
                        isDismissing = true
                        dismissOffset = value.translation
                    }
                }
                .onEnded { value in
                    if isDismissing {
                        // Check if swipe is significant enough to dismiss
                        let swipeThreshold: CGFloat = 100
                        let velocity = value.predictedEndTranslation.height - value.translation.height
                        
                        if abs(value.translation.height) > swipeThreshold || abs(velocity) > 500 {
                            // Dismiss the view
                            withAnimation(.easeOut(duration: 0.3)) {
                                isPresented = false
                            }
                        } else {
                            // Snap back to original position
                            withAnimation(.easeOut(duration: 0.3)) {
                                dismissOffset = .zero
                                isDismissing = false
                            }
                        }
                    }
                }
        )
    }
}

// MARK: - Message Bubble

struct MessageBubble: View {
    let message: CommunityMessage
    let isCurrentUser: Bool
    
    var body: some View {
        HStack {
            if isCurrentUser { Spacer() }
            
            VStack(alignment: isCurrentUser ? .trailing : .leading, spacing: 4) {
                if !isCurrentUser {
                    Text(message.senderName)
                        .font(.caption)
                        .fontWeight(.medium)
                        .foregroundColor(.gray)
                }
                
                Text(message.text)
                    .font(.subheadline)
                    .foregroundColor(isCurrentUser ? .white : .black)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 8)
                    .background(isCurrentUser ? AnyShapeStyle(Color.slingGradient) : AnyShapeStyle(Color.white))
                    .cornerRadius(16)
                    .overlay(
                        RoundedRectangle(cornerRadius: 16)
                            .stroke(Color.gray.opacity(0.15), lineWidth: isCurrentUser ? 0 : 1)
                    )
                
                Text(formatMessageTime(message.timestamp))
                    .font(.caption2)
                    .foregroundColor(.gray)
            }
            .frame(maxWidth: 250, alignment: isCurrentUser ? .trailing : .leading)
            
            if !isCurrentUser { Spacer() }
        }
    }
    
    private func formatMessageTime(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "h:mm a"
        return formatter.string(from: date)
    }
}



// MARK: - Bet Announcement Card

struct BetAnnouncementCard: View {
    let message: CommunityMessage
    let firestoreService: FirestoreService
    let onBetTap: () -> Void
    
    @State private var bet: FirestoreBet?
    @State private var isLoading = true
    @State private var communityName: String = ""
    @State private var creatorDisplayName: String = ""
    @State private var userFullNames: [String: String] = [:]
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            if isLoading {
                // Loading state
                HStack {
                    ProgressView()
                        .scaleEffect(0.6)
                    Text("Loading bet details...")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
                .frame(maxWidth: .infinity, alignment: .center)
                .padding(.vertical, 12)
            } else if let bet = bet {
                // Clickable mini bet card
                betCardView(bet: bet)
            } else {
                // Error state
                HStack {
                    Image(systemName: "exclamationmark.triangle")
                        .foregroundColor(.orange)
                    Text("Could not load bet details")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
                .frame(maxWidth: .infinity, alignment: .center)
                .padding(.vertical, 12)
            }
        }
        .padding(12)
        .background(Color.white)
        .cornerRadius(10)
        .overlay(
            RoundedRectangle(cornerRadius: 10)
                .stroke(Color.gray.opacity(0.2), lineWidth: 1)
        )
        .onTapGesture {
            onBetTap()
        }
        .onAppear {
            print("🔍 BetAnnouncementCard onAppear:")
            print("  - Message type: \(message.messageType)")
            print("  - Message text: \(message.text)")
            print("  - Bet ID: \(message.betId ?? "nil")")
            print("  - Sender email: \(message.senderEmail)")
            loadBetDetails()
        }
    }
    
    private func loadBetDetails() {
        guard let betId = message.betId else {
            isLoading = false
            return
        }
        
        firestoreService.fetchBet(by: betId) { fetchedBet in
            DispatchQueue.main.async {
                self.bet = fetchedBet
                self.isLoading = false
                
                if let fetchedBet = fetchedBet {
                    // Get community name - first try userCommunities, then fetch from Firestore if needed
                    if let community = firestoreService.userCommunities.first(where: { $0.id == fetchedBet.community_id }) {
                        self.communityName = community.name
                    } else {
                        // If not in userCommunities, fetch the community directly
                        self.fetchCommunityName(communityId: fetchedBet.community_id)
                    }
                    
                    // Get creator's display name with proper formatting
                    self.creatorDisplayName = self.formatCreatorName(from: fetchedBet.creator_email)
                }
            }
        }
    }
    
    private func fetchCommunityName(communityId: String) {
        // Fetch community name directly from Firestore
        firestoreService.db.collection("community")
            .whereField("id", isEqualTo: communityId)
            .getDocuments { snapshot, _ in
                DispatchQueue.main.async {
                    if snapshot == nil {
                        self.communityName = "Community"
                        return
                    }
                    
                    if let document = snapshot?.documents.first,
                       let communityData = try? document.data(as: FirestoreCommunity.self) {
                        self.communityName = communityData.name
                    } else {
                        // Fallback to community ID if name can't be fetched
                        self.communityName = "Community"
                    }
                }
            }
    }
    
    private func extractFirstName(from email: String) -> String {
        // Try to get the first part of the email (before @)
        let emailPrefix = email.components(separatedBy: "@").first ?? email
        
        // If it contains dots or underscores, take the first part
        let firstName = emailPrefix.components(separatedBy: CharacterSet(charactersIn: "._")).first ?? emailPrefix
        
        // Capitalize first letter
        return firstName.prefix(1).uppercased() + firstName.dropFirst().lowercased()
    }
    
    // Function to get user's full name, with caching
    private func getUserFullName(from email: String) -> String {
        // Check cache first
        if let cachedName = userFullNames[email] {
            return cachedName
        }
        
        // For current user, use local data
        if let user = firestoreService.currentUser, user.email == email {
            let fullName = "\(user.first_name ?? "") \(user.last_name ?? "")".trimmingCharacters(in: .whitespaces)
            userFullNames[email] = fullName
            return fullName
        }
        
        // For other users, fetch from Firestore and cache
        firestoreService.getUserDetails(email: email) { fullName, _ in
            DispatchQueue.main.async {
                self.userFullNames[email] = fullName
            }
        }
        
        // Return first name as fallback while fetching
        return email.components(separatedBy: "@").first ?? email
    }
    
    private func formatDeadline(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d 'at' h:mm a"
        return formatter.string(from: date)
    }
    
    private func formatCreatorName(from email: String) -> String {
        // For current user, use local data
        if let user = firestoreService.currentUser, user.email == email {
            let firstName = user.first_name ?? ""
            let lastName = user.last_name ?? ""
            return formatName(firstName: firstName, lastName: lastName)
        }
        
        // For other users, try to get from cache first
        if let cachedName = userFullNames[email] {
            return formatNameFromFullName(cachedName)
        }
        
        // If not cached, fetch from Firestore
        firestoreService.getUserDetails(email: email) { fullName, _ in
            DispatchQueue.main.async {
                self.userFullNames[email] = fullName
                self.creatorDisplayName = self.formatNameFromFullName(fullName)
            }
        }
        
        // Return abbreviated email as fallback while fetching
        return formatNameFromEmail(email)
    }
    
    private func formatName(firstName: String, lastName: String) -> String {
        let trimmedFirstName = firstName.trimmingCharacters(in: .whitespacesAndNewlines)
        let trimmedLastName = lastName.trimmingCharacters(in: .whitespacesAndNewlines)
        
        if trimmedFirstName.isEmpty && trimmedLastName.isEmpty {
            return "Unknown User"
        } else if trimmedFirstName.isEmpty {
            return trimmedLastName
        } else if trimmedLastName.isEmpty {
            return trimmedFirstName
        } else {
            let fullName = "\(trimmedFirstName) \(trimmedLastName)"
            return abbreviateNameIfNeeded(fullName)
        }
    }
    
    private func formatNameFromFullName(_ fullName: String) -> String {
        let trimmedName = fullName.trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmedName.isEmpty {
            return "Unknown User"
        }
        return abbreviateNameIfNeeded(trimmedName)
    }
    
    private func formatNameFromEmail(_ email: String) -> String {
        let emailPrefix = email.components(separatedBy: "@").first ?? email
        return emailPrefix.capitalized
    }
    
    private func abbreviateNameIfNeeded(_ fullName: String) -> String {
        let components = fullName.components(separatedBy: " ")
        if components.count >= 2 {
            let firstName = components[0]
            let lastName = components[1]
            
            // If the full name is too long (more than 20 characters), abbreviate
            if fullName.count > 20 {
                let firstInitial = String(lastName.prefix(1)).uppercased()
                return "\(firstName) \(firstInitial)"
            } else {
                return fullName
            }
        } else {
            return fullName
        }
    }
    
    private func formatNumber(_ number: Int) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        return formatter.string(from: NSNumber(value: number)) ?? "\(number)"
    }
    
    private func betCardView(bet: FirestoreBet) -> some View {
        Button(action: {
            onBetTap()
        }) {
            VStack(alignment: .leading, spacing: 6) {
                betHeaderView(bet: bet)
                bettingOptionsView(bet: bet)
                deadlineView(bet: bet)
            }
            .padding(.horizontal, 12)
            .padding(.vertical, 8)
        }
        .buttonStyle(PlainButtonStyle())
        .frame(maxWidth: 300, alignment: .leading)
    }
    
    private func betHeaderView(bet: FirestoreBet) -> some View {
        HStack(spacing: 8) {
            betImageView(bet: bet)
            betTitleView(bet: bet)
            Spacer()
        }
    }
    
    private func betImageView(bet: FirestoreBet) -> some View {
        Group {
            if let imageURL = bet.image_url, !imageURL.isEmpty {
                AsyncImage(url: URL(string: imageURL)) { phase in
                    switch phase {
                    case .success(let image):
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .frame(width: 40, height: 40)
                            .clipped()
                            .cornerRadius(8)
                    case .failure(_):
                        placeholderImageView
                    case .empty:
                        loadingImageView
                    @unknown default:
                        placeholderImageView
                    }
                }
            } else {
                placeholderImageView
            }
        }
    }
    
    private var placeholderImageView: some View {
        RoundedRectangle(cornerRadius: 8)
            .fill(Color.gray.opacity(0.3))
            .frame(width: 40, height: 40)
            .overlay(
                Image(systemName: "photo")
                    .font(.caption)
                    .foregroundColor(.gray)
            )
    }
    
    private var loadingImageView: some View {
        RoundedRectangle(cornerRadius: 8)
            .fill(Color.gray.opacity(0.3))
            .frame(width: 40, height: 40)
            .overlay(
                ProgressView()
                    .scaleEffect(0.5)
            )
    }
    
    private func betTitleView(bet: FirestoreBet) -> some View {
        VStack(alignment: .leading, spacing: 2) {
            Text(bet.title)
                .font(.subheadline)
                .fontWeight(.semibold)
                .foregroundColor(.black)
                .lineLimit(2)
            
            HStack(spacing: 4) {
                Text(communityName)
                    .font(.caption2)
                    .foregroundColor(.gray)
                
                Text("•")
                    .font(.caption2)
                    .foregroundColor(.gray)
                
                Text("by \(creatorDisplayName)")
                    .font(.caption2)
                    .foregroundColor(.gray)
            }
        }
    }
    
    private func bettingOptionsView(bet: FirestoreBet) -> some View {
        HStack(spacing: 6) {
            if bet.options.count == 1 {
                // Show single option
                bettingOptionView(option: bet.options[0], bet: bet)
                    .frame(maxWidth: .infinity)
            } else if bet.options.count == 2 {
                // Show both options
                ForEach(bet.options, id: \.self) { option in
                    bettingOptionView(option: option, bet: bet)
                        .frame(maxWidth: .infinity)
                }
            } else {
                // Show first option and "and X others"
                bettingOptionView(option: bet.options[0], bet: bet)
                    .frame(maxWidth: .infinity)
                andOthersView(bet: bet)
                    .frame(maxWidth: .infinity)
            }
        }
    }
    
    private func bettingOptionView(option: String, bet: FirestoreBet) -> some View {
        HStack(spacing: 4) {
            Text(option)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(.slingBlue)
            
            Text(firestoreService.formatImpliedOdds(firestoreService.calculateImpliedOdds(for: bet)[option] ?? 0.5))
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(.slingBlue)
        }
        .frame(maxWidth: .infinity)
        .padding(.horizontal, 8)
        .padding(.vertical, 6)
        .background(Color.slingLightBlue)
        .cornerRadius(8)
    }
    
    private func andOthersView(bet: FirestoreBet) -> some View {
        Text("and \(bet.options.count - 1) others")
            .font(.caption)
            .fontWeight(.medium)
            .foregroundColor(.gray)
            .frame(maxWidth: .infinity)
            .padding(.horizontal, 8)
            .padding(.vertical, 6)
            .background(Color.gray.opacity(0.1))
            .cornerRadius(8)
    }
    
    private func moreOptionsView(bet: FirestoreBet) -> some View {
        Text("+\(bet.options.count - 2)")
            .font(.caption)
            .fontWeight(.medium)
            .foregroundColor(.slingBlue)
            .padding(.horizontal, 8)
            .padding(.vertical, 6)
            .background(Color.slingBlue.opacity(0.1))
            .cornerRadius(8)
    }
    
    private func deadlineView(bet: FirestoreBet) -> some View {
        Text("Deadline: \(formatDeadline(bet.deadline))")
            .font(.caption2)
            .foregroundColor(.gray)
    }
}

// MARK: - Bet Result Card

struct BetResultCard: View {
    let message: CommunityMessage
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack(spacing: 8) {
                Text("🎯")
                    .font(.title3)
                
                Text("Bet Settled!")
                    .font(.headline)
                    .fontWeight(.bold)
                    .foregroundColor(.green)
            }
            
            Text(message.text)
                .font(.subheadline)
                .foregroundColor(.black)
            
            Text("Check your winnings! 💰")
                .font(.caption)
                .foregroundColor(.green)
                .fontWeight(.medium)
        }
        .padding(16)
        .background(Color.green.opacity(0.05))
        .cornerRadius(16)
    }
}








// MARK: - Place Bet View

struct PlaceBetView: View {
    let bet: FirestoreBet
    let presetOption: String? // Add preset option parameter
    @ObservedObject var firestoreService: FirestoreService
    @Environment(\.dismiss) private var dismiss
    let onBetPlaced: (() -> Void)? // Callback when bet is successfully placed
    
    @State private var selectedOption = ""
    @State private var betAmount = ""
    @State private var showingConfirmation = false
    @State private var isLoading = false
    @FocusState private var isBetAmountFocused: Bool
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                // Bet Title
                VStack(alignment: .leading, spacing: 8) {
                    Text(bet.title)
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Text("Place your bet on this market")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                    
                    // Show selected option if preset
                    if let preset = presetOption, !preset.isEmpty {
                        HStack {
                            Image(systemName: "checkmark.circle.fill")
                                .foregroundColor(.green)
                            Text("Pre-selected: \(preset)")
                                .font(.subheadline)
                                .foregroundColor(.green)
                                .fontWeight(.medium)
                        }
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(Color.green.opacity(0.1))
                        .cornerRadius(8)
                    }
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.horizontal, 20)
                
                // Betting Options
                VStack(alignment: .leading, spacing: 12) {
                    Text("Select Your Pick")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                    
                    ForEach(Array(bet.options.enumerated()), id: \.offset) { index, option in
                        Button(action: {
                            selectedOption = option
                        }) {
                            HStack {
                                Text(option)
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                    .foregroundColor(selectedOption == option ? .white : .black)
                                
                                Spacer()
                                
                                Text(firestoreService.formatImpliedOdds(firestoreService.calculateImpliedOdds(for: bet)[option] ?? 0.5))
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                    .foregroundColor(selectedOption == option ? .white : .gray)
                            }
                            .padding(.horizontal, 16)
                            .padding(.vertical, 12)
                            .background(selectedOption == option ? AnyShapeStyle(Color.slingGradient) : AnyShapeStyle(Color.gray.opacity(0.1)))
                            .cornerRadius(8)
                            .overlay(
                                RoundedRectangle(cornerRadius: 8)
                                    .stroke(selectedOption == option ? Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)) : Color.clear, lineWidth: 2)
                            )
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                .padding(.horizontal, 20)
                
                // Bet Amount
                VStack(alignment: .leading, spacing: 12) {
                    Text("Bet Amount")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                    
                    TextField("Enter amount", text: $betAmount)
                        .keyboardType(.decimalPad)
                        .focused($isBetAmountFocused)
                        .padding(.horizontal, 16)
                        .padding(.vertical, 12)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                        .onChange(of: betAmount) { _, newValue in
                            updateBetAmount(newValue)
                        }
                }
                .padding(.horizontal, 20)
                
                // Info about multiple bets
                HStack(spacing: 4) {
                    Image(systemName: "info.circle")
                        .font(.caption)
                        .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                    Text("You can place multiple bets on this market while it's open")
                        .font(.caption)
                        .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                }
                .padding(.horizontal, 20)
                
                Spacer()
                
                // Place Bet Button
                Button(action: {
                    showingConfirmation = true
                }) {
                    HStack {
                        if isLoading {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                .scaleEffect(0.8)
                        } else {
                            Text("place bet")
                                .font(.subheadline)
                                .fontWeight(.semibold)
                            
                            Image(systemName: "arrow.right")
                                .font(.subheadline)
                        }
                    }
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 16)
                    .background(selectedOption.isEmpty || betAmount.isEmpty ? AnyShapeStyle(Color.gray) : AnyShapeStyle(Color.slingGradient))
                    .cornerRadius(12)
                }
                .disabled(selectedOption.isEmpty || betAmount.isEmpty || isLoading)
                .padding(.horizontal, 20)
                .padding(.bottom, 20)
            }
            .navigationTitle("Place Bet")
            .navigationBarTitleDisplayMode(.inline)
            .navigationBarBackButtonHidden(true)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        if isLoading {
                            // Don't allow dismissal during bet placement
                            return
                        }
                        dismiss()
                    }
                    .disabled(isLoading)
                }
            }
            .onAppear {
                // Auto-select preset option if provided
                if let preset = presetOption, !preset.isEmpty {
                    selectedOption = preset
                }
                
                // Auto-focus the bet amount field after a short delay
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    isBetAmountFocused = true
                }
            }
            .interactiveDismissDisabled(isLoading) // Prevent dismissal during bet placement
        }
        .alert("Confirm Bet", isPresented: $showingConfirmation) {
            Button("Cancel", role: .cancel) { }
            Button("place bet") {
                placeBet()
            }
        } message: {
            Text("Are you sure you want to place a bet of \(formatCurrency(Double(betAmount) ?? 0)) Sling Points on '\(selectedOption)'?")
        }
    }
    
    private func placeBet() {
        guard let amount = Double(betAmount), amount > 0 else { 
            print("❌ Invalid bet amount: \(betAmount)")
            return 
        }
        
        // Validate amount is reasonable (between 1 and 10000 points)
        guard amount >= 1 && amount <= 10000 else {
            print("❌ Bet amount out of range: \(amount)")
            return
        }
        
        isLoading = true
        
        guard let betId = bet.id else { 
            print("❌ No bet ID found")
            isLoading = false
            return 
        }
        
        print("🎯 Placing bet: \(amount) points on '\(selectedOption)' for bet '\(bet.title)'")
        
        firestoreService.joinBet(
            betId: betId,
            chosenOption: selectedOption,
            stakeAmount: Int(amount) // Use points directly, not cents
        ) { success, error in
            DispatchQueue.main.async {
                isLoading = false
                if success {
                    print("✅ Bet placed successfully!")
                    // Add a small delay to ensure data is processed
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    dismiss()
                    }
                } else {
                    print("❌ Error placing bet: \(error ?? "Unknown error")")
                }
            }
        }
    }
    
    private func formatCurrency(_ amount: Double) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.minimumFractionDigits = 0
        formatter.maximumFractionDigits = 2
        return formatter.string(from: NSNumber(value: amount)) ?? "\(amount)"
    }
    
    private func updateBetAmount(_ newValue: String) {
        // Filter out non-numeric characters except decimal point
        let filtered = newValue.filter { "0123456789.".contains($0) }
        // Ensure only one decimal point
        let components = filtered.components(separatedBy: ".")
        if components.count > 2 {
            betAmount = String(components.prefix(2).joined(separator: "."))
        } else {
            betAmount = filtered
        }
    }
}

// MARK: - Choose Winner View

struct ChooseWinnerView: View {
    let bet: FirestoreBet
    @ObservedObject var firestoreService: FirestoreService
    @Environment(\.dismiss) private var dismiss
    
    @State private var selectedWinner = ""
    @State private var showingConfirmation = false
    @State private var isLoading = false
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                // Bet Title
                VStack(alignment: .leading, spacing: 8) {
                    Text(bet.title)
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Text("Select the winning outcome")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.horizontal, 20)
                
                // Betting Options
                VStack(alignment: .leading, spacing: 12) {
                    Text("Select Winner")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                    
                    ForEach(Array(bet.options.enumerated()), id: \.offset) { index, option in
                        Button(action: {
                            selectedWinner = option
                        }) {
                            HStack {
                                Text(option)
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                    .foregroundColor(selectedWinner == option ? .white : .black)
                                
                                Spacer()
                                
                                Text(firestoreService.formatImpliedOdds(firestoreService.calculateImpliedOdds(for: bet)[option] ?? 0.5))
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                    .foregroundColor(selectedWinner == option ? .white : .gray)
                            }
                            .padding(.horizontal, 16)
                            .padding(.vertical, 12)
                            .background(selectedWinner == option ? AnyShapeStyle(Color.slingGradient) : AnyShapeStyle(Color.gray.opacity(0.1)))
                            .cornerRadius(8)
                        }
                    }
                }
                .padding(.horizontal, 20)
                
                Spacer()
                
                // Choose Winner Button
                Button(action: {
                    showingConfirmation = true
                }) {
                    HStack {
                        if isLoading {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                .scaleEffect(0.8)
                        } else {
                            Text("Choose Winner")
                                .font(.headline)
                                .fontWeight(.semibold)
                        }
                    }
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 16)
                    .background(selectedWinner.isEmpty ? AnyShapeStyle(Color.gray) : AnyShapeStyle(Color.slingGradient))
                    .cornerRadius(12)
                }
                .disabled(selectedWinner.isEmpty || isLoading)
                .padding(.horizontal, 20)
                .padding(.bottom, 20)
            }
            .navigationTitle("Choose Winner")
            .navigationBarTitleDisplayMode(.inline)
            .navigationBarBackButtonHidden(true)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
        }
        .alert("Confirm Winner", isPresented: $showingConfirmation) {
            Button("Cancel", role: .cancel) { }
            Button("Choose Winner") {
                chooseWinner()
            }
        } message: {
            Text("Are you sure you want to select '\(selectedWinner)' as the winner? This will settle the bet and distribute winnings.")
        }
    }
    
    private func chooseWinner() {
        guard let betId = bet.id else { return }
        
        isLoading = true
        
        firestoreService.settleBet(betId: betId, winnerOption: selectedWinner) { success in
            DispatchQueue.main.async {
                isLoading = false
                if success {
                    dismiss()
                } else {
                    print("Error settling bet: Unknown error")
                }
            }
        }
    }
}

// MARK: - Communities View

struct CommunitiesView: View {
    let firestoreService: FirestoreService
    let onNavigateToHome: ((String) -> Void)?
    @State private var showingJoinCommunityModal = false
    @State private var showingCreateCommunityModal = false
    @State private var outstandingBalances: [OutstandingBalance] = []
    @State private var showingAllBalances = false
    @StateObject private var timeTracker = TimeTracker()
    
    
    var body: some View {
        VStack(spacing: 0) {
            // Header with logo, title, and Add button (exact match to SimpleHeaderView structure)
            HStack(spacing: 12) {
                // Sling Logo and Title (exact copy from SimpleHeaderView)
                HStack(spacing: 8) {
                    Image("Logo")
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: 32, height: 32)
                        .cornerRadius(8)
                    
                            Text("Communities")
                                .font(.title2)
                                .fontWeight(.bold)
                                .foregroundColor(.black)
                }
                            
                            Spacer()
                            
                            // Create/Join Community Button with Dropdown
                            Menu {
                                Button(action: { 
                                    AnalyticsService.shared.trackCommunitiesInteraction(action: .create)
                                    showingCreateCommunityModal = true 
                                }) {
                                    Label("Create Community", systemImage: "plus.circle")
                                }
                                
                                Button(action: { 
                                    AnalyticsService.shared.trackCommunitiesInteraction(action: .join)
                                    showingJoinCommunityModal = true 
                                }) {
                                    Label("Join Community", systemImage: "person.badge.plus")
                                }
                            } label: {
                                HStack(spacing: 6) {
                                    Image(systemName: "plus")
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                        .foregroundColor(.white)
                                    
                                                        Text("Add")
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(.white)
                                    
                                    Image(systemName: "chevron.down")
                                        .font(.caption)
                                        .fontWeight(.medium)
                                        .foregroundColor(.white)
                                }
                                .padding(.horizontal, 12)
                                .padding(.vertical, 8)
                                .background(AnyShapeStyle(Color.slingGradient))
                                .cornerRadius(20)
                            }
                        }
            .padding(.horizontal, 16)
                        .padding(.vertical, 12)
                        .background(Color.white)
                        
            ScrollView {
                VStack(spacing: 16) {
                        // Outstanding Balances Section
                        outstandingBalancesSection
                        
                        // Communities Section
                        communitiesSection
                    }
                    .padding(.horizontal, 16)
                    .padding(.bottom, 100) // Space for bottom tab bar
            }
        }
        .refreshable {
            AnalyticsService.shared.trackCommunitiesInteraction(action: .refresh)
            await refreshData()
        }
        .background(Color.white)
        .onAppear {
            // Track communities page view
            AnalyticsService.shared.trackUserFlowStep(step: .communitiesTab)
            AnalyticsService.shared.trackFeatureUsage(feature: "communities_page", context: "main_app")
            AnalyticsService.shared.trackCommunitiesInteraction(action: .view)
            timeTracker.startTracking(for: "communities_page")
            
            loadOutstandingBalances()
            firestoreService.fetchUserCommunities()
            updateCommunityStatistics()
        }
        .onDisappear {
            // Track time spent on communities page
            if let duration = timeTracker.endTracking(for: "communities_page") {
                AnalyticsService.shared.trackPageViewTime(page: "communities_page", timeSpent: duration)
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)) { _ in
            firestoreService.fetchUserCommunities()
            updateCommunityStatistics()
        }
        .sheet(isPresented: $showingJoinCommunityModal) {
            JoinCommunityPage(firestoreService: firestoreService)
        }
        .sheet(isPresented: $showingCreateCommunityModal) {
            CreateCommunityPage(firestoreService: firestoreService)
        }
        .sheet(isPresented: $showingAllBalances) {
            AllBalancesView(balances: outstandingBalances, firestoreService: firestoreService)
        }
    }
    

    
    // MARK: - Outstanding Balances Section
    private var outstandingBalancesSection: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Outstanding Balances")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundColor(.black)
            
            // Main Outstanding Balances Card
            HStack(spacing: 16) {
                // Status Indicator (Left) - Dynamic based on balances
                HStack(spacing: 8) {
                    if outstandingBalances.isEmpty {
                        // Green checkmark circle for no outstanding balances
                        Circle()
                            .fill(Color.green)
                            .frame(width: 24, height: 24)
                            .overlay(
                                Image(systemName: "checkmark")
                                    .font(.caption)
                                    .foregroundColor(.white)
                            )
                        
                        // Status text
                        Text("All Bets Settled 🎉")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(.black)
                    } else {
                        // Orange/yellow circle for outstanding balances
                        Circle()
                            .fill(Color.orange)
                            .frame(width: 24, height: 24)
                            .overlay(
                                Image(systemName: "exclamationmark")
                                    .font(.caption)
                                    .fontWeight(.bold)
                                    .foregroundColor(.white)
                            )
                        
                        // Status text with count
                        Text("\(outstandingBalances.count) Outstanding")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(.black)
                    }
                }
                
                Spacer()
                
                // View All button - only show if there are balances
                if !outstandingBalances.isEmpty {
                    Button(action: {
                        AnalyticsService.shared.trackCommunitiesInteraction(action: .balanceView, details: ["balance_count": outstandingBalances.count])
                        showingAllBalances = true
                    }) {
                        Text("View All")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(.black)
                            .padding(.horizontal, 16)
                            .padding(.vertical, 8)
                            .background(Color.white)
                            .cornerRadius(8)
                            .overlay(
                                RoundedRectangle(cornerRadius: 8)
                                    .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                            )
                    }
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .background(outstandingBalances.isEmpty ? Color.green.opacity(0.1) : Color.orange.opacity(0.1))
            .cornerRadius(12)
        }
    }
    
    
    // MARK: - Communities Section
    private var communitiesSection: some View {
        VStack(alignment: .leading, spacing: 8) {
                                    if !firestoreService.userCommunities.isEmpty {
                HStack {
                    Text("My Communities")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    Text("\(firestoreService.userCommunities.count) communities")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                    }
                
                // Horizontal line under My Communities section
                Rectangle()
                    .fill(Color.gray.opacity(0.2))
                    .frame(height: 1)
                
                
                LazyVStack(spacing: 0) {
                    ForEach(firestoreService.userCommunities) { community in
                        CommunityListItem(
                            community: community,
                            firestoreService: firestoreService,
                            onViewCommunity: onNavigateToHome
                        )
                        
                        // Add divider between items (except for the last item)
                        if community.id != firestoreService.userCommunities.last?.id {
                            Divider()
                                .padding(.leading, 60) // Align with community name text
                        }
                    }
                }
                .padding(.top, 2) // Minimal spacing after horizontal line
            } else {
                        EmptyCommunitiesView(firestoreService: firestoreService)
            }
        }
    }
    
    
    // MARK: - Helper Methods
    private func getUserInitials() -> String {
        let user = firestoreService.currentUser
        if let firstName = user?.first_name, let lastName = user?.last_name, !firstName.isEmpty, !lastName.isEmpty {
            let firstInitial = String(firstName.prefix(1)).uppercased()
            let lastInitial = String(lastName.prefix(1)).uppercased()
            return "\(firstInitial)\(lastInitial)"
        } else if let displayName = user?.display_name, !displayName.isEmpty {
            let components = displayName.components(separatedBy: " ")
            if components.count >= 2 {
                let firstInitial = String(components[0].prefix(1)).uppercased()
                let lastInitial = String(components[1].prefix(1)).uppercased()
                return "\(firstInitial)\(lastInitial)"
            } else if components.count == 1 {
                return String(components[0].prefix(1)).uppercased()
            }
        } else if let email = user?.email {
            return String(email.prefix(1)).uppercased()
        }
        return "U"
    }
    
    private func loadOutstandingBalances() {
        // Fetch outstanding balances from Firestore
        firestoreService.fetchOutstandingBalances { balances in
            DispatchQueue.main.async {
                self.outstandingBalances = balances
                print("✅ Loaded \(balances.count) outstanding balances from Firestore")
            }
        }
    }
    
    private func updateCommunityStatistics() {
            for community in firestoreService.userCommunities {
                if let communityId = community.id {
                    firestoreService.updateCommunityStatistics(communityId: communityId) { success, error in
                        if let error = error {
                            print("❌ Error updating statistics for community \(communityId): \(error)")
                        }
                    }
                }
            }
        }
    
    private func refreshData() async {
            firestoreService.fetchUserCommunities()
        loadOutstandingBalances()
    }
}

// MARK: - Outstanding Balance Model

struct OutstandingBalance: Identifiable {
    let id: String
    let profilePicture: String?
    let username: String
    let name: String
    let netAmount: Double // Net amount (positive = they owe you, negative = you owe them)
    let transactions: [BalanceTransaction] // Individual transactions that make up this balance
    let counterpartyId: String // ID of the other user
    
    // Computed properties for easier use
    var isOwed: Bool { netAmount < 0 } // true = you owe them, false = they owe you
    var displayAmount: Double { abs(netAmount) }
    var isPositive: Bool { netAmount > 0 }
}

struct BalanceTransaction: Identifiable {
    let id: String
    let betId: String
    let betTitle: String
    let amount: Double
    let isOwed: Bool // true = you owe them, false = they owe you
    let date: Date
    let communityName: String
}

// MARK: - All Balances View

struct AllBalancesView: View {
    let balances: [OutstandingBalance]
    let firestoreService: FirestoreService
    @Environment(\.dismiss) private var dismiss
    
    // Computed property for sorted balances to avoid complex inline sorting
    private var sortedBalances: [OutstandingBalance] {
        balances.sorted { first, second in
            if first.isOwed == second.isOwed {
                if first.isOwed {
                    return first.displayAmount < second.displayAmount
                } else {
                    return first.displayAmount > second.displayAmount
                }
            } else {
                return !first.isOwed && second.isOwed
            }
        }
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title3)
                            .foregroundColor(.gray)
                            .frame(width: 40, height: 40)
                            .background(Color.gray.opacity(0.1))
                            .clipShape(Circle())
                    }
                    
                    Spacer()
                    
                    Text("Outstanding Balances")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    // Placeholder for balance
                    Color.clear
                        .frame(width: 40, height: 40)
                }
                .padding(.horizontal, 16)
                .padding(.vertical, 16)
                .background(Color.white)
                
                // Content
                if sortedBalances.isEmpty {
                    // Empty state when no balances
                    VStack(spacing: 20) {
                        Spacer()
                        
                        Image(systemName: "checkmark.circle.fill")
                            .font(.system(size: 64))
                            .foregroundColor(.slingBlue)
                        
                        Text("All Caught Up!")
                            .font(.title2)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                        
                        Text("You don't have any outstanding balances at the moment. Everyone is square!")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                            .padding(.horizontal, 32)
                        
                        Spacer()
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .background(Color.white)
                } else {
                    ScrollView {
                        LazyVStack(spacing: 16) {
                            ForEach(sortedBalances) { balance in
                                DetailedBalanceRow(balance: balance, firestoreService: firestoreService)
                            }
                        }
                        .padding(.horizontal, 16)
                        .padding(.top, 20)
                    }
                }
            }
            .background(Color.white)
            .navigationBarHidden(true)
        }
    }
}

// MARK: - Detailed Balance Row

struct DetailedBalanceRow: View {
    let balance: OutstandingBalance
    let firestoreService: FirestoreService
    @State private var showingResolutionModal = false
    @State private var showingBreakdownModal = false
    
    var body: some View {
        VStack(spacing: 0) {
            // Main balance row
            HStack(spacing: 16) {
            // Profile Picture
            if let profilePicture = balance.profilePicture, !profilePicture.isEmpty {
                AsyncImage(url: URL(string: profilePicture)) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    Circle()
                        .fill(AnyShapeStyle(Color.slingGradient))
                        .overlay(
                            Text(String(balance.name.prefix(1)).uppercased())
                                .font(.title3)
                                .fontWeight(.bold)
                                .foregroundColor(.white)
                        )
                }
                .frame(width: 56, height: 56)
                .clipShape(Circle())
            } else {
                Circle()
                    .fill(AnyShapeStyle(Color.slingGradient))
                    .frame(width: 56, height: 56)
                    .overlay(
                        Text(String(balance.name.prefix(1)).uppercased())
                            .font(.title3)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                    )
            }
            
            // User Info
            VStack(alignment: .leading, spacing: 6) {
                Text(balance.name)
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                
                Text(balance.username)
                    .font(.subheadline)
                    .foregroundColor(.gray)
            }
            
            Spacer()
            
            // Amount
            VStack(alignment: .trailing, spacing: 4) {
                HStack(spacing: 6) {
                    Image(systemName: "bolt.fill")
                        .font(.caption)
                        .foregroundColor(balance.isOwed ? .red : .green)
                    
                        Text("\(String(format: "%.0f", balance.displayAmount))")
                        .font(.title3)
                        .fontWeight(.bold)
                        .foregroundColor(balance.isOwed ? .red : .green)
                }
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(
                        (balance.isOwed ? Color.red : Color.green).opacity(0.1)
                    )
                    .cornerRadius(8)
                }
            }
            .padding(.horizontal, 20)
            .padding(.top, 20)
            .padding(.bottom, 20)
            
            // Bet breakdown section
            VStack(spacing: 12) {
                // Bet breakdown header
                HStack {
                    Text("Breakdown")
                        .font(.caption)
                        .foregroundColor(.gray)
                    
                    Spacer()
                    
                    Text("\(balance.transactions.count) total")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                .padding(.horizontal, 20)
                
                // Show up to 3 bets
                VStack(spacing: 8) {
                    ForEach(Array(balance.transactions.prefix(3)), id: \.id) { transaction in
                        BetBreakdownRow(transaction: transaction)
                    }
                    
                    // Show "View All" if there are more than 3 bets
                    if balance.transactions.count > 3 {
                        Button(action: {
                            showingBreakdownModal = true
                        }) {
                            HStack(spacing: 8) {
                                Text("View All \(balance.transactions.count) Bets")
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                    .foregroundColor(.slingBlue)
                                
                                Image(systemName: "chevron.right")
                                    .font(.caption)
                                    .foregroundColor(.slingBlue)
                            }
                            .padding(.horizontal, 16)
                            .padding(.vertical, 8)
                            .background(Color.slingBlue.opacity(0.1))
                            .cornerRadius(8)
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                .padding(.horizontal, 20)
                .padding(.bottom, 20)
            }
        }
        .background(Color.white)
        .cornerRadius(16)
        .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
        .sheet(isPresented: $showingBreakdownModal) {
            BalanceBreakdownModal(balance: balance)
        }
        .onTapGesture {
            showingResolutionModal = true
        }
        .sheet(isPresented: $showingResolutionModal) {
            BalanceResolutionModal(balance: balance, firestoreService: firestoreService)
        }
    }
}

// MARK: - Bet Breakdown Row

struct BetBreakdownRow: View {
    let transaction: BalanceTransaction
    
    var body: some View {
        HStack(spacing: 12) {
            // Bet icon
            Circle()
                .fill(transaction.isOwed ? Color.red.opacity(0.1) : Color.green.opacity(0.1))
                .frame(width: 32, height: 32)
                .overlay(
                    Image(systemName: "list.bullet.clipboard")
                        .font(.caption)
                        .foregroundColor(transaction.isOwed ? .red : .green)
                )
            
            // Bet details
            VStack(alignment: .leading, spacing: 2) {
                Text(transaction.betTitle)
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .foregroundColor(.black)
                    .lineLimit(1)
                
                Text(transaction.communityName)
                    .font(.caption)
                    .foregroundColor(.gray)
                    .lineLimit(1)
            }
            
            Spacer()
            
            // Amount
            VStack(alignment: .trailing, spacing: 2) {
                HStack(spacing: 4) {
                    Image(systemName: "bolt.fill")
                        .font(.caption)
                        .foregroundColor(transaction.isOwed ? .red : .green)
                    
                    Text("\(String(format: "%.0f", transaction.amount))")
                        .font(.subheadline)
                        .fontWeight(.semibold)
                        .foregroundColor(transaction.isOwed ? .red : .green)
                }
                
                Text(transaction.date, style: .date)
                    .font(.caption)
                    .foregroundColor(.gray)
            }
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 8)
        .background(Color.gray.opacity(0.05))
        .cornerRadius(8)
    }
}

// MARK: - Balance Breakdown Modal

struct BalanceBreakdownModal: View {
    let balance: OutstandingBalance
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title3)
                            .foregroundColor(.gray)
                            .frame(width: 40, height: 40)
                            .background(Color.gray.opacity(0.1))
                            .clipShape(Circle())
                    }
                    
                    Spacer()
                    
                    VStack(spacing: 4) {
                        Text("Balance Breakdown")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                        
                        Text("with \(balance.name)")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                    }
                    
                    Spacer()
                    
                    // Placeholder for balance
                    Color.clear
                        .frame(width: 40, height: 40)
                }
                .padding(.horizontal, 16)
                .padding(.vertical, 16)
                .background(Color.white)
                
                // Summary card
                VStack(spacing: 16) {
                    HStack(spacing: 16) {
                        // Profile Picture
                        if let profilePicture = balance.profilePicture, !profilePicture.isEmpty {
                            AsyncImage(url: URL(string: profilePicture)) { image in
                                image
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                            } placeholder: {
                                Circle()
                                    .fill(AnyShapeStyle(Color.slingGradient))
                                    .overlay(
                                        Text(String(balance.name.prefix(1)).uppercased())
                                            .font(.title2)
                                            .fontWeight(.bold)
                                            .foregroundColor(.white)
                                    )
                            }
                            .frame(width: 64, height: 64)
                            .clipShape(Circle())
                        } else {
                            Circle()
                                .fill(AnyShapeStyle(Color.slingGradient))
                                .frame(width: 64, height: 64)
                                .overlay(
                                    Text(String(balance.name.prefix(1)).uppercased())
                                        .font(.title2)
                                        .fontWeight(.bold)
                                        .foregroundColor(.white)
                                )
                        }
                        
                        VStack(alignment: .leading, spacing: 4) {
                            Text(balance.name)
                                .font(.title3)
                                .fontWeight(.bold)
                                .foregroundColor(.black)
                            
                            Text(balance.username)
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }
                        
                        Spacer()
                        
                        // Total amount
                        VStack(alignment: .trailing, spacing: 4) {
                            HStack(spacing: 6) {
                                Image(systemName: "bolt.fill")
                                    .font(.title3)
                                    .foregroundColor(balance.isOwed ? .red : .green)
                                
                                Text("\(String(format: "%.0f", balance.displayAmount))")
                                    .font(.title2)
                                    .fontWeight(.bold)
                                    .foregroundColor(balance.isOwed ? .red : .green)
                            }
                            
                            Text("Total Balance")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                    }
                    .padding(20)
                    .background(Color.white)
                    .cornerRadius(16)
                    .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
                }
                .padding(.horizontal, 16)
                .padding(.top, 20)
                
                // All transactions list
                ScrollView {
                    LazyVStack(spacing: 12) {
                        ForEach(balance.transactions) { transaction in
                            DetailedBetBreakdownRow(transaction: transaction)
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.top, 20)
                }
            }
            .background(Color.white)
            .navigationBarHidden(true)
        }
    }
}

// MARK: - Detailed Bet Breakdown Row

struct DetailedBetBreakdownRow: View {
    let transaction: BalanceTransaction
    
    var body: some View {
        VStack(spacing: 12) {
            HStack(spacing: 16) {
                // Bet icon
                Circle()
                    .fill(transaction.isOwed ? Color.red.opacity(0.1) : Color.green.opacity(0.1))
                    .frame(width: 48, height: 48)
                    .overlay(
                        Image(systemName: "list.bullet.clipboard")
                            .font(.title3)
                            .foregroundColor(transaction.isOwed ? .red : .green)
                    )
                
                // Bet details
                VStack(alignment: .leading, spacing: 6) {
                    Text(transaction.betTitle)
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                    
                    HStack(spacing: 8) {
                        Text(transaction.communityName)
                            .font(.subheadline)
                            .foregroundColor(.gray)
                        
                        Text("•")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                        
                        Text(transaction.date, style: .date)
                            .font(.subheadline)
                            .foregroundColor(.gray)
                    }
                }
                
                Spacer()
                
                // Amount
                VStack(alignment: .trailing, spacing: 4) {
                    Text("\(String(format: "%.0f", transaction.amount))")
                        .font(.title3)
                        .fontWeight(.bold)
                        .foregroundColor(transaction.isOwed ? .red : .green)
                    
                    Text(transaction.isOwed ? "You Owe" : "They Owe")
                        .font(.caption)
                        .fontWeight(.medium)
                        .foregroundColor(transaction.isOwed ? .red : .green)
                }
            }
        }
        .padding(20)
        .background(Color.white)
        .cornerRadius(16)
        .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
    }
}

// MARK: - Outstanding Balance Card

struct OutstandingBalanceCard: View {
    let balance: OutstandingBalance
    let firestoreService: FirestoreService
    @State private var showingResolutionModal = false
    
    var body: some View {
        Button(action: {
            showingResolutionModal = true
        }) {
            VStack(spacing: 12) {
            // Profile Picture
            if let profilePicture = balance.profilePicture, !profilePicture.isEmpty {
                AsyncImage(url: URL(string: profilePicture)) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    Circle()
                        .fill(AnyShapeStyle(Color.slingGradient))
                        .overlay(
                            Text(String(balance.name.prefix(1)).uppercased())
                                .font(.title3)
                                .fontWeight(.bold)
                                .foregroundColor(.white)
                        )
                }
                .frame(width: 48, height: 48)
                .clipShape(Circle())
            } else {
                Circle()
                    .fill(AnyShapeStyle(Color.slingGradient))
                    .frame(width: 48, height: 48)
                    .overlay(
                        Text(String(balance.name.prefix(1)).uppercased())
                            .font(.title3)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                    )
            }
            
            // User Info
            VStack(spacing: 4) {
                Text(balance.name)
                    .font(.subheadline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                    .lineLimit(1)
                
                Text(balance.username)
                    .font(.caption)
                    .foregroundColor(.gray)
                    .lineLimit(1)
            }
            
            // Amount
            HStack(spacing: 4) {
                Image(systemName: "bolt.fill")
                    .font(.caption)
                    .foregroundColor(balance.isOwed ? .red : .green)
                
                Text("\(String(format: "%.0f", balance.displayAmount))")
                    .font(.subheadline)
                    .fontWeight(.bold)
                    .foregroundColor(balance.isOwed ? .red : .green)
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            .background(
                (balance.isOwed ? Color.red : Color.green).opacity(0.1)
            )
            .cornerRadius(8)
            

            }
            .frame(width: 80)
            .padding(16)
            .background(Color.white)
            .cornerRadius(16)
            .overlay(
                RoundedRectangle(cornerRadius: 16)
                    .stroke(Color.gray.opacity(0.2), lineWidth: 1)
            )
            .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
        }
        .buttonStyle(PlainButtonStyle())
        .sheet(isPresented: $showingResolutionModal) {
            BalanceResolutionModal(balance: balance, firestoreService: firestoreService)
        }
    }
}

// MARK: - Balance Resolution Modal

struct BalanceResolutionModal: View {
    let balance: OutstandingBalance
    let firestoreService: FirestoreService
    @Environment(\.dismiss) private var dismiss
    @State private var showingConfirmation = false
    @State private var isResolving = false
    @State private var paymentAmount: String = ""
    @State private var errorMessage = ""


    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title3)
                            .foregroundColor(.gray)
                            .frame(width: 40, height: 40)
                            .background(Color.gray.opacity(0.1))
                            .clipShape(Circle())
                    }
                    
                    Spacer()
                    
                    Text("Settle Balance")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    // Placeholder for balance
                    Color.clear
                        .frame(width: 40, height: 40)
                }
                .padding(.horizontal, 16)
                .padding(.vertical, 16)
                .background(Color.white)
                
                // Content - Single Flow Design
                ScrollView {
                    VStack(spacing: 24) {
                        // 1. Balance Summary & Context
                        balanceSummarySection
                        
                        // 2. Bet Breakdown
                        betBreakdownSection
                        

                    }
                    .padding(.horizontal, 16)
                    .padding(.bottom, 100) // Space for sticky button
                }
                
                // Sticky Action Button
                stickyActionButton
                
                // Error message
                if !errorMessage.isEmpty {
                    Text(errorMessage)
                        .font(.caption)
                        .foregroundColor(.red)
                        .padding(.horizontal, 16)
                        .padding(.bottom, 8)
                }
            }
            .background(Color.white)
            .navigationBarHidden(true)
            .alert(balance.isOwed ? "Mark as Paid" : "Mark as Received", isPresented: $showingConfirmation) {
                Button("Cancel", role: .cancel) { }
                Button(balance.isOwed ? "Mark as Paid" : "Mark as Received") {
                    resolveBalance()
                }
            } message: {
                Text(balance.isOwed ? 
                     "Are you sure you want to mark this balance as paid? This will remove it from your outstanding balances." :
                     "Are you sure you want to mark this balance as received? This will remove it from your outstanding balances.")
            }

        }
    }
    
    // MARK: - Balance Summary Section
    
    private var balanceSummarySection: some View {
        VStack(spacing: 16) {
            // Profile Picture and Name - Non-clickable
            VStack(spacing: 16) {
                VStack(spacing: 16) {
                    // Profile Picture
                    if let profilePicture = balance.profilePicture, !profilePicture.isEmpty {
                        AsyncImage(url: URL(string: profilePicture)) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                        } placeholder: {
                            Circle()
                                .fill(AnyShapeStyle(Color.slingGradient))
                                .overlay(
                                    Text(String(balance.name.prefix(1)).uppercased())
                                        .font(.title2)
                                        .fontWeight(.bold)
                                        .foregroundColor(.white)
                                )
                        }
                        .frame(width: 80, height: 80)
                        .clipShape(Circle())
                    } else {
                        Circle()
                            .fill(AnyShapeStyle(Color.slingGradient))
                            .frame(width: 80, height: 80)
                            .overlay(
                                Text(String(balance.name.prefix(1)).uppercased())
                                    .font(.title2)
                                    .fontWeight(.bold)
                                    .foregroundColor(.white)
                            )
                    }
                    
                    // User Info
                    VStack(spacing: 8) {
                        Text(balance.name)
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                        
                        Text(balance.username)
                            .font(.subheadline)
                            .foregroundColor(.gray)
                    }
                }
            }
            
            // Amount Display
            HStack(spacing: 8) {
                Image(systemName: "bolt.fill")
                    .font(.title2)
                    .foregroundColor(balance.isOwed ? .red : .green)
                
                Text("\(String(format: "%.0f", balance.displayAmount))")
                    .font(.title)
                    .fontWeight(.bold)
                    .foregroundColor(balance.isOwed ? .red : .green)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .background(
                (balance.isOwed ? Color.red : Color.green).opacity(0.1)
            )
            .cornerRadius(16)
            
            // Context Message
            Text(balance.isOwed ? 
                 "You owe \(balance.name) from \(balance.transactions.count) bet\(balance.transactions.count == 1 ? "" : "s")" :
                 "\(balance.name) owes you from \(balance.transactions.count) bet\(balance.transactions.count == 1 ? "" : "s")")
                .font(.subheadline)
                .foregroundColor(.gray)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 20)
        }
        .padding(.top, 20)
    }
    
    // MARK: - Bet Breakdown Section
    
    private var betBreakdownSection: some View {
        VStack(spacing: 16) {
            // Section Header
            HStack {
                Text("Breakdown")
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                
                Spacer()
            }
            .padding(.horizontal, 4)
            
            // Bet Transactions
            LazyVStack(spacing: 12) {
                ForEach(balance.transactions) { transaction in
                    BalanceTransactionRow(transaction: transaction)
                }
            }
        }
        .padding(.horizontal, 4)
    }
    

    
    // MARK: - Sticky Action Button
    
    private var stickyActionButton: some View {
        VStack(spacing: 0) {
            Divider()
                .background(Color.gray.opacity(0.2))
            
            Button(action: {
                showingConfirmation = true
            }) {
                HStack(spacing: 8) {
                    Image(systemName: "checkmark.circle.fill")
                        .font(.title3)
                    Text(balance.isOwed ? "Mark as Paid" : "Mark as Received")
                        .foregroundColor(.white)
                        .font(.headline)
                        .fontWeight(.semibold)
                }
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .padding(.vertical, 16)
                .background(AnyShapeStyle(Color.slingGradient))
                .cornerRadius(16)
            }
            .padding(.horizontal, 20)
            .padding(.vertical, 16)
            .background(Color.white)
        }
    }
    
    // MARK: - Helper Functions
    
    private func resolveBalance() {
        isResolving = true
        errorMessage = ""
        
        // Use the appropriate function based on whether user owes or is owed
        if balance.isOwed {
            // User owes money - mark as paid
            firestoreService.markBalanceAsPaid(counterpartyId: balance.counterpartyId, amount: balance.displayAmount) { success, error in
                DispatchQueue.main.async {
                    isResolving = false
                    
                    if success {
                        dismiss()
                        
                        // Show success feedback
                        let impactFeedback = UIImpactFeedbackGenerator(style: .medium)
                        impactFeedback.impactOccurred()
                    } else {
                        errorMessage = error ?? "Failed to mark balance as paid"
                    }
                }
            }
        } else {
            // User is owed money - mark as received
            firestoreService.resolveOutstandingBalance(balanceId: balance.id) { success, error in
                DispatchQueue.main.async {
                    isResolving = false
                    
                    if success {
                        dismiss()
                        
                        // Show success feedback
                        let impactFeedback = UIImpactFeedbackGenerator(style: .medium)
                        impactFeedback.impactOccurred()
                    } else {
                        errorMessage = error ?? "Failed to mark balance as received"
                    }
                }
            }
        }
    }
}

// MARK: - Balance Transaction Row

struct BalanceTransactionRow: View {
    let transaction: BalanceTransaction
    
    var body: some View {
        VStack(spacing: 8) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(transaction.betTitle)
                        .font(.subheadline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                        .lineLimit(2)
                    
                    Text(transaction.communityName)
                        .font(.caption)
                        .foregroundColor(.gray)
                    
                    Text(formatDate(transaction.date))
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                
                Spacer()
                
                VStack(alignment: .trailing, spacing: 4) {
                    HStack(spacing: 4) {
                        Image(systemName: "bolt.fill")
                            .font(.caption)
                            .foregroundColor(transaction.isOwed ? .red : .green)
                        
                        Text("\(String(format: "%.0f", transaction.amount))")
                            .font(.subheadline)
                            .fontWeight(.bold)
                            .foregroundColor(transaction.isOwed ? .red : .green)
                    }
                    

                }
            }
        }
        .padding(16)
        .background(Color.white)
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(Color.gray.opacity(0.2), lineWidth: 1)
        )
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy"
        return formatter.string(from: date)
    }
}

// MARK: - Community Card with Admin Status

struct CommunityCardWithAdmin: View {
    let community: FirestoreCommunity
    let firestoreService: FirestoreService
    let onViewCommunity: ((String) -> Void)?
    @State private var isAdmin: Bool = false
    
    var body: some View {
        CommunityCard(
            community: community,
            isAdmin: isAdmin,
            firestoreService: firestoreService,
            onViewCommunity: onViewCommunity
        )
        .onAppear {
            checkAdminStatus()
        }
    }
    
    private func checkAdminStatus() {
        guard let userEmail = firestoreService.currentUser?.email else { return }
        firestoreService.isUserAdminInCommunity(communityId: community.id ?? "", userEmail: userEmail) { adminStatus in
            DispatchQueue.main.async {
                self.isAdmin = adminStatus
            }
        }
    }
}

// MARK: - Community List Item

struct CommunityListItem: View {
    let community: FirestoreCommunity
    let firestoreService: FirestoreService
    let onViewCommunity: ((String) -> Void)?
    @State private var showingCommunityDetail = false
    @State private var isAdmin: Bool = false
    @State private var actualMemberCount: Int = 0
    @State private var actualBetCount: Int = 0
    
    var body: some View {
        Button(action: {
            // Track community tap
            AnalyticsService.shared.trackCommunityView(
                communityId: community.id ?? "",
                communityName: community.name,
                memberCount: community.member_count,
                betCount: community.total_bets
            )
            AnalyticsService.shared.trackCommunitiesInteraction(
                action: .communityTap,
                communityId: community.id,
                communityName: community.name
            )
            showingCommunityDetail = true
        }) {
            HStack(alignment: .center, spacing: 12) {
                communityAvatarView
                communityContentView
                
                Spacer()
                
                // Right Arrow - vertically centered
                Image(systemName: "chevron.right")
                    .font(.subheadline)
                    .foregroundColor(.gray)
                    .frame(width: 20, height: 20)
            }
            .padding(.horizontal, 0) // Remove horizontal padding to align with header
            .padding(.vertical, 10) // Slightly reduced vertical padding for tighter spacing
        }
        .buttonStyle(PlainButtonStyle())
        .sheet(isPresented: $showingCommunityDetail) {
            EnhancedCommunityDetailView(
                community: community, 
                firestoreService: firestoreService,
                onChatTap: {
                    // Navigate to chat for this community
                    // This will be handled by the parent view
                }
            )
        }
        .onAppear {
            checkAdminStatus()
            loadCommunityMetrics()
        }
    }
    
    private var communityAvatarView: some View {
        Group {
            if let profileImageUrl = community.profile_image_url, !profileImageUrl.isEmpty {
                AsyncImage(url: URL(string: profileImageUrl)) { phase in
                    switch phase {
                    case .success(let image):
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                    case .failure(_), .empty:
                        // Fallback to initials on error or while loading
                        Circle()
                            .fill(AnyShapeStyle(Color.slingGradient))
                            .overlay(
                                Text(String(community.name.prefix(1)).uppercased())
                                    .font(.title2)
                                    .fontWeight(.bold)
                                    .foregroundColor(.white)
                            )
                    @unknown default:
                        Circle()
                            .fill(AnyShapeStyle(Color.slingGradient))
                            .overlay(
                                Text(String(community.name.prefix(1)).uppercased())
                                    .font(.title2)
                                    .fontWeight(.bold)
                                    .foregroundColor(.white)
                            )
                    }
                }
            } else {
                // Fallback to initials if no profile image
                Circle()
                    .fill(AnyShapeStyle(Color.slingGradient))
                    .overlay(
                        Text(String(community.name.prefix(1)).uppercased())
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                    )
            }
        }
        .frame(width: 44, height: 44)
        .clipShape(Circle())
    }
    
    private var communityContentView: some View {
        VStack(alignment: .leading, spacing: 4) {
            HStack {
                Text(community.name)
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                
                // Crown icon for admin users
                if isAdmin {
                    Image(systemName: "crown.fill")
                        .font(.caption)
                        .foregroundColor(.yellow)
                }
                
                Spacer()
            }
            
            HStack(spacing: 12) {
                HStack(spacing: 4) {
                    Image(systemName: "person.2.fill")
                        .font(.caption)
                        .foregroundColor(.gray)
                    Text("\(actualMemberCount) members")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                
                HStack(spacing: 4) {
                    Image(systemName: "list.bullet.clipboard")
                        .font(.caption)
                        .foregroundColor(.gray)
                    Text("\(actualBetCount) bets")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                
                Spacer()
            }
        }
    }
    
    private func checkAdminStatus() {
        guard let userEmail = firestoreService.currentUser?.email else { return }
        firestoreService.isUserAdminInCommunity(communityId: community.id ?? "", userEmail: userEmail) { adminStatus in
            DispatchQueue.main.async {
                self.isAdmin = adminStatus
            }
        }
    }
    
    private func loadCommunityMetrics() {
        guard let communityId = community.id else { return }
        
        // Load member count
        firestoreService.fetchCommunityMembers(communityId: communityId) { members in
            DispatchQueue.main.async {
                self.actualMemberCount = members.count
            }
        }
        
        // Load bet count
        let communityBets = firestoreService.bets.filter { $0.community_id == communityId }
        actualBetCount = communityBets.count
    }
}

// MARK: - Community Card

struct CommunityCard: View {
    let community: FirestoreCommunity
    let isAdmin: Bool
    let firestoreService: FirestoreService
    let onViewCommunity: ((String) -> Void)?
    @State private var showingCommunityDetail = false
    @State private var showingShareSheet = false
    @State private var showingSettingsModal = false
    @State private var actualMemberCount: Int = 0
    @State private var actualBetCount: Int = 0
    
    var body: some View {
        Button(action: {
            showingCommunityDetail = true
        }) {
        VStack(alignment: .leading, spacing: 12) {
            // Header with Admin Badge and Three Dots Menu
            HStack {
                Text(community.name)
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.black)
                
                Spacer()
                
                if isAdmin {
                    HStack(spacing: 4) {
                        Image(systemName: "crown.fill")
                            .font(.caption)
                            .foregroundColor(.purple)
                        Text("Admin")
                            .font(.caption)
                            .fontWeight(.medium)
                            .foregroundColor(.purple)
                    }
                    .padding(.horizontal, 8)
                    .padding(.vertical, 4)
                    .background(Color.purple.opacity(0.1))
                    .cornerRadius(8)
                    .overlay(
                        RoundedRectangle(cornerRadius: 8)
                            .stroke(Color.purple, lineWidth: 1)
                    )
                }
                
                // Three Dots Menu
                Menu {
                    Button(action: {
                        UIPasteboard.general.string = community.invite_code
                        let impactFeedback = UIImpactFeedbackGenerator(style: .light)
                        impactFeedback.impactOccurred()
                    }) {
                            Label("Copy Invite Code", systemImage: "list.bullet.clipboard")
                    }
                    
                    Button(action: {
                        showingShareSheet = true
                    }) {
                        Label("Share Community", systemImage: "square.and.arrow.up")
                    }
                    
                    if isAdmin {
                    Button(action: {
                        showingSettingsModal = true
                    }) {
                            Label("Settings", systemImage: "gearshape")
                        }
                    }
                    
                    Button(action: {
                        onViewCommunity?(community.name)
                    }) {
                        Label("View Community", systemImage: "arrow.up.right.square")
                    }
                } label: {
                    Image(systemName: "ellipsis")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                        .frame(width: 24, height: 24)
                }
            }
            
            // Statistics
            HStack(spacing: 16) {
                        HStack(spacing: 4) {
                    Image(systemName: "person.2")
                                .font(.caption)
                        .foregroundColor(.gray)
                    Text("\(actualMemberCount) members")
                                .font(.subheadline)
                        .foregroundColor(.gray)
                }
                
                HStack(spacing: 4) {
                    Image(systemName: "chart.line.uptrend.xyaxis")
                        .font(.caption)
                        .foregroundColor(.gray)
                    Text("\(actualBetCount) bets")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
            }
            
            // Footer with creation date
            HStack {
                Text("Created \(formatDate(community.created_date))")
                    .font(.caption)
                    .foregroundColor(.gray)
                
                Spacer()
            }
        }
        .padding(16)
        .background(Color.white)
        .cornerRadius(16)
        .overlay(
            RoundedRectangle(cornerRadius: 16)
                .stroke(Color.gray.opacity(0.2), lineWidth: 1)
        )
        }
        .buttonStyle(PlainButtonStyle())
        .sheet(isPresented: $showingCommunityDetail) {
            EnhancedCommunityDetailView(
                community: community, 
                firestoreService: firestoreService,
                onChatTap: {
                    // Navigate to chat for this community
                    // This will be handled by the parent view
                }
            )
        }
        .sheet(isPresented: $showingShareSheet) {
            ShareSheet(activityItems: ["Join my community on Sling! Use invite code: \(community.invite_code)"])
        }
        .sheet(isPresented: $showingSettingsModal) {
            CommunitySettingsView(community: community, isAdmin: isAdmin, firestoreService: firestoreService)
        }
        .onAppear {
            loadCommunityMetrics()
        }
    }
    
    private func loadCommunityMetrics() {
        guard let communityId = community.id else { return }
        
        // Load member count
        firestoreService.fetchCommunityMembers(communityId: communityId) { members in
            DispatchQueue.main.async {
                self.actualMemberCount = members.count
            }
        }
        
        // Load bet count
        let communityBets = firestoreService.bets.filter { $0.community_id == communityId }
        actualBetCount = communityBets.count
    }
    

}

// MARK: - Create View

struct CreateView: View {
    let firestoreService: FirestoreService
    @State private var showingCreateBetModal = false
    @State private var showingCreateCommunityModal = false
    @State private var showingJoinCommunityModal = false
    
    var body: some View {
        ScrollView {
            VStack(spacing: 24) {
                // Create Options
                VStack(spacing: 16) {
                    // Create Bet Option
                    Button(action: {
                        if firestoreService.userCommunities.isEmpty {
                            showingCreateCommunityModal = true
                        } else {
                            showingCreateBetModal = true
                        }
                    }) {
                        HStack(spacing: 16) {
                            Circle()
                                .fill(Color.slingLightBlue)
                                .frame(width: 50, height: 50)
                                .overlay(
                                    Image(systemName: "chart.line.uptrend.xyaxis")
                                        .font(.title2)
                                        .foregroundColor(.slingBlue)
                                )
                            
                            VStack(alignment: .leading, spacing: 4) {
                                Text("Create Bet")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Text("Start a new prediction market")
                                    .font(.subheadline)
                                    .foregroundColor(.gray)
                            }
                            
                            Spacer()
                            
                            Image(systemName: "chevron.right")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }
                        .padding(16)
                        .background(Color.white)
                        .cornerRadius(12)
                        .shadow(color: .black.opacity(0.05), radius: 4, x: 0, y: 2)
                    }
                    .disabled(firestoreService.userCommunities.isEmpty)
                    
                    // Create Community Option
                    Button(action: {
                        showingCreateCommunityModal = true
                    }) {
                        HStack(spacing: 16) {
                            Circle()
                                .fill(Color.slingLightPurple)
                                .frame(width: 50, height: 50)
                                .overlay(
                                    Image(systemName: "person.2")
                                        .font(.title2)
                                        .foregroundColor(.slingPurple)
                                )
                            
                            VStack(alignment: .leading, spacing: 4) {
                                Text("Create Community")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Text("Start a new betting group")
                                    .font(.subheadline)
                                    .foregroundColor(.gray)
                            }
                            
                            Spacer()
                            
                            Image(systemName: "chevron.right")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }
                        .padding(16)
                        .background(Color.white)
                        .cornerRadius(12)
                        .shadow(color: .black.opacity(0.05), radius: 4, x: 0, y: 2)
                    }
                    
                    // Join Community Option
                    Button(action: {
                        showingJoinCommunityModal = true
                    }) {
                        HStack(spacing: 16) {
                            Circle()
                                .fill(Color.green.opacity(0.2))
                                .frame(width: 50, height: 50)
                                .overlay(
                                    Image(systemName: "person.badge.plus")
                                        .font(.title2)
                                        .foregroundColor(.green)
                                )
                            
                            VStack(alignment: .leading, spacing: 4) {
                                Text("Join Community")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Text("Join an existing community")
                                    .font(.subheadline)
                                    .foregroundColor(.gray)
                            }
                            
                            Spacer()
                            
                            Image(systemName: "chevron.right")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }
                        .padding(16)
                        .background(Color.white)
                        .cornerRadius(12)
                        .shadow(color: .black.opacity(0.05), radius: 4, x: 0, y: 2)
                    }
                }
                .padding(.horizontal, 16)
                
                // Info Section
                if firestoreService.userCommunities.isEmpty {
                    VStack(spacing: 12) {
                        Image(systemName: "info.circle")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                        
                        Text("You need to join or create a community before you can create bets.")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                    }
                    .padding(20)
                    .background(Color.slingLightBlue)
                    .cornerRadius(12)
                    .padding(.horizontal, 16)
                }
            }
            .refreshable {
                // Refresh data when user pulls down
                await refreshData()
            }
            .padding(.bottom, 100)
        }
        .background(Color.white)
        .onAppear {
            firestoreService.fetchUserCommunities()
        }
        .sheet(isPresented: $showingCreateBetModal) {
            CreateBetView(firestoreService: firestoreService, preSelectedCommunity: nil)
        }
        .sheet(isPresented: $showingCreateCommunityModal) {
            CreateCommunityPage(firestoreService: firestoreService, onSuccess: {
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    // Navigate to communities tab
                }
            })
        }
        .sheet(isPresented: $showingJoinCommunityModal) {
            JoinCommunityPage(firestoreService: firestoreService, onSuccess: {
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    // Navigate to communities tab
                }
            })
        }
    }
    
    private func refreshData() async {
        // Fetch fresh data from Firestore
        firestoreService.fetchUserCommunities()
    }
}

// MARK: - Community Settings View

struct CommunitySettingsView: View {
    @Environment(\.dismiss) private var dismiss
    let community: FirestoreCommunity
    let isAdmin: Bool
    @ObservedObject var firestoreService: FirestoreService
    @State private var selectedTab = 0 // 0 = General, 1 = Members
    @State private var communityName: String
    @State private var isEditingName = false
    @State private var showingShareSheet = false
    @State private var members: [CommunityMemberInfo] = []
    @State private var isLoading = false
    
    init(community: FirestoreCommunity, isAdmin: Bool, firestoreService: FirestoreService) {
        self.community = community
        self.isAdmin = isAdmin
        self.firestoreService = firestoreService
        self._communityName = State(initialValue: community.name)
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Tab Bar
                HStack(spacing: 0) {
                    Button(action: { selectedTab = 0 }) {
                        Text("General")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(selectedTab == 0 ? .black : .gray)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 12)
                            .background(selectedTab == 0 ? Color.white : Color(.systemGray6))
                    }
                    
                    Button(action: { selectedTab = 1 }) {
                        Text("Members")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(selectedTab == 1 ? .black : .gray)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 12)
                            .background(selectedTab == 1 ? Color.white : Color(.systemGray6))
                    }
                }
                .background(Color(.systemGray6))
                
                // Content
                if selectedTab == 0 {
                    GeneralSettingsTab(community: community, isAdmin: isAdmin, firestoreService: firestoreService, communityName: $communityName, isEditingName: $isEditingName, showingShareSheet: $showingShareSheet)
                } else {
                    MembersTab(community: community, isAdmin: isAdmin, firestoreService: firestoreService, members: $members, isLoading: $isLoading)
                }
            }
            .navigationTitle("Community Settings")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
        .onAppear {
            loadMembers()
        }
    }
    
    private func loadMembers() {
        isLoading = true
        firestoreService.fetchCommunityMembers(communityId: community.id ?? "") { fetchedMembers in
            DispatchQueue.main.async {
                self.members = fetchedMembers
                self.isLoading = false
            }
        }
    }
}

// MARK: - General Settings Tab

struct GeneralSettingsTab: View {
    let community: FirestoreCommunity
    let isAdmin: Bool
    let firestoreService: FirestoreService
    @Binding var communityName: String
    @Binding var isEditingName: Bool
    @Binding var showingShareSheet: Bool
    @State private var isSaving = false
    @State private var errorMessage = ""
    @State private var showingCopyFeedback = false
    @State private var showingDeleteAlert = false
    @State private var showingLeaveAlert = false
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                // Community Name Section
                VStack(alignment: .leading, spacing: 12) {
                    HStack {
                        Text("Community Name")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                        
                        Spacer()
                        
                        if isAdmin {
                            Button(action: {
                                isEditingName.toggle()
                            }) {
                                Text(isEditingName ? "Cancel" : "Edit")
                                    .font(.subheadline)
                                    .foregroundColor(.slingBlue)
                            }
                        }
                    }
                    
                    if isEditingName {
                        VStack(spacing: 8) {
                            HStack {
                                TextField("Community Name", text: $communityName)
                                    .textFieldStyle(RoundedBorderTextFieldStyle())
                                
                                Button("Save") {
                                    saveCommunityName()
                                }
                                .foregroundColor(.slingBlue)
                                .disabled(communityName.isEmpty || isSaving)
                            }
                            
                            if !errorMessage.isEmpty {
                                Text(errorMessage)
                                    .font(.caption)
                                    .foregroundColor(.red)
                            }
                        }
                    } else {
                        Text(communityName)
                            .font(.subheadline)
                            .foregroundColor(.gray)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 16)
                
                // Invite Code Section
                VStack(alignment: .leading, spacing: 12) {
                    Text("Invite Code")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                    
                    VStack(alignment: .leading, spacing: 8) {
                        HStack(alignment: .center) {
                            Text(community.invite_code)
                                .font(.title2)
                                .fontWeight(.bold)
                                .foregroundColor(.black)
                            
                            Spacer()
                            
                            Button(action: {
                                UIPasteboard.general.string = community.invite_code
                                // Provide haptic feedback
                                let impactFeedback = UIImpactFeedbackGenerator(style: .light)
                                impactFeedback.impactOccurred()
                                
                                // Show copy feedback
                                showingCopyFeedback = true
                                DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                                    showingCopyFeedback = false
                                }
                            }) {
                                ZStack {
                                    if showingCopyFeedback {
                                        // Show checkmark when copied
                                        Image(systemName: "checkmark")
                                            .font(.system(size: 10, weight: .bold))
                                            .foregroundColor(.green)
                                    } else {
                                        // Show copy icon
                                Image(systemName: "list.bullet.clipboard")
                                            .font(.system(size: 14))
                                            .foregroundColor(.gray)
                                    }
                                }
                            }
                            .buttonStyle(PlainButtonStyle())
                        }
                        .padding(12)
                        .background(Color(.systemGray6))
                        .cornerRadius(8)
                        
                        Text("Share this code with friends to invite them to your community.")
                            .font(.caption)
                            .foregroundColor(.gray)
                        
                        Button(action: {
                            showingShareSheet = true
                        }) {
                            HStack(spacing: 8) {
                                Image(systemName: "square.and.arrow.up")
                                Text("Share Invite Code")
                            }
                            .foregroundColor(.white)
                            .padding(.horizontal, 20)
                            .padding(.vertical, 12)
                            .frame(maxWidth: .infinity)
                            .background(Color.slingGradient)
                            .cornerRadius(10)
                        }
                    }
                }
                .padding(.horizontal, 16)
                
                // Community Stats Section
                VStack(alignment: .leading, spacing: 12) {
                    Text("Community Stats")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                    
                    VStack(spacing: 8) {
                        HStack {
                            Text("Members")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                            Spacer()
                            Text("\(community.member_count)")
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.black)
                        }
                        
                        HStack {
                            Text("Total Bets")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                            Spacer()
                            Text("\(community.total_bets)")
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.black)
                        }
                        
                        HStack {
                            Text("Created")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                            Spacer()
                            Text(formatDate(community.created_date))
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.black)
                        }
                        
                        HStack {
                            Text("Status")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                            Spacer()
                            HStack(spacing: 4) {
                                Circle()
                                    .fill(community.is_active == true ? Color.green : Color.red)
                                    .frame(width: 8, height: 8)
                                Text(community.is_active == true ? "Active" : "Inactive")
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                    .foregroundColor(.black)
                            }
                        }
                    }
                    .padding(12)
                    .background(Color(.systemGray6))
                    .cornerRadius(8)
                }
                .padding(.horizontal, 16)
                
                // Actions Section
                VStack(alignment: .leading, spacing: 12) {
                    Text("Actions")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                    
                    VStack(spacing: 0) {
                        if isAdmin {
                            // Admin-only: Delete Community
                            Button(action: {
                                showDeleteCommunityAlert()
                            }) {
                                HStack {
                                    Image(systemName: "trash")
                                        .font(.title3)
                                        .foregroundColor(.red)
                                        .frame(width: 24, height: 24)
                                    
                                    VStack(alignment: .leading, spacing: 2) {
                                        Text("Delete Community")
                                            .font(.subheadline)
                                            .fontWeight(.medium)
                                            .foregroundColor(.red)
                                        Text("Permanently delete this community for all members")
                                            .font(.caption)
                                            .foregroundColor(.gray)
                                    }
                                    
                                    Spacer()
                                    
                                    Image(systemName: "chevron.right")
                                        .font(.caption)
                                        .foregroundColor(.gray)
                                }
                                .padding(.horizontal, 12)
                                .padding(.vertical, 12)
                            }
                            .buttonStyle(PlainButtonStyle())
                            
                            Divider()
                                .padding(.horizontal, 12)
                        }
                        
                        // Leave Community (available to all members)
                        Button(action: {
                            showLeaveCommunityAlert()
                        }) {
                            HStack {
                                Image(systemName: "person.badge.minus")
                                    .font(.title3)
                                    .foregroundColor(.orange)
                                    .frame(width: 24, height: 24)
                                
                                VStack(alignment: .leading, spacing: 2) {
                                    Text("Leave Community")
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                        .foregroundColor(.orange)
                                    Text("You can rejoin later using the invite code")
                                        .font(.caption)
                                        .foregroundColor(.gray)
                                }
                                
                                Spacer()
                                
                                Image(systemName: "chevron.right")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                            }
                            .padding(.horizontal, 12)
                            .padding(.vertical, 12)
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                    .background(Color(.systemGray6))
                    .cornerRadius(8)
                }
                .padding(.horizontal, 16)
            }
            .padding(.bottom, 20)
        }
        .background(Color.white)
        .sheet(isPresented: $showingShareSheet) {
            ShareSheet(activityItems: ["Join my community on Sling! Use invite code: \(community.invite_code)"])
        }
        .alert("Leave Community", isPresented: $showingLeaveAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Leave", role: .destructive) {
                leaveCommunity()
            }
        } message: {
            Text("Are you sure you want to leave this community? You can rejoin later using the invite code.")
        }
        .alert("Delete Community", isPresented: $showingDeleteAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Delete", role: .destructive) {
                deleteCommunity()
            }
        } message: {
            Text("Are you sure you want to delete this community? This action cannot be undone and all data will be permanently lost.")
        }
    }
    
    private func showLeaveCommunityAlert() {
        showingLeaveAlert = true
    }
    
    private func showDeleteCommunityAlert() {
        showingDeleteAlert = true
    }
    
    private func leaveCommunity() {
        guard let userEmail = firestoreService.currentUser?.email else { return }
        
        firestoreService.leaveCommunity(communityId: community.id ?? "", userEmail: userEmail) { success in
            DispatchQueue.main.async {
                if success {
                    SlingLogInfo("User left community: \(self.community.name)")
                    // Dismiss the settings view
                    dismiss()
                }
            }
        }
    }
    
    private func deleteCommunity() {
        firestoreService.deleteCommunity(communityId: community.id ?? "") { success in
            DispatchQueue.main.async {
                if success {
                    SlingLogInfo("Admin deleted community: \(self.community.name)")
                    // Dismiss the settings view
                    dismiss()
                }
            }
        }
    }
    
    private func saveCommunityName() {
        guard !communityName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            errorMessage = "Community name cannot be empty"
            return
        }
        
        isSaving = true
        errorMessage = ""
        
        firestoreService.updateCommunityName(communityId: community.id ?? "", newName: communityName.trimmingCharacters(in: .whitespacesAndNewlines)) { success in
            DispatchQueue.main.async {
                isSaving = false
                if success {
                    isEditingName = false
                } else {
                    errorMessage = "Failed to update community name"
                }
            }
        }
    }
}

// MARK: - Members Tab

struct MembersTab: View {
    let community: FirestoreCommunity
    let isAdmin: Bool
    let firestoreService: FirestoreService
    @Binding var members: [CommunityMemberInfo]
    @Binding var isLoading: Bool
    @State private var showingShareSheet = false
    @State private var memberToKick: CommunityMemberInfo?
    @State private var showingKickAlert = false
    
    var body: some View {
        VStack {
            if isLoading {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle())
                    .scaleEffect(1.5)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                List {
                    ForEach(members, id: \.email) { member in
                        HStack(spacing: 12) {
                            // Profile Picture
                            Circle()
                                .fill(Color.slingGradient)
                                .frame(width: 40, height: 40)
                                .overlay(
                                    Text(String(member.name.prefix(1)).uppercased())
                                        .font(.subheadline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(.white)
                                )
                            
                            VStack(alignment: .leading, spacing: 4) {
                                HStack {
                                    Text(member.name)
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                        .foregroundColor(.black)
                                    
                                    if member.isAdmin {
                                        HStack(spacing: 4) {
                                            Image(systemName: "crown.fill")
                                                .font(.caption)
                                                .foregroundColor(.slingPurple)
                                            Text("Admin")
                                                .font(.caption)
                                                .fontWeight(.medium)
                                                .foregroundColor(.slingPurple)
                                        }
                                        .padding(.horizontal, 6)
                                        .padding(.vertical, 2)
                                        .background(Color.slingPurple.opacity(0.1))
                                        .cornerRadius(6)
                                        .overlay(
                                            RoundedRectangle(cornerRadius: 6)
                                                .stroke(Color.slingPurple, lineWidth: 0.5)
                                        )
                                    }
                                }
                                
                                Text(member.email)
                                    .font(.caption)
                                    .foregroundColor(.gray)
                            }
                            
                            Spacer()
                            
                            if isAdmin && !member.isAdmin && member.email != firestoreService.currentUser?.email {
                                Button(action: {
                                    memberToKick = member
                                    showingKickAlert = true
                                }) {
                                    Image(systemName: "xmark")
                                        .font(.caption)
                                        .foregroundColor(.red)
                                        .padding(8)
                                        .background(Color.red.opacity(0.1))
                                        .clipShape(Circle())
                                }
                            }
                        }
                        .padding(.vertical, 4)
                    }
                    
                    // Share Button at bottom
                    Section {
                        Button(action: {
                            showingShareSheet = true
                        }) {
                            HStack(spacing: 12) {
                                Image(systemName: "square.and.arrow.up")
                                    .font(.title3)
                                    .foregroundColor(.slingBlue)
                                
                                VStack(alignment: .leading, spacing: 4) {
                                    Text("Share Community")
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                        .foregroundColor(.black)
                                    Text("Invite friends to join")
                                        .font(.caption)
                                        .foregroundColor(.gray)
                                }
                                
                                Spacer()
                                
                                Image(systemName: "chevron.right")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                            }
                            .padding(.vertical, 8)
                        }
                    }
                }
            }
        }
        .background(Color.white)
        .sheet(isPresented: $showingShareSheet) {
            ShareSheet(activityItems: ["Join my community on Sling! Use invite code: \(community.invite_code)"])
        }
        .alert("Remove Member", isPresented: $showingKickAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Remove", role: .destructive) {
                if let member = memberToKick {
                    kickMember(member)
                }
            }
        } message: {
            if let member = memberToKick {
                Text("Are you sure you want to remove \(member.name) from this community? They can rejoin later using the invite code.")
            }
        }
    }
    
    private func kickMember(_ member: CommunityMemberInfo) {
        firestoreService.kickMemberFromCommunity(communityId: community.id ?? "", memberEmail: member.email) { success in
            DispatchQueue.main.async {
                if success {
                    // Remove member from local list
                    members.removeAll { $0.email == member.email }
                    SlingLogInfo("Admin removed member from community", file: #file, function: #function, line: #line)
                }
                memberToKick = nil
            }
        }
    }
}

// MARK: - Share Sheet

struct ShareSheet: UIViewControllerRepresentable {
    let activityItems: [Any]
    
    func makeUIViewController(context: Context) -> UIActivityViewController {
        let controller = UIActivityViewController(activityItems: activityItems, applicationActivities: nil)
        return controller
    }
    
    func updateUIViewController(_ uiViewController: UIActivityViewController, context: Context) {}
}

// MARK: - Profile View

struct ProfileView: View {
    let firestoreService: FirestoreService
    @Binding var showingEditProfile: Bool
    @State private var selectedCommunity: FirestoreCommunity?
    @State private var showingCommunityDetail = false
    
    // Fullscreen image state
    @State private var showImageFullscreen = false
    @State private var selectedImageUrl: String?
    
    private func getUserInitials() -> String {
        let user = firestoreService.currentUser
        
        // Prioritize first and last name to get both initials
        if let firstName = user?.first_name, let lastName = user?.last_name, !firstName.isEmpty, !lastName.isEmpty {
            let firstInitial = String(firstName.prefix(1)).uppercased()
            let lastInitial = String(lastName.prefix(1)).uppercased()
            return "\(firstInitial)\(lastInitial)"
        }
        
        // If we have first name but no last name, try to get second initial from display name
        if let firstName = user?.first_name, !firstName.isEmpty {
            let firstInitial = String(firstName.prefix(1)).uppercased()
            if let displayName = user?.display_name, !displayName.isEmpty {
                let components = displayName.components(separatedBy: " ")
                if components.count >= 2 {
                    let lastInitial = String(components[1].prefix(1)).uppercased()
                    return "\(firstInitial)\(lastInitial)"
                }
            }
            return firstInitial
        }
        
        // Fallback to display name parsing
        if let displayName = user?.display_name, !displayName.isEmpty {
            let components = displayName.components(separatedBy: " ")
            if components.count >= 2 {
                let firstInitial = String(components[0].prefix(1)).uppercased()
                let lastInitial = String(components[1].prefix(1)).uppercased()
                return "\(firstInitial)\(lastInitial)"
            } else if components.count == 1 {
                return String(components[0].prefix(1)).uppercased()
            }
        }
        
        // Final fallback to email
        if let email = user?.email {
            return String(email.prefix(1)).uppercased()
        }
        
        return "U"
    }
    
    var body: some View {
        ScrollView {
            VStack(spacing: 20) {
                // Profile Information Card
                VStack(spacing: 24) {
                    // Profile Summary
                    HStack(spacing: 16) {
                        // Profile Picture or Initials - Enhanced with click handlers
                        ZStack {
                            if let profilePictureUrl = firestoreService.currentUser?.profile_picture_url {
                                // Show user's profile picture
                                AsyncImage(url: URL(string: profilePictureUrl)) { phase in
                                    switch phase {
                                    case .success(let image):
                                        image
                                            .resizable()
                                            .aspectRatio(contentMode: .fill)
                                            .frame(width: 80, height: 80)
                                            .clipShape(Circle())
                                            .overlay(
                                                Circle()
                                                    .stroke(Color.white, lineWidth: 4)
                                            )
                                            .onTapGesture {
                                                // Show fullscreen image
                                                selectedImageUrl = profilePictureUrl
                                                showImageFullscreen = true
                                            }
                                    case .failure(_):
                                        // Fallback to initials on error
                                        Circle()
                                            .fill(Color.slingGradient)
                                            .frame(width: 80, height: 80)
                                            .overlay(
                                                Text(getUserInitials())
                                                    .font(.largeTitle)
                                                    .fontWeight(.semibold)
                                                    .foregroundColor(.white)
                                            )
                                            .overlay(
                                                Circle()
                                                    .stroke(Color.white, lineWidth: 4)
                                            )
                                            .onTapGesture {
                                                // Change picture
                                                showingEditProfile = true
                                            }
                                    case .empty:
                                        // Show initials while loading
                                        Circle()
                                            .fill(Color.slingGradient)
                                            .frame(width: 80, height: 80)
                                            .overlay(
                                                Text(getUserInitials())
                                                    .font(.largeTitle)
                                                    .fontWeight(.semibold)
                                                    .foregroundColor(.white)
                                            )
                                            .overlay(
                                                Circle()
                                                    .stroke(Color.white, lineWidth: 4)
                                            )
                                            .onTapGesture {
                                                // Change picture
                                                showingEditProfile = true
                                            }
                                    @unknown default:
                                        Circle()
                                            .fill(Color.slingGradient)
                                            .frame(width: 80, height: 80)
                                            .overlay(
                                                Text(getUserInitials())
                                                    .font(.largeTitle)
                                                    .fontWeight(.semibold)
                                                    .foregroundColor(.white)
                                            )
                                            .overlay(
                                                Circle()
                                                    .stroke(Color.white, lineWidth: 4)
                                            )
                                            .onTapGesture {
                                                // Change picture
                                                showingEditProfile = true
                                            }
                                    }
                                }
                            } else {
                                // Fallback to initials
                                Circle()
                                    .fill(Color.slingGradient)
                                    .frame(width: 80, height: 80)
                                    .overlay(
                                        Text(getUserInitials())
                                            .font(.largeTitle)
                                            .fontWeight(.semibold)
                                            .foregroundColor(.white)
                                    )
                                    .overlay(
                                        Circle()
                                            .stroke(Color.white, lineWidth: 4)
                                    )
                                    .onTapGesture {
                                        // Change picture
                                        showingEditProfile = true
                                    }
                            }
                            
                            // Swap icon overlay at 3-6 o'clock position
                            Circle()
                                .fill(Color.slingBlue)
                                .frame(width: 28, height: 28)
                                .overlay(
                                    Image(systemName: "arrow.2.squarepath")
                                        .font(.system(size: 12, weight: .medium))
                                        .foregroundColor(.white)
                                )
                                .overlay(
                                    Circle()
                                        .stroke(Color.white, lineWidth: 2)
                                )
                                .offset(x: 28, y: 28) // Position at 3-6 o'clock (half on, half off)
                                .onTapGesture {
                                    // Change picture
                                    showingEditProfile = true
                                }
                        }
                        
                        VStack(alignment: .leading, spacing: 4) {
                            HStack {
                                Text(firestoreService.currentUser?.display_name ?? "User")
                                    .font(.title2)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                
                                // Small Edit Profile Button
                                Button(action: {
                                    showingEditProfile = true
                                }) {
                                    Image(systemName: "pencil")
                                        .font(.title3)
                                        .foregroundColor(.slingBlue)
                                        .frame(width: 32, height: 32)
                                        .background(Color.slingLightBlue)
                                        .clipShape(Circle())
                                }
                            }
                            
                            Text(firestoreService.currentUser?.email ?? "user@example.com")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }
                        
                        Spacer()
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                    .background(Color.white)
                    .cornerRadius(16)
                    .shadow(color: .black.opacity(0.05), radius: 2, x: 0, y: 1)
                    

                }
                
                // Points Section
                VStack(alignment: .leading, spacing: 16) {
                    HStack {
                        HStack(spacing: 8) {
                            Image(systemName: "bolt.fill")
                                .foregroundColor(.slingBlue)
                                .font(.title3)
                            Text("Points")
                                .font(.title2)
                                .fontWeight(.bold)
                        }
                        
                        Spacer()
                        
                        Menu {
                            Button("All Communities Overview") {
                                // This will show overview of all communities combined
                            }
                            ForEach(firestoreService.userCommunities, id: \.id) { community in
                                Button(community.name) {
                                    // This will filter to show specific community
                                }
                            }
                        } label: {
                            HStack {
                                Text("All Communities Overview")
                                    .font(.subheadline)
                                    .foregroundColor(.gray)
                                Image(systemName: "chevron.down")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                            }
                            .padding(.horizontal, 12)
                            .padding(.vertical, 6)
                            .background(Color.gray.opacity(0.1))
                            .cornerRadius(8)
                        }
                    }
                    .padding(.horizontal, 16)
                    
                    // Total Winnings Card
                    VStack(spacing: 12) {
                        HStack {
                            HStack(spacing: 12) {
                                Circle()
                                    .fill(Color.slingGradient)
                                    .frame(width: 40, height: 40)
                                    .overlay(
                                        Image(systemName: "clock.arrow.circlepath")
                                            .font(.title3)
                                            .foregroundColor(.white)
                                    )
                                
                                VStack(alignment: .leading, spacing: 2) {
                                    Text("Total Winnings")
                                        .font(.headline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(.black)
                                    
                                    Text("Across all communities")
                                        .font(.caption)
                                        .foregroundColor(.gray)
                                }
                            }
                            
                            Spacer()
                            
                            HStack(spacing: 4) {
                                Image(systemName: "bolt.fill")
                                    .foregroundColor(.slingBlue)
                                    .font(.title3)
                                Text("0.00")
                                    .font(.title2)
                                    .fontWeight(.bold)
                                    .foregroundColor(.black)
                            }
                        }
                        .padding(.horizontal, 16)
                        .padding(.vertical, 20)
                        .background(Color.slingLightBlue)
                        .cornerRadius(16)
                    }
                    .padding(.horizontal, 16)
                    
                    // Community Balances
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Your Balance by Community")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                            .padding(.horizontal, 16)
                        
                        LazyVStack(spacing: 8) {
                            ForEach(firestoreService.userCommunities, id: \.id) { community in
                                Button(action: {
                                    selectedCommunity = community
                                    showingCommunityDetail = true
                                }) {
                                    HStack {
                                        Text(community.name)
                                            .font(.subheadline)
                                            .foregroundColor(.black)
                                        
                                        Spacer()
                                        
                                        HStack(spacing: 4) {
                                            Image(systemName: "bolt.fill")
                                                .foregroundColor(.slingBlue)
                                                .font(.caption)
                                            Text("0.00")
                                                .font(.subheadline)
                                                .fontWeight(.medium)
                                                .foregroundColor(.black)
                                        }
                                        
                                        Image(systemName: "chevron.right")
                                            .font(.caption)
                                            .foregroundColor(.gray)
                                    }
                                    .padding(.horizontal, 16)
                                    .padding(.vertical, 12)
                                    .background(Color.white)
                                    .cornerRadius(12)
                                    .shadow(color: .black.opacity(0.05), radius: 2, x: 0, y: 1)
                                }
                                .buttonStyle(PlainButtonStyle())
                            }
                        }
                    }
                }
                
                Spacer()
            }
        }
        .background(Color.white)
        .onAppear {
            // loadCommunityBalances()
        }
        .refreshable {
            // loadCommunityBalances()
        }
        .sheet(isPresented: $showingCommunityDetail) {
            if let community = selectedCommunity {
                CommunityDetailView(
                    community: community,
                    firestoreService: firestoreService
                )
            }
        }
        .fullScreenCover(isPresented: $showImageFullscreen) {
            if let imageUrl = selectedImageUrl {
                FullscreenImageView(imageUrl: imageUrl, isPresented: $showImageFullscreen)
            }
        }
    }
    

}

// MARK: - User Activity Models and Views

enum UserActivityType {
    case betPlaced
    case betWon
    case betLost
    case betVoided
    case betCreated
    case communityJoined
}

struct UserActivityItem: Identifiable {
    let id: String
    let type: UserActivityType
    let title: String
    let subtitle: String
    let communityName: String?
    let timestamp: Date
    let icon: String
    let iconColor: Color
}

struct ActivityRow: View {
    let activityItem: UserActivityItem
    
    private func formatTimestamp(_ date: Date) -> String {
        let now = Date()
        let timeInterval = now.timeIntervalSince(date)
        
        if timeInterval < 60 {
            return "Just now"
        } else if timeInterval < 3600 {
            let minutes = Int(timeInterval / 60)
            return "\(minutes)m ago"
        } else if timeInterval < 86400 {
            let hours = Int(timeInterval / 3600)
            return "\(hours)h ago"
        } else if timeInterval < 2592000 {
            let days = Int(timeInterval / 86400)
            return "\(days)d ago"
        } else {
            let formatter = DateFormatter()
            formatter.dateFormat = "MMM d"
            return formatter.string(from: date)
        }
    }
    
    private func extractChosenOption(from subtitle: String) -> String {
        // Extract the chosen option from "Chose: [option] • Wager: ⚡ [points]"
        if let choseRange = subtitle.range(of: "Chose: ") {
            let afterChose = subtitle[choseRange.upperBound...]
            if let bulletRange = afterChose.range(of: " • ") {
                return String(afterChose[..<bulletRange.lowerBound])
            }
        }
        return subtitle
    }
    
    private func extractWagerLabel(from subtitle: String) -> String {
        // Extract the wager label from "Chose: [option] • Wager: ⚡ [points]"
        if subtitle.contains("Wager: ⚡") {
            return "Wager: "
        } else if subtitle.contains("Paid: ⚡") {
            return "Paid: "
        } else if subtitle.contains("Lost: ⚡") {
            return "Lost: "
        }
        return "Wager: "
    }
    
    private func extractWagerValue(from subtitle: String) -> String {
        // Extract the wager value from "Chose: [option] • Wager: ⚡ [points]"
        if let wagerRange = subtitle.range(of: "Wager: ⚡ ") {
            return String(subtitle[wagerRange.upperBound...])
        } else if let paidRange = subtitle.range(of: "Paid: ⚡ ") {
            return String(subtitle[paidRange.upperBound...])
        } else if let lostRange = subtitle.range(of: "Lost: ⚡ ") {
            return String(subtitle[lostRange.upperBound...])
        }
        return subtitle
    }
    
    var body: some View {
        HStack(spacing: 16) {
            activityIcon
            
            VStack(alignment: .leading, spacing: 6) {
                activityTitle
                activitySubtitle
            }
            
            Spacer()
        }
        .padding(.horizontal, 20)
        .padding(.vertical, 16)
        .background(activityBackground)
    }
    
    private var activityIcon: some View {
            ZStack {
                Circle()
                .fill(iconBackgroundColor)
                    .frame(width: 48, height: 48)
                
                Image(systemName: activityItem.icon)
                    .font(.system(size: 18, weight: .medium))
                .foregroundColor(iconForegroundColor)
        }
    }
    
    private var iconBackgroundColor: Color {
        if activityItem.icon == "bolt.fill" {
            return Color.slingBlue.opacity(0.15)
        } else {
            return activityItem.iconColor.opacity(0.15)
        }
    }
    
    private var iconForegroundColor: Color {
        activityItem.icon == "bolt.fill" ? .slingBlue : activityItem.iconColor
    }
    
    private var activityTitle: some View {
        (Text(activityItem.title)
            .font(.system(size: 15, weight: .semibold))
            .foregroundColor(.primary) +
         Text(" \(formatTimestamp(activityItem.timestamp))")
            .font(.system(size: 15, weight: .regular))
            .foregroundColor(.secondary))
            .multilineTextAlignment(.leading)
            .lineLimit(2)
    }
                
    private var activitySubtitle: some View {
        HStack(spacing: 0) {
            Text("Chose: ")
                    .font(.system(size: 14, weight: .regular))
                    .foregroundColor(.secondary)
            
            Text(extractChosenOption(from: activityItem.subtitle))
                .font(.system(size: 14, weight: .semibold))
                .foregroundStyle(Color.slingGradient)
            
            Text(" • ")
                .font(.system(size: 14, weight: .regular))
                .foregroundColor(.secondary)
            
            Text(extractWagerLabel(from: activityItem.subtitle))
                .font(.system(size: 14, weight: .regular))
                .foregroundColor(.secondary)
            
            Image(systemName: "bolt.fill")
                .font(.system(size: 12, weight: .medium))
                .foregroundStyle(Color.slingGradient)
            
            Text(extractWagerValue(from: activityItem.subtitle))
                .font(.system(size: 14, weight: .regular))
                .foregroundColor(.secondary)
        }
                    .multilineTextAlignment(.leading)
        .lineLimit(1)
    }
                
    private var activityMetadata: some View {
                HStack(spacing: 8) {
            if let communityName = activityItem.communityName {
                Image(systemName: "person.2")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                Text(communityName)
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                Text("•")
                            .font(.caption)
                            .foregroundColor(.secondary)
            }
                        
            Text(formatTimestamp(activityItem.timestamp))
                            .font(.caption)
                            .foregroundColor(.secondary)
        }
    }
    
    private var activityBackground: some View {
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.white)
                .shadow(color: Color.black.opacity(0.05), radius: 2, x: 0, y: 1)
    }
}

// MARK: - Community Balance Row

struct CommunityBalanceRow: View {
    let name: String
    let balance: String
    
    var body: some View {
        HStack {
            Text(name)
                .font(.subheadline)
                .fontWeight(.medium)
                .foregroundColor(.black)
            
            Spacer()
            
            HStack(spacing: 4) {
                Image(systemName: "bolt.fill")
                    .font(.caption)
                    .foregroundColor(.slingBlue)
                Text(balance)
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .foregroundColor(.black)
            }
            
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(.gray)
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .background(Color.white)
    }
}

// MARK: - Community Detail View

struct CommunityDetailView: View {
    @Environment(\.dismiss) private var dismiss
    let community: FirestoreCommunity
    let firestoreService: FirestoreService
    @State private var members: [CommunityMemberInfo] = []
    @State private var isLoading = false
    @State private var showingTransactionHistory = false
    @State private var selectedMember: CommunityMemberInfo?
    @State private var userBalance: Double = 0.0
    @State private var memberBalances: [String: Double] = [:]
    @State private var hasLoadedBalances = false
    @StateObject private var timeTracker = TimeTracker()
    
    // Computed property to sort members by activity/balance
    private var sortedMembers: [CommunityMemberInfo] {
        return members.sorted { member1, member2 in
            let balance1 = memberBalances[member1.email] ?? 0.0
            let balance2 = memberBalances[member2.email] ?? 0.0
            
            // First: Members who owe you money (positive balances) - highest first
            if balance1 > 0 && balance2 <= 0 {
                return true
            } else if balance1 <= 0 && balance2 > 0 {
                return false
            } else if balance1 > 0 && balance2 > 0 {
                return balance1 > balance2
            }
            
            // Second: Members you owe money to (negative balances) - least debt first (closer to 0)
            else if balance1 < 0 && balance2 < 0 {
                return balance1 > balance2  // -10 comes before -20
            }
            
            // Third: Members with zero balance (least active) - alphabetical order
            else {
                return member1.name < member2.name
            }
        }
    }
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 20) {
                    // Header with back button and dropdown
                    HStack {
                        Button(action: {
                            AnalyticsService.shared.trackCommunityDetailInteraction(
                                action: .back,
                                communityId: community.id ?? "",
                                communityName: community.name
                            )
                            dismiss()
                        }) {
                            Image(systemName: "arrow.left")
                                .font(.title3)
                                .foregroundColor(.black)
                        }
                        
                        Spacer()
                        
                        Menu {
                            Button("All Members") {
                                AnalyticsService.shared.trackCommunityDetailInteraction(
                                    action: .filter,
                                    communityId: community.id ?? "",
                                    communityName: community.name,
                                    details: ["filter_type": "all_members"]
                                )
                            }
                            Button("Active Bets") {
                                AnalyticsService.shared.trackCommunityDetailInteraction(
                                    action: .filter,
                                    communityId: community.id ?? "",
                                    communityName: community.name,
                                    details: ["filter_type": "active_bets"]
                                )
                            }
                            Button("Settled Bets") {
                                AnalyticsService.shared.trackCommunityDetailInteraction(
                                    action: .filter,
                                    communityId: community.id ?? "",
                                    communityName: community.name,
                                    details: ["filter_type": "settled_bets"]
                                )
                            }
                        } label: {
                            HStack(spacing: 4) {
                                Text(community.name)
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Image(systemName: "chevron.down")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                            }
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.top, 16)
                    
                    // Subtitle
                    Text("Your balance in \(community.name)")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                        .frame(maxWidth: .infinity, alignment: .leading)
                        .padding(.horizontal, 16)
                    
                    // Your Balance Card
                    VStack(spacing: 12) {
                        HStack {
                            HStack(spacing: 12) {
                                Circle()
                                    .fill(Color.slingLightBlue)
                                    .frame(width: 40, height: 40)
                                    .overlay(
                                        Image(systemName: "person.2")
                                            .font(.title3)
                                            .foregroundColor(.slingBlue)
                                    )
                                
                                VStack(alignment: .leading, spacing: 2) {
                                    Text("Your Balance")
                                        .font(.subheadline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(.black)
                                    Text(firestoreService.currentUser?.email ?? "user@example.com")
                                        .font(.caption)
                                        .foregroundColor(.gray)
                                }
                            }
                            
                            Spacer()
                            
                            HStack(spacing: 4) {
                                Image(systemName: "bolt.fill")
                                    .font(.caption)
                                    .foregroundColor(.slingBlue)
                                if userBalance == 0.0 && isLoading {
                                    RoundedRectangle(cornerRadius: 4)
                                        .fill(Color.gray.opacity(0.3))
                                        .frame(width: 60, height: 16)
                                } else {
                                    Text(formatBalance(userBalance))
                                        .font(.subheadline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(userBalance >= 0 ? .black : .red)
                                }
                            }
                        }
                    }
                    .padding(16)
                    .background(Color.slingLightBlue)
                    .cornerRadius(12)
                    .padding(.horizontal, 16)
                    
                    // Check if there are any transactions
                    if hasLoadedBalances && memberBalances.values.allSatisfy({ $0 == 0.0 }) && userBalance == 0.0 {
                        // No transactions exist - show clear message
                        VStack(spacing: 16) {
                            Image(systemName: "doc.text")
                                .font(.system(size: 48))
                                .foregroundColor(Color.slingBlue.opacity(0.6))
                            
                            Text("No transactions yet")
                                .font(.headline)
                                .fontWeight(.semibold)
                                .foregroundColor(.black)
                            
                            Text("Bets and settlements will appear here once you start predicting in this community.")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                                .multilineTextAlignment(.center)
                        }
                        .padding(.vertical, 40)
                        .padding(.horizontal, 16)
                    } else if isLoading {
                        // Loading state
                        VStack(spacing: 16) {
                            ForEach(0..<min(3, members.count), id: \.self) { index in
                                HStack(spacing: 12) {
                                    Circle()
                                        .fill(Color.gray.opacity(0.3))
                                        .frame(width: 32, height: 32)
                                    
                                    VStack(alignment: .leading, spacing: 2) {
                                        RoundedRectangle(cornerRadius: 4)
                                            .fill(Color.gray.opacity(0.3))
                                            .frame(width: 100, height: 14)
                                        
                                        RoundedRectangle(cornerRadius: 4)
                                            .fill(Color.gray.opacity(0.3))
                                            .frame(width: 150, height: 12)
                                    }
                                    
                                    Spacer()
                                    
                                    RoundedRectangle(cornerRadius: 4)
                                        .fill(Color.gray.opacity(0.3))
                                        .frame(width: 60, height: 16)
                                }
                                .padding(.horizontal, 16)
                                .padding(.vertical, 12)
                            }
                        }
                        .background(Color.white)
                        .cornerRadius(12)
                        .padding(.horizontal, 16)
                    } else if !members.isEmpty {
                        // Member Balances List
                        VStack(alignment: .leading, spacing: 12) {
                            Text("Member Balances")
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.gray)
                                .padding(.horizontal, 16)
                            
                            VStack(spacing: 0) {
                                ForEach(sortedMembers, id: \.email) { member in
                                    Button(action: {
                                        AnalyticsService.shared.trackCommunityMemberInteraction(
                                            action: "balance_view",
                                            communityId: community.id ?? "",
                                            communityName: community.name,
                                            memberEmail: member.email,
                                            memberName: member.name
                                        )
                                        AnalyticsService.shared.trackCommunityDetailInteraction(
                                            action: .transactionHistory,
                                            communityId: community.id ?? "",
                                            communityName: community.name,
                                            details: ["member_email": member.email, "member_name": member.name]
                                        )
                                        selectedMember = member
                                        showingTransactionHistory = true
                                    }) {
                                        MemberBalanceRow(
                                            member: member,
                                            balance: formatBalance(memberBalances[member.email] ?? 0.0)
                                        )
                                    }
                                    .buttonStyle(PlainButtonStyle())
                                    
                                    if member.email != sortedMembers.last?.email {
                                        Divider()
                                            .padding(.leading, 16)
                                    }
                                }
                            }
                            .background(Color.white)
                            .cornerRadius(12)
                            .padding(.horizontal, 16)
                        }
                    }
                }
                .padding(.bottom, 20)
            }
            .background(Color.white)
            .navigationBarHidden(true)
            .onAppear {
                // Track community detail view
                AnalyticsService.shared.trackCommunityDetailInteraction(
                    action: .view,
                    communityId: community.id ?? "",
                    communityName: community.name,
                    details: ["member_count": community.member_count, "bet_count": community.total_bets]
                )
                timeTracker.startTracking(for: "community_detail_\(community.id ?? "")")
                
                loadMembers()
                loadBalances()
            }
            .onDisappear {
                // Track time spent on community detail page
                if let duration = timeTracker.endTracking(for: "community_detail_\(community.id ?? "")") {
                    AnalyticsService.shared.trackPageViewTime(
                        page: "community_detail_\(community.name)",
                        timeSpent: duration
                    )
                }
            }
            .sheet(isPresented: $showingTransactionHistory) {
                if let member = selectedMember {
                    TransactionHistoryView(
                        community: community,
                        member: member,
                        firestoreService: firestoreService
                    )
                }
            }
        }
    }
    
    private func loadMembers() {
        isLoading = true
        firestoreService.fetchCommunityMembers(communityId: community.id ?? "") { fetchedMembers in
            DispatchQueue.main.async {
                self.members = fetchedMembers
                self.isLoading = false
            }
        }
    }
    
    private func loadBalances() {
        guard let userEmail = firestoreService.currentUser?.email else { return }
        isLoading = true
        hasLoadedBalances = false
        
        // Load user's balance
        firestoreService.calculateNetBalance(
            communityId: community.id ?? "", 
            userEmail: userEmail
        ) { balance in
            DispatchQueue.main.async {
                self.userBalance = balance
                
                // Load member balances
                self.firestoreService.calculateMemberBalances(
                    communityId: self.community.id ?? ""
                ) { balances in
                    DispatchQueue.main.async {
                        self.memberBalances = balances
                        self.isLoading = false
                        self.hasLoadedBalances = true
                    }
                }
            }
        }
        
        // Load all member balances
        let memberEmails = members.map { $0.email }
        let group = DispatchGroup()
        
        for memberEmail in memberEmails {
            group.enter()
            firestoreService.calculateNetBalance(
                communityId: community.id ?? "", 
                userEmail: memberEmail
            ) { balance in
                DispatchQueue.main.async {
                    self.memberBalances[memberEmail] = balance
                }
                group.leave()
            }
        }
        
        // Mark as loaded when all balances are calculated
        group.notify(queue: .main) {
            self.hasLoadedBalances = true
        }
    }
    
    private func formatBalance(_ balance: Double) -> String {
        let prefix = balance >= 0 ? "+" : ""
        return "\(prefix)\(String(format: "%.2f", balance))"
    }
}

// MARK: - Member Balance Row

struct MemberBalanceRow: View {
    let member: CommunityMemberInfo
    let balance: String
    
    var body: some View {
        HStack(spacing: 12) {
            // Profile Picture
            Circle()
                .fill(Color.slingGradient)
                .frame(width: 32, height: 32)
                .overlay(
                    Text(String(member.name.prefix(1)).uppercased())
                        .font(.caption)
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                )
            
            VStack(alignment: .leading, spacing: 2) {
                Text(member.name)
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .foregroundColor(.black)
                
                Text(member.email)
                    .font(.caption)
                    .foregroundColor(.gray)
            }
            
            Spacer()
            
            HStack(spacing: 4) {
                Image(systemName: "bolt.fill")
                    .font(.caption)
                    .foregroundColor(.slingBlue)
                Text(balance)
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .foregroundColor(.black)
            }
            
            Image(systemName: "chevron.right")
                .font(.caption)
                .foregroundColor(.gray)
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .background(Color.white)
    }
}

// MARK: - Transaction History View

struct TransactionHistoryView: View {
    @Environment(\.dismiss) private var dismiss
    let community: FirestoreCommunity
    let member: CommunityMemberInfo
    let firestoreService: FirestoreService
    @State private var transactions: [TransactionItem] = []
    @State private var isLoading = false
    @State private var netBalance: Double = 0.0
    
    private func loadTransactionHistory() {
        isLoading = true
        guard let currentUserEmail = firestoreService.currentUser?.email else { return }
        
        firestoreService.fetchTransactions(communityId: community.id ?? "", userEmail: currentUserEmail) { fetchedTransactions in
            // For now, show all transactions for the current user in this community
            // In the future, this could be enhanced to show transactions between specific users
            let transformedTransactions = fetchedTransactions.map { transaction in
                TransactionItem(
                    type: transaction.final_payout != nil ? .settlement : .bet,
                    amount: transaction.final_payout != nil ? Double(transaction.final_payout!) : -Double(transaction.stake_amount),
                    description: "Bet on \(transaction.chosen_option)",
                    date: transaction.created_date,
                    betTitle: nil,
                    isWin: transaction.final_payout != nil && transaction.final_payout! > 0
                )
            }
            
            DispatchQueue.main.async {
                self.transactions = transformedTransactions
                self.netBalance = transformedTransactions.reduce(0.0) { $0 + $1.amount }
                self.isLoading = false
            }
        }
    }

    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                HStack {
                    Button(action: {
                        dismiss()
                    }) {
                        Image(systemName: "arrow.left")
                            .font(.title3)
                            .foregroundColor(.black)
                    }
                    
                    Spacer()
                    
                    Text("Transaction History")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    // Placeholder for balance
                    Text("")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                }
                .padding(.horizontal, 16)
                .padding(.top, 16)
                
                // Member Info
                VStack(spacing: 8) {
                    HStack(spacing: 12) {
                        Circle()
                            .fill(Color.slingGradient)
                            .frame(width: 40, height: 40)
                            .overlay(
                                Text(String(member.name.prefix(1)).uppercased())
                                    .font(.subheadline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.white)
                            )
                        
                        VStack(alignment: .leading, spacing: 2) {
                            Text(member.name)
                                .font(.headline)
                                .fontWeight(.semibold)
                                .foregroundColor(.black)
                            Text(member.email)
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }
                        
                        Spacer()
                    }
                    .padding(.horizontal, 16)
                    
                    // Net Balance
                    HStack(spacing: 4) {
                        Image(systemName: "bolt.fill")
                            .font(.caption)
                            .foregroundColor(.slingBlue)
                        Text("Net Balance: \(formatBalance(netBalance))")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(netBalance >= 0 ? .black : .red)
                    }
                    .padding(.horizontal, 16)
                }
                .padding(.vertical, 16)
                .background(Color.white)
                
                // Transactions List
                if isLoading {
                    Spacer()
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle())
                        .scaleEffect(1.5)
                    Spacer()
                } else if transactions.isEmpty {
                    Spacer()
                    VStack(spacing: 12) {
                        Image(systemName: "doc.text")
                            .font(.system(size: 48))
                            .foregroundColor(Color.slingBlue.opacity(0.6))
                        
                        Text("No transactions yet")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                        
                        Text("Bets and settlements will appear here")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                    }
                    .padding(.horizontal, 16)
                    Spacer()
                } else {
                    ScrollView {
                        LazyVStack(spacing: 0) {
                            ForEach(transactions) { transaction in
                                TransactionRow(transaction: transaction)
                                
                                if transaction.id != transactions.last?.id {
                                    Divider()
                                        .padding(.leading, 16)
                                }
                            }
                        }
                        .background(Color.white)
                        .cornerRadius(12)
                        .padding(.horizontal, 16)
                        .padding(.top, 16)
                    }
                }
            }
            .background(Color.white)
            .navigationBarHidden(true)
            .onAppear {
                loadTransactionHistory()
            }
        }
    }

    
    private func transactionTypeFromString(_ type: String) -> TransactionType {
        switch type.lowercased() {
        case "bet":
            return .bet
        case "settlement":
            return .settlement
        case "refund":
            return .refund
        default:
            return .bet
        }
    }
    
    private func formatBalance(_ balance: Double) -> String {
        let prefix = balance >= 0 ? "+" : ""
        return "\(prefix)\(String(format: "%.2f", balance))"
    }
}

// MARK: - Transaction Item

struct TransactionItem: Identifiable {
    let id = UUID()
    let type: TransactionType
    let amount: Double
    let description: String
    let date: Date
    let betTitle: String?
    let isWin: Bool?
}

enum TransactionType {
    case bet
    case settlement
    case refund
}

// MARK: - Transaction Row

struct TransactionRow: View {
    let transaction: TransactionItem
    
    var body: some View {
        HStack(spacing: 12) {
            // Transaction Icon
            Circle()
                .fill(transactionTypeColor.opacity(0.2))
                .frame(width: 32, height: 32)
                .overlay(
                    Image(systemName: transactionTypeIcon)
                        .font(.caption)
                        .foregroundColor(transactionTypeColor)
                )
            
            VStack(alignment: .leading, spacing: 4) {
                Text(transaction.description)
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .foregroundColor(.black)
                
                if let betTitle = transaction.betTitle {
                    Text(betTitle)
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                
                Text(formatTransactionDate(transaction.date))
                    .font(.caption)
                    .foregroundColor(.gray)
            }
            
            Spacer()
            
            VStack(alignment: .trailing, spacing: 2) {
                HStack(spacing: 4) {
                    Image(systemName: "bolt.fill")
                        .font(.caption)
                        .foregroundColor(.slingBlue)
                    Text(formatAmount(transaction.amount))
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(transactionAmountColor)
                }
                
                if let isWin = transaction.isWin {
                    Text(isWin ? "Won" : "Lost")
                        .font(.caption)
                        .foregroundColor(isWin ? .green : .red)
                }
            }
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .background(Color.white)
    }
    
    private var transactionTypeColor: Color {
        switch transaction.type {
        case .bet:
            return .slingBlue
        case .settlement:
            return .green
        case .refund:
            return .orange
        }
    }
    
    private var transactionTypeIcon: String {
        switch transaction.type {
        case .bet:
            return "target"
        case .settlement:
            return "checkmark.circle"
        case .refund:
            return "arrow.clockwise"
        }
    }
    
    private var transactionAmountColor: Color {
        if transaction.amount > 0 {
            return .green
        } else if transaction.amount < 0 {
            return .red
        } else {
            return .black
        }
    }
    
    private func formatAmount(_ amount: Double) -> String {
        let prefix = amount > 0 ? "+" : ""
        return "\(prefix)\(String(format: "%.2f", amount))"
    }
    
    private func formatTransactionDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .short
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }
}

// MARK: - Stat Card

struct StatCard: View {
    let icon: String
    let iconColor: Color
    let value: String
    let label: String
    
    var body: some View {
        VStack(spacing: 12) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundColor(iconColor)
            
            VStack(spacing: 4) {
                Text(value)
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.black)
                
                Text(label)
                    .font(.caption)
                    .foregroundColor(.gray)
            }
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 20)
        .background(Color.white)
        .cornerRadius(12)
        .shadow(color: .black.opacity(0.05), radius: 4, x: 0, y: 2)
    }
}



// MARK: - Notifications View

// MARK: - Notification Filter Enum

enum NotificationFilter: String, CaseIterable {
    case all = "All"
    case unread = "Unread"
}

struct NotificationsView: View {
    @Environment(\.dismiss) private var dismiss
    let firestoreService: FirestoreService
    @State private var isLoadingNotifications = false
    @State private var selectedFilter: NotificationFilter = .all
    @StateObject private var timeTracker = TimeTracker()
    
    // Computed property to filter notifications based on selected filter
    private var filteredNotifications: [FirestoreNotification] {
        switch selectedFilter {
        case .all:
            return firestoreService.notifications
        case .unread:
            return firestoreService.notifications.filter { !$0.is_read }
        }
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Enhanced Header with better styling
                VStack(spacing: 16) {
                    // Navigation Bar
                    HStack {
                        Button(action: {
                            AnalyticsService.shared.trackFeatureUsage(feature: "notifications_close", context: "notifications_page")
                            dismiss()
                        }) {
                            Image(systemName: "xmark")
                                .font(.title2)
                                .fontWeight(.medium)
                                .foregroundColor(.black)
                                .frame(width: 44, height: 44)
                        }
                        
                        Spacer()
                        
                        VStack(spacing: 2) {
                            Text("Notifications")
                                .font(.headline)
                                .fontWeight(.bold)
                                .foregroundColor(.black)
                            
                            // Show unread count
                            let unreadCount = firestoreService.notifications.filter { !$0.is_read }.count
                            if unreadCount > 0 {
                                Text("\(unreadCount) unread")
                                    .font(.caption2)
                                    .foregroundColor(.secondary)
                            }
                        }
                        
                        Spacer()
                        
                        // Filter button
                        Menu {
                            ForEach(NotificationFilter.allCases, id: \.self) { filter in
                                Button(filter.rawValue) {
                                    AnalyticsService.shared.trackNotificationFilter(filter: filter.rawValue)
                                    selectedFilter = filter
                                }
                            }
                        } label: {
                            ZStack {
                                Image(systemName: "line.3.horizontal.decrease.circle")
                                    .font(.title2)
                                    .foregroundColor(.black)
                                
                                // Small indicator for current filter
                                if selectedFilter == .unread {
                                    Circle()
                                        .fill(Color.blue)
                                        .frame(width: 8, height: 8)
                                        .offset(x: 8, y: -8)
                                }
                            }
                            .frame(width: 44, height: 44)
                        }
                    }
                    

                    

                }
                .padding(.horizontal, 20)
                .padding(.top, 16)
                .padding(.bottom, 20)
                .background(Color.white)
                
                // Enhanced Notifications List
                if filteredNotifications.isEmpty {
                    // Empty State or Loading State
                    VStack(spacing: 20) {
                        Spacer()
                        
                        if isLoadingNotifications {
                            // Loading State
                            ProgressView()
                                .scaleEffect(1.2)
                                .progressViewStyle(CircularProgressViewStyle(tint: .slingBlue))
                            
                            Text("Loading notifications...")
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                                .padding(.top, 8)
                        } else {
                            // Empty State
                            Image(systemName: "bell.slash")
                                .font(.system(size: 60))
                                .foregroundColor(.gray.opacity(0.5))
                            
                            VStack(spacing: 8) {
                                Text(selectedFilter == .all ? "No notifications yet" : "No unread notifications")
                                    .font(.title2)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.primary)
                                
                                Text(selectedFilter == .all ? "When you receive notifications, they'll appear here" : "All notifications have been read")
                                    .font(.subheadline)
                                    .foregroundColor(.secondary)
                                    .multilineTextAlignment(.center)
                            }
                        }
                        
                        Spacer()
                    }
                    .padding(.horizontal, 40)
                } else {
                    ScrollView {
                        LazyVStack(spacing: 1) {
                            ForEach(filteredNotifications) { notification in
                                EnhancedNotificationRow(
                                    notification: convertToNotificationItem(notification),
                                    firestoreService: firestoreService
                                )
                                .transition(.opacity.combined(with: .move(edge: .leading)))
                            }
                        }
                        .padding(.top, 8)
                        .animation(.easeInOut(duration: 0.3), value: filteredNotifications.count)
                    }

                }
            }
            .background(Color.white)
            .navigationBarHidden(true)

            .onAppear {
                // Track notifications page view
                AnalyticsService.shared.trackUserFlowStep(step: .notifications)
                AnalyticsService.shared.trackFeatureUsage(feature: "notifications_page", context: "main_app")
                timeTracker.startTracking(for: "notifications_page")
                
                print("🔍 NotificationsView: onAppear triggered")
                print("🔍 NotificationsView: Current user email: \(firestoreService.currentUser?.email ?? "nil")")
                print("🔍 NotificationsView: Current notifications count: \(firestoreService.notifications.count)")
                
                // Fetch notifications if none exist
                if firestoreService.notifications.isEmpty {
                    isLoadingNotifications = true
                    firestoreService.fetchNotifications()
                }
                
                // Don't mark notifications as read when opening - only when closing
            }
            .onDisappear {
                // Track time spent on notifications page
                if let duration = timeTracker.endTracking(for: "notifications_page") {
                    AnalyticsService.shared.trackPageViewTime(page: "notifications_page", timeSpent: duration)
                }
                
                print("🔍 NotificationsView: onDisappear triggered - marking notifications as read")
                // Mark all unread notifications as read when the notification page is closed
                markAllUnreadNotificationsAsRead()
            }
            .onReceive(firestoreService.$notifications) { notifications in
                print("🔍 NotificationsView: Notifications updated, count: \(notifications.count)")
                // Notifications will only be marked as read when the user closes the page
                isLoadingNotifications = false
            }
        }
    }
    
    // MARK: - Helper Methods
    
    private func markAllUnreadNotificationsAsRead() {
        let unreadNotifications = firestoreService.notifications.filter { !$0.is_read }
        print("🔍 NotificationsView: Marking \(unreadNotifications.count) unread notifications as read")
        
        // Track mark all read action
        if unreadNotifications.count > 0 {
            AnalyticsService.shared.trackNotificationMarkAllRead(count: unreadNotifications.count)
        }
        
        for notification in unreadNotifications {
            if let notificationId = notification.id {
                firestoreService.markNotificationAsRead(notificationId: notificationId) { success in
                    if success {
                        print("✅ NotificationsView: Marked notification as read: \(notificationId)")
                    } else {
                        print("❌ NotificationsView: Failed to mark notification as read: \(notificationId)")
                    }
                }
            }
        }
    }
}

// MARK: - Filter Button Component

struct FilterButton: View {
    let title: String
    let isSelected: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(title)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(isSelected ? .white : .black)
                .padding(.horizontal, 12)
                .padding(.vertical, 8)
                .background(
                    isSelected ? 
                    AnyShapeStyle(Color.slingGradient) : 
                    AnyShapeStyle(Color.white)
                )
                .cornerRadius(20)
                .frame(height: 32)
                .overlay(
                    RoundedRectangle(cornerRadius: 20)
                        .stroke(Color.gray.opacity(0.3), lineWidth: isSelected ? 0 : 1)
                )
        }
    }
}

// MARK: - Enhanced Notification Row

struct EnhancedNotificationRow: View {
    let notification: NotificationItem
    let firestoreService: FirestoreService
    
    var body: some View {
        Button(action: {
            // Track notification tap
            AnalyticsService.shared.trackNotificationInteraction(
                action: .tap,
                notificationId: notification.id ?? "unknown",
                notificationType: notification.icon
            )
            // This button can be used for future navigation or actions
            // Notifications will be marked as read when the user closes the notifications page
        }) {
            HStack(spacing: 16) {
                // Enhanced Icon with better styling
                ZStack {
                    Circle()
                        .fill(notificationIconBackgroundColor)
                        .frame(width: 48, height: 48)
                    
                    Image(systemName: notification.icon)
                        .font(.system(size: 18, weight: .medium))
                        .foregroundColor(notificationIconForegroundColor)
                }
                
                // Enhanced Content
                VStack(alignment: .leading, spacing: 6) {
                     NotificationTextView(
                         text: notification.text,
                         isUnread: notification.isUnread
                     )
                    
                    HStack(spacing: 8) {
                        if let communityName = notification.communityName {
                            // Community icon (default to person.2 if no specific icon)
                            Image(systemName: notification.communityIcon ?? "person.2")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        
                            Text(communityName)
                                .font(.caption)
                                .foregroundColor(.secondary)
                            
                            Text("•")
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            
                        Text(notification.timestamp)
                                .font(.caption)
                                .foregroundColor(.secondary)
                    }
                }
                
                Spacer()
                

            }
            .padding(.horizontal, 20)
            .padding(.vertical, 16)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(Color.white)
                    .shadow(color: Color.black.opacity(0.05), radius: 2, x: 0, y: 1)
            )


        }
        .buttonStyle(PlainButtonStyle())
        .padding(.horizontal, 20)
        .padding(.vertical, 4)
        .onAppear {
            // Track notification view
            AnalyticsService.shared.trackNotificationInteraction(
                action: .view,
                notificationId: notification.id ?? "unknown",
                notificationType: notification.icon
            )
            
            // Don't automatically mark notifications as read when they appear on screen
            // They will only be marked as read when the user closes the notifications page
        }
    }
    
    private var notificationIconBackgroundColor: Color {
        if notification.icon == "bolt.fill" {
            return Color.slingBlue.opacity(0.15)
        } else {
            return notification.iconColor.opacity(0.15)
        }
    }
    
    private var notificationIconForegroundColor: Color {
        notification.icon == "bolt.fill" ? .slingBlue : notification.iconColor
    }
}

// MARK: - Notification Item

struct NotificationItem {
    let id: String?
    let icon: String
    let iconColor: Color
    let text: String
    let timestamp: String
    let isUnread: Bool
    let communityName: String?
    let communityIcon: String?
}

// MARK: - Edit Profile View

struct EditProfileView: View {
    @Environment(\.dismiss) private var dismiss
    @ObservedObject var firestoreService: FirestoreService
    @State private var displayName: String
    @State private var firstName: String
    @State private var lastName: String
    @State private var isLoading = false
    @State private var showingSaveSuccess = false
    @State private var showingUnsavedChangesAlert = false
    @State private var showingImagePicker = false
    @State private var showingPhotoOptions = false
    @State private var showingPhotoPicker = false
    @State private var showingCamera = false
    @State private var selectedItem: PhotosPickerItem? = nil
    @State private var selectedImage: UIImage?
    @State private var profileImageUrl: String?
    @StateObject private var timeTracker = TimeTracker()
    @State private var originalDisplayName: String
    @State private var originalFirstName: String
    @State private var originalLastName: String
    
    init(firestoreService: FirestoreService) {
        self.firestoreService = firestoreService
        self._displayName = State(initialValue: firestoreService.currentUser?.display_name ?? "")
        self._firstName = State(initialValue: firestoreService.currentUser?.first_name ?? "")
        self._lastName = State(initialValue: firestoreService.currentUser?.last_name ?? "")
        self._profileImageUrl = State(initialValue: firestoreService.currentUser?.profile_picture_url)
        self._originalDisplayName = State(initialValue: firestoreService.currentUser?.display_name ?? "")
        self._originalFirstName = State(initialValue: firestoreService.currentUser?.first_name ?? "")
        self._originalLastName = State(initialValue: firestoreService.currentUser?.last_name ?? "")
    }
    
    var body: some View {
        NavigationView {
            ZStack {
                // Clean white background
                Color.white.ignoresSafeArea()
                
                VStack(spacing: 0) {
                    // Header
                    HStack {
                        Button(action: { 
                            if hasUnsavedChanges() {
                                AnalyticsService.shared.trackProfileEditAction(action: .unsavedChanges)
                                showingUnsavedChangesAlert = true
                            } else {
                                AnalyticsService.shared.trackProfileEditAction(action: .close)
                                dismiss()
                            }
                        }) {
                            Image(systemName: "arrow.left")
                                .font(.title2)
                                .foregroundColor(.black)
                                .frame(width: 44, height: 44)
                        }
                        
                        Spacer()
                        
                        Text("Edit Profile")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                        
                        Spacer()
                        
                        Button(action: {
                            AnalyticsService.shared.trackProfileEditAction(action: .save)
                            saveChanges()
                        }) {
                            Text("Save")
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.slingBlue)
                        }
                        .disabled(isLoading)
                    }
                    .padding(.horizontal, 20)
                    .padding(.top, 20)
                    
                    // Content
                    VStack(spacing: 32) {
                        // Profile Picture Section
                        VStack(spacing: 16) {
                            Text("Profile Picture")
                                .font(.headline)
                                .fontWeight(.semibold)
                            .foregroundColor(.black)
                                .frame(maxWidth: .infinity, alignment: .leading)
                            .padding(.horizontal, 20)
                        
                            // Profile Picture Display and Edit Button
                            Button(action: {
                                AnalyticsService.shared.trackProfileEditAction(action: .imageSelect)
                                showingPhotoOptions = true
                            }) {
                                ZStack {
                                    if let selectedImage = selectedImage {
                                        // Show selected image
                                        Image(uiImage: selectedImage)
                                            .resizable()
                                            .aspectRatio(contentMode: .fill)
                                            .frame(width: 120, height: 120)
                                            .clipShape(Circle())
                                            .overlay(
                                                Circle()
                                                    .stroke(Color.slingBlue, lineWidth: 3)
                                            )
                                    } else if let profileImageUrl = profileImageUrl {
                                        // Show current profile image
                                        AsyncImage(url: URL(string: profileImageUrl)) { image in
                                            image
                                                .resizable()
                                                .aspectRatio(contentMode: .fill)
                                        } placeholder: {
                                            Circle()
                                                .fill(Color.slingGradient)
                                                .overlay(
                                                    ProgressView()
                                                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                                        .scaleEffect(0.8)
                                                )
                                        }
                                        .frame(width: 120, height: 120)
                                        .clipShape(Circle())
                                        .overlay(
                                            Circle()
                                                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                        )
                                    } else {
                                        // Show initials fallback
                                        Circle()
                                            .fill(Color.slingGradient)
                                            .frame(width: 120, height: 120)
                                            .overlay(
                                                Text(getUserInitials())
                                                    .font(.largeTitle)
                                                    .fontWeight(.semibold)
                                                    .foregroundColor(.white)
                                            )
                                            .overlay(
                                                Circle()
                                                    .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                            )
                                    }
                                    
                                    // Swap icon overlay at 3-6 o'clock position
                                    Circle()
                                        .fill(Color.slingBlue)
                                        .frame(width: 36, height: 36)
                                        .overlay(
                                            Image(systemName: "arrow.2.squarepath")
                                                .font(.system(size: 16, weight: .medium))
                                                .foregroundColor(.white)
                                        )
                                        .overlay(
                                            Circle()
                                                .stroke(Color.white, lineWidth: 2)
                                        )
                                        .offset(x: 42, y: 42) // Position at 3-6 o'clock (half on, half off)
                                }
                            }
                            
                            Text("Tap to change your profile picture")
                                .font(.caption)
                            .foregroundColor(.gray)
                        }
                        
                        // User details input fields
                        VStack(alignment: .leading, spacing: 16) {
                            // Email field
                            VStack(alignment: .leading, spacing: 8) {
                                Text("Email")
                                    .font(.headline)
                                    .foregroundColor(.black)
                                
                                Text(firestoreService.currentUser?.email ?? "")
                                    .font(.body)
                                    .foregroundColor(.gray)
                                    .padding(.horizontal, 20)
                                    .padding(.vertical, 16)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .background(Color.gray.opacity(0.1))
                                    .cornerRadius(12)
                            }
                            
                            // First and Last name on same row
                            HStack(spacing: 16) {
                                VStack(alignment: .leading, spacing: 8) {
                                    Text("First Name")
                                        .font(.headline)
                                        .foregroundColor(.black)
                                    
                                    TextField("First", text: $firstName)
                                        .textFieldStyle(ModernTextFieldStyle())
                                        .onChange(of: firstName) { newValue in
                                            if newValue != originalFirstName {
                                                AnalyticsService.shared.trackProfileFieldEdit(field: "first_name", oldValue: originalFirstName, newValue: newValue)
                                            }
                                        }
                                }
                                
                                VStack(alignment: .leading, spacing: 8) {
                                    Text("Last Name")
                                        .font(.headline)
                                        .foregroundColor(.black)
                                    
                                    TextField("Last", text: $lastName)
                                        .textFieldStyle(ModernTextFieldStyle())
                                        .onChange(of: lastName) { newValue in
                                            if newValue != originalLastName {
                                                AnalyticsService.shared.trackProfileFieldEdit(field: "last_name", oldValue: originalLastName, newValue: newValue)
                                            }
                                        }
                                }
                            }
                            
                            VStack(alignment: .leading, spacing: 8) {
                                Text("Display Name")
                                    .font(.headline)
                                    .foregroundColor(.black)
                                
                                HStack(spacing: 0) {
                                    Text("@")
                                        .font(.title2)
                                        .foregroundColor(.gray)
                                        .padding(.leading, 16)
                                    
                                    TextField("username", text: $displayName)
                                        .textFieldStyle(PlainTextFieldStyle())
                                        .font(.body)
                                        .foregroundColor(.black)
                                        .padding(.leading, 8)
                                        .padding(.trailing, 16)
                                        .onChange(of: displayName) { newValue in
                                            // Remove spaces from display name
                                            let formattedName = newValue.replacingOccurrences(of: " ", with: "")
                                            if formattedName != newValue {
                                                displayName = formattedName
                                            }
                                            
                                            // Track field edit
                                            if formattedName != originalDisplayName {
                                                AnalyticsService.shared.trackProfileFieldEdit(field: "display_name", oldValue: originalDisplayName, newValue: formattedName)
                                            }
                                        }
                                }
                                .padding(.horizontal, 16)
                                .padding(.vertical, 12)
                                .background(Color.white)
                                .overlay(
                                    RoundedRectangle(cornerRadius: 10)
                                        .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                )
                                .cornerRadius(10)
                            }
                            
                            Text("This is how other users will see you")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        .padding(.horizontal, 24)
                        
                        Spacer()
                    }
                    .padding(.top, 40)
                }
            }
            .navigationBarHidden(true)
            .alert("Profile Updated", isPresented: $showingSaveSuccess) {
                Button("OK") { dismiss() }
            } message: {
                Text("Your profile has been successfully updated.")
            }
            .alert("Unsaved Changes", isPresented: $showingUnsavedChangesAlert) {
                Button("Leave", role: .destructive) { dismiss() }
                Button("Stay", role: .cancel) { }
            } message: {
                Text("You have unsaved changes. Are you sure you want to leave?")
            }
            .confirmationDialog("Choose Profile Picture", isPresented: $showingPhotoOptions, titleVisibility: .visible) {
                Button("Choose from Photos") {
                    AnalyticsService.shared.trackProfileImageUpload(method: "photo_library", success: true)
                    showingPhotoPicker = true
                }
                
                Button("Take Photo") {
                    AnalyticsService.shared.trackProfileImageUpload(method: "camera", success: true)
                    showingCamera = true
                }
                
                Button("Cancel", role: .cancel) { 
                    AnalyticsService.shared.trackProfileEditAction(action: .cancel)
                }
            }
            .photosPicker(isPresented: $showingPhotoPicker, selection: $selectedItem, matching: .images, photoLibrary: .shared())
            .sheet(isPresented: $showingCamera) {
                CameraView(
                    onImageCaptured: { image in
                    selectedImage = image
                    showingCamera = false
                    },
                    onError: { error in
                        print("Camera error: \(error)")
                    showingCamera = false
                }
                )
            }
            .onChange(of: selectedItem) { _ in
                loadPhotoFromPicker()
            }
            .onAppear {
                // Track profile edit page view
                AnalyticsService.shared.trackProfileEditAction(action: .open)
                AnalyticsService.shared.trackUserFlowStep(step: .profileEdit)
                timeTracker.startTracking(for: "profile_edit")
            }
            .onDisappear {
                // Track time spent on profile edit
                if let duration = timeTracker.endTracking(for: "profile_edit") {
                    AnalyticsService.shared.trackPageViewTime(page: "profile_edit", timeSpent: duration)
                }
            }
        }
    }
    
    private func getUserInitials() -> String {
        let user = firestoreService.currentUser
        if let firstName = user?.first_name, let lastName = user?.last_name, !firstName.isEmpty, !lastName.isEmpty {
            let firstInitial = String(firstName.prefix(1)).uppercased()
            let lastInitial = String(lastName.prefix(1)).uppercased()
            return "\(firstInitial)\(lastInitial)"
        } else if let displayName = user?.display_name, !displayName.isEmpty {
            let components = displayName.components(separatedBy: " ")
            if components.count >= 2 {
                let firstInitial = String(components[0].prefix(1)).uppercased()
                let lastInitial = String(components[1].prefix(1)).uppercased()
                return "\(firstInitial)\(lastInitial)"
            } else if components.count == 1 {
                return String(components[0].prefix(1)).uppercased()
            }
        } else if let email = user?.email {
            return String(email.prefix(1)).uppercased()
        }
        return "U"
    }
    
    private func loadPhotoFromPicker() {
        guard let selectedItem = selectedItem else { return }
        
        Task {
            do {
                if let data = try await selectedItem.loadTransferable(type: Data.self),
                   let image = UIImage(data: data) {
                    await MainActor.run {
                        self.selectedImage = image
                    }
                }
            } catch {
                print("❌ Error loading photo: \(error)")
            }
        }
    }
    
    private func hasUnsavedChanges() -> Bool {
        let originalDisplayName = firestoreService.currentUser?.display_name ?? ""
        let originalFirstName = firestoreService.currentUser?.first_name ?? ""
        let originalLastName = firestoreService.currentUser?.last_name ?? ""
        
        return displayName != originalDisplayName || 
               firstName != originalFirstName || 
               lastName != originalLastName ||
               selectedImage != nil
    }
    
    private func saveChanges() {
        // Prevent multiple simultaneous save operations
        guard !isLoading else {
            print("⚠️ Save operation already in progress")
            return
        }
        
        isLoading = true
        
        // Validate input
        guard !displayName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            AnalyticsService.shared.trackProfileEditAction(action: .validationError, field: "display_name")
            isLoading = false
            return
        }
        
        print("💾 Starting profile save process...")
        
        // Track fields that changed
        var fieldsChanged: [String] = []
        if displayName != originalDisplayName { fieldsChanged.append("display_name") }
        if firstName != originalFirstName { fieldsChanged.append("first_name") }
        if lastName != originalLastName { fieldsChanged.append("last_name") }
        if selectedImage != nil { fieldsChanged.append("profile_image") }
        
        // If there's a new profile image, upload it first
        if let selectedImage = selectedImage {
            print("📷 Uploading new profile image...")
            firestoreService.uploadUserProfileImage(selectedImage) { success, error in
                DispatchQueue.main.async {
                    
                    if success {
                        print("✅ Profile image uploaded successfully")
                        AnalyticsService.shared.trackProfileImageUpload(method: "upload", success: true)
                        // Clear the selected image and update local URL
                        self.selectedImage = nil
                        self.profileImageUrl = self.firestoreService.currentUser?.profile_picture_url
                        
                        // Force UI refresh by updating the published property
                        print("🔄 Refreshing UI with new profile picture URL: \(self.firestoreService.currentUser?.profile_picture_url ?? "nil")")
                        
                        // Force UI refresh by triggering objectWillChange
                        self.firestoreService.objectWillChange.send()
                        
                        // Now update the text fields
                        self.updateTextFields(fieldsChanged: fieldsChanged)
                    } else {
                        print("❌ Failed to upload profile image: \(error ?? "Unknown error")")
                        AnalyticsService.shared.trackProfileImageUpload(method: "upload", success: false, error: error ?? "Unknown error")
                        self.isLoading = false
                        // Show error feedback to user
                        // You could add an error state here
                    }
                }
            }
        } else {
            // No new image, just update text fields
            print("📝 No new image, updating text fields only...")
            updateTextFields(fieldsChanged: fieldsChanged)
        }
    }
    
    private func updateTextFields(fieldsChanged: [String]) {
        // Update user profile text fields in Firestore
        let trimmedFirstName = firstName.trimmingCharacters(in: .whitespacesAndNewlines)
        let trimmedLastName = lastName.trimmingCharacters(in: .whitespacesAndNewlines)
        let fullName = "\(trimmedFirstName) \(trimmedLastName)".trimmingCharacters(in: .whitespacesAndNewlines)
        
        let updateData: [String: Any] = [
            "display_name": displayName.trimmingCharacters(in: .whitespacesAndNewlines),
            "first_name": trimmedFirstName,
            "last_name": trimmedLastName,
            "full_name": fullName,
            "updated_date": Date()
        ]
        
        firestoreService.updateUserSettings(settings: updateData) { success in
            DispatchQueue.main.async {
                self.isLoading = false
                if success {
                    print("✅ Profile updated successfully")
                    AnalyticsService.shared.trackProfileSave(success: true, fieldsChanged: fieldsChanged)
                    self.showingSaveSuccess = true
                } else {
                    print("❌ Failed to update profile")
                    AnalyticsService.shared.trackProfileSave(success: false, fieldsChanged: fieldsChanged, error: "Update failed")
                    // You could show an error alert here
                }
            }
        }
    }
}



// MARK: - Create Bet View

struct CreateBetView: View {
    @Environment(\.dismiss) private var dismiss
    @ObservedObject var firestoreService: FirestoreService
    let preSelectedCommunity: String? // New parameter for pre-selecting community
    @State private var currentStep = 1
    @State private var selectedMarketType = "Yes/No"
    @State private var marketQuestion = ""
    @State private var selectedCommunity = ""
    @State private var outcomes: [String] = ["Yes", "No"]
    @State private var odds: [String] = ["-110", "-110"]
    @State private var percentages: [String] = ["52.4%", "52.4%"]
    @State private var spreadLine = ""
    @State private var overUnderLine = ""
    @State private var bettingCloseDate = Date().addingTimeInterval(72 * 60 * 60) // 72 hours from now
    @State private var showingDatePicker = false
    @State private var showingAdjustOdds = false
    @State private var selectedOutcomeIndex = 0
    @State private var newOptionText = ""
    
    // Mention system state
    @State private var showingMentions = false
    @State private var mentionSearchText = ""
    @State private var mentionedUsers: [String] = []
    @State private var currentMentionPosition: Int = 0
    @State private var allCommunityMembers: [CommunityMemberInfo] = []
    @State private var userFullNames: [String: String] = [:] // Cache for user full names
    @State private var userDisplayNames: [String: String] = [:] // Cache for user display names
    
    let marketTypes = [
        ("Yes/No", "target", "Binary outcome", "Perfect for simple predictions"),
        ("Multiple Choice", "chart.bar", "Several options", "Great for complex scenarios"),
        ("Spread", "number", "Point handicap", "Ideal for sports betting"),
        ("Over/Under", "arrow.up.arrow.down", "Above or below", "Perfect for numerical predictions"),
        ("Prop Bet", "person.2", "Custom wager", "Create unique betting opportunities")
    ]
    
        var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header with Progress
                VStack(spacing: 16) {
                    // Top Navigation
                    HStack {
                        Button(action: {
                            if currentStep > 1 {
                                currentStep -= 1
                            } else {
                                dismiss()
                            }
                        }) {
                            Image(systemName: currentStep > 1 ? "chevron.left" : "xmark")
                                .font(.title3)
                                .foregroundColor(.black)
                                .frame(width: 40, height: 40)
                                .background(Color(.systemGray5))
                                .clipShape(Circle())
                        }
                        
                        Spacer()
                        
                        // Progress Indicator
                        HStack(spacing: 8) {
                            Text("\(min(currentStep, 3)) of 3")
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.slingBlue)
                            
                            Circle()
                                .fill(Color.gray.opacity(0.3))
                                .frame(width: 4, height: 4)
                            
                            Text(getStepTitle())
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }
                        
                        Spacer()
                        
                        // Progress Bar
                        HStack(spacing: 2) {
                            ForEach(1...3, id: \.self) { step in
                                Rectangle()
                                    .fill(step <= min(currentStep, 3) ? Color.slingBlue : Color.gray.opacity(0.3))
                                    .frame(width: 20, height: 4)
                                    .cornerRadius(2)
                            }
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.top, 16)
                }
                
                // Content Area
                ScrollView {
                    VStack(spacing: 32) {
                                        switch currentStep {
                case 1:
                    marketTypeStep
                case 2:
                    betDetailsStep
                case 3:
                    outcomesStep
                case 4:
                    reviewStep
                default:
                    EmptyView()
                }
                    }
                    .padding(.horizontal, 16)
                    .padding(.top, 32)
                    .padding(.bottom, 100)
                }
                
                // Continue Button
                VStack(spacing: 0) {
                    Button(action: {
                        if currentStep < 4 {
                            currentStep += 1
                        } else {
                            createBet()
                        }
                    }) {
                        HStack {
                            if currentStep == 4 {
                                Image(systemName: "checkmark")
                                    .font(.subheadline)
                            }
                            
                            Text(getContinueButtonText())
                                .fontWeight(.semibold)
                            
                            if currentStep < 4 {
                                Image(systemName: "arrow.right")
                                    .font(.subheadline)
                            }
                        }
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 16)
                        .background(canContinueToNextStep() ? Color.slingBlue : Color.gray)
                        .cornerRadius(12)
                    }
                    .disabled(!canContinueToNextStep())
                    .padding(.horizontal, 16)
                    .padding(.bottom, 32)
                }
                .background(Color.white)
            }
            .background(Color.white)
            .navigationBarHidden(true)
            .sheet(isPresented: $showingDatePicker) {
                DatePickerView(selectedDate: $bettingCloseDate, isPresented: $showingDatePicker)
            }
            .sheet(isPresented: $showingAdjustOdds) {
                AdjustOddsView(
                    odds: $odds,
                    percentages: $percentages,
                    isPresented: $showingAdjustOdds,
                    outcomes: outcomes
                )
            }
            .onAppear {
                firestoreService.fetchCommunities()
                
                // Set pre-selected community if provided
                if let preSelectedCommunity = preSelectedCommunity {
                    selectedCommunity = preSelectedCommunity
                }
                
                // Load community members for mention system
                loadAllCommunityMembers()
            }
        }
    }
    
    // MARK: - Step 1: Market Type
    private var marketTypeStep: some View {
        VStack(spacing: 24) {
            // Title
            VStack(spacing: 8) {
                Text("Market Type")
                    .font(.title3)
                    .fontWeight(.bold)
                    .foregroundColor(.black)
                
                Text("Choose your bet format")
                    .font(.subheadline)
                    .foregroundColor(.gray)
            }
            
            // Market Type Grid
            LazyVGrid(columns: [
                GridItem(.flexible()),
                GridItem(.flexible())
            ], spacing: 16) {
                ForEach(marketTypes, id: \.0) { type, icon, subtitle, description in
                    Button(action: {
                        selectedMarketType = type
                        updateOutcomesForMarketType()
                    }) {
                        VStack(spacing: 8) {
                            // Icon
                            ZStack {
                                Circle()
                                    .fill(selectedMarketType == type ? Color.slingBlue : Color.gray.opacity(0.2))
                                    .frame(width: 40, height: 40)
                                
                                Image(systemName: icon)
                                    .font(.title3)
                                    .foregroundColor(selectedMarketType == type ? .white : .slingBlue)
                            }
                            
                            // Title
                            Text(type)
                                .font(.subheadline)
                                .fontWeight(.semibold)
                                .foregroundColor(selectedMarketType == type ? .slingBlue : .black)
                            
                            // Description
                            VStack(spacing: 2) {
                                Text(subtitle)
                                    .font(.caption2)
                                    .foregroundColor(selectedMarketType == type ? .slingBlue : .gray)
                                
                                Text(description)
                                    .font(.caption2)
                                    .foregroundColor(selectedMarketType == type ? .slingBlue.opacity(0.8) : .gray.opacity(0.8))
                                    .multilineTextAlignment(.center)
                            }
                        }
                        .frame(maxWidth: .infinity, minHeight: 120)
                        .padding(.vertical, 16)
                        .padding(.horizontal, 12)
                        .background(selectedMarketType == type ? Color.slingBlue.opacity(0.1) : Color.white)
                        .cornerRadius(16)
                        .overlay(
                            RoundedRectangle(cornerRadius: 16)
                                .stroke(selectedMarketType == type ? Color.slingBlue : Color.gray.opacity(0.3), lineWidth: selectedMarketType == type ? 2 : 1)
                        )
                    }
                }
            }
        }
    }
    
    // MARK: - Step 2: Bet Details
    private var betDetailsStep: some View {
        VStack(spacing: 24) {
            // Title
            VStack(spacing: 8) {
                Text("Your Bet")
                    .font(.title3)
                    .fontWeight(.bold)
                    .foregroundColor(.black)
                
                Text("Set up your market details")
                    .font(.subheadline)
                    .foregroundColor(.gray)
            }
            
            // Market Question Card
            VStack(spacing: 16) {
                HStack(spacing: 12) {
                    Image(systemName: "questionmark.circle.fill")
                        .font(.title2)
                        .foregroundColor(.slingBlue)
                    
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Market Title")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                        
                        Text("Use @ to mention users (hides bet from them)")
                            .font(.caption)
                            .foregroundColor(.gray)
                    }
                    
                    Spacer()
                }
                
                VStack(spacing: 0) {
                    ColoredTextView(
                        text: $marketQuestion,
                        placeholder: "e.g., Who will win the championship?",
                        onTextChange: { oldValue, newValue in
                            handleMentionInput(oldValue: oldValue, newValue: newValue)
                        }
                    )
                    .frame(minHeight: 44, maxHeight: 120)
                    .padding(.vertical, 12)
                    .padding(.horizontal, 12)
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                    
                    // Mention suggestions list
                    if showingMentions {
                        mentionSuggestionsView
                    }
                }
                
                HStack {
                    Spacer()
                    Text("\(marketQuestion.count)/100")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
            }
            .padding(20)
            .background(Color.white)
            .cornerRadius(16)
            .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
            
            // Spread Line Section (only for Spread type)
            if selectedMarketType == "Spread" {
                VStack(spacing: 16) {
                    HStack(spacing: 12) {
                        Image(systemName: "number")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                        
                        VStack(alignment: .leading, spacing: 4) {
                            Text("Spread Line")
                                .font(.headline)
                                .fontWeight(.semibold)
                                .foregroundColor(.black)
                            
                            Text("Enter the point handicap")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        
                        Spacer()
                    }
                    
                    TextField("e.g., -3.5", text: $spreadLine)
                        .textFieldStyle(PlainTextFieldStyle())
                        .font(.subheadline)
                        .keyboardType(.decimalPad)
                        .padding(.vertical, 12)
                        .padding(.horizontal, 12)
                        .background(Color(.systemGray6))
                        .cornerRadius(12)
                        .onChange(of: spreadLine) { oldValue, newValue in
                            // Filter to only allow numbers, decimal points, and minus signs
                            let filtered = newValue.filter { "0123456789.-".contains($0) }
                            if filtered != newValue {
                                spreadLine = filtered
                            }
                            updateSpreadOutcomes()
                        }
                    
                    HStack(spacing: 8) {
                        Image(systemName: "info.circle.fill")
                            .font(.caption)
                            .foregroundColor(.slingBlue)
                        
                        Text("Negative favors Team A, positive favors Team B")
                            .font(.caption)
                            .foregroundColor(.gray)
                    }
                }
                .padding(20)
                .background(Color.white)
                .cornerRadius(16)
                .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
            }
            
            // Over/Under Line Section (only for Over/Under type)
            if selectedMarketType == "Over/Under" {
                VStack(spacing: 16) {
                    HStack(spacing: 12) {
                        Image(systemName: "arrow.up.arrow.down")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                        
                        VStack(alignment: .leading, spacing: 4) {
                            Text("Over/Under Line")
                                .font(.headline)
                                .fontWeight(.semibold)
                                .foregroundColor(.black)
                            
                            Text("Enter the threshold number")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        
                        Spacer()
                    }
                    
                    TextField("e.g., 27.5", text: $overUnderLine)
                        .textFieldStyle(PlainTextFieldStyle())
                        .font(.subheadline)
                        .keyboardType(.decimalPad)
                        .padding(.vertical, 12)
                        .padding(.horizontal, 12)
                        .background(Color(.systemGray6))
                        .cornerRadius(12)
                        .onChange(of: overUnderLine) { oldValue, newValue in
                            // Filter to only allow numbers, decimal points, and minus signs
                            let filtered = newValue.filter { "0123456789.-".contains($0) }
                            if filtered != newValue {
                                overUnderLine = filtered
                            }
                            updateOverUnderOutcomes()
                        }
                    
                    HStack(spacing: 8) {
                        Image(systemName: "info.circle.fill")
                            .font(.caption)
                            .foregroundColor(.slingBlue)
                        
                        Text("Bettors predict if the total will be above or below this number")
                            .font(.caption)
                            .foregroundColor(.gray)
                    }
                }
                .padding(20)
                .background(Color.white)
                .cornerRadius(16)
                .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
            }
            
            // Community Card
            VStack(spacing: 16) {
                HStack(spacing: 12) {
                    Image(systemName: "person.2.fill")
                        .font(.title2)
                        .foregroundColor(.slingBlue)
                    
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Community")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                        
                        Text("Where will people bet on this?")
                            .font(.caption)
                            .foregroundColor(.gray)
                    }
                    
                    Spacer()
                }
                
                Menu {
                    ForEach(firestoreService.userCommunities) { community in
                        Button(community.name) {
                            selectedCommunity = community.name
                        }
                    }
                } label: {
                    HStack {
                        ZStack {
                            Circle()
                                .fill(selectedCommunity.isEmpty ? Color.slingBlue : Color.green)
                                .frame(width: 20, height: 20)
                            
                            Image(systemName: selectedCommunity.isEmpty ? "plus" : "checkmark")
                                .font(.caption)
                                .foregroundColor(.white)
                        }
                        
                        Text(selectedCommunity.isEmpty ? "Select a community" : selectedCommunity)
                            .foregroundColor(selectedCommunity.isEmpty ? .gray : .black)
                        
                        Spacer()
                        
                        Image(systemName: "chevron.down")
                            .font(.caption)
                            .foregroundColor(.gray)
                    }
                    .padding(.vertical, 12)
                    .padding(.horizontal, 12)
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                }
            }
                        .padding(20)
            .background(Color.white)
            .cornerRadius(16)
            .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
        }
    }
    
    // MARK: - Step 3: Outcomes & Odds
    private var outcomesStep: some View {
        VStack(spacing: 24) {
            // Title
            VStack(spacing: 8) {
                Text("Outcomes & Odds")
                    .font(.title3)
                    .fontWeight(.bold)
                    .foregroundColor(.black)
                
                Text("Configure betting options and probabilities")
                    .font(.subheadline)
                    .foregroundColor(.gray)
            }
            
                        // Outcomes
            VStack(spacing: 16) {
                ForEach(Array(outcomes.enumerated()), id: \.offset) { index, outcome in
                    Button(action: {
                        showingAdjustOdds = true
                    }) {
                    VStack(spacing: 0) {
                        HStack(spacing: 16) {
                            // Option Number Badge - More prominent
                            ZStack {
                                Circle()
                                    .fill(Color.slingGradient)
                                    .frame(width: 36, height: 36)
                                
                                Text("\(index + 1)")
                                    .font(.subheadline)
                                    .fontWeight(.bold)
                                    .foregroundColor(.white)
                            }
                            
                            // Outcome Text - Expanded and better styled
                            VStack(alignment: .leading, spacing: 4) {
                            if selectedMarketType == "Yes/No" {
                                // Yes/No outcomes are not editable
                                    HStack(spacing: 8) {
                                    Text(outcome)
                                        .font(.headline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(.black)
                                    
                                    Image(systemName: "lock.fill")
                                        .font(.caption)
                                        .foregroundColor(.gray)
                                }
                            } else if selectedMarketType == "Spread" || selectedMarketType == "Over/Under" {
                                // Spread and Over/Under outcomes are not editable
                                    HStack(spacing: 8) {
                                    Text(outcome)
                                        .font(.headline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(.black)
                                    
                                    Image(systemName: "lock.fill")
                                        .font(.caption)
                                        .foregroundColor(.gray)
                                }
                            } else {
                                // Multiple Choice and Prop Bet outcomes are editable
                                    VStack(alignment: .leading, spacing: 4) {
                                        TextField("Enter outcome...", text: $outcomes[index])
                                        .textFieldStyle(PlainTextFieldStyle())
                                        .font(.headline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(.black)
                                    
                                        HStack(spacing: 4) {
                                    Image(systemName: "pencil.circle.fill")
                                                .font(.caption2)
                                        .foregroundColor(.slingBlue)
                                            
                                            Text("Tap to edit")
                                                .font(.caption2)
                                                .foregroundColor(.gray)
                                        }
                                    }
                                }
                            }
                            
                            Spacer()
                            
                            // Odds Section - Condensed
                            HStack(spacing: 8) {
                                VStack(spacing: 4) {
                                // Odds Input - More prominent
                                VStack(spacing: 2) {
                                    Text("Odds")
                                        .font(.caption2)
                                        .foregroundColor(.gray)
                                    
                                        Text(odds[index])
                                .font(.subheadline)
                                        .fontWeight(.medium)
                                .multilineTextAlignment(.center)
                                        .frame(width: 80)
                                            .padding(.vertical, 6)
                                        .padding(.horizontal, 12)
                                .background(Color(.systemGray6))
                                .cornerRadius(8)
                                    }
                                }
                            
                                // Arrow indicator
                                Image(systemName: "chevron.right")
                                .font(.caption)
                                    .foregroundColor(.gray)
                            }
                            
                            // Remove Button - More prominent for Multiple Choice and Prop Bet
                            if selectedMarketType == "Multiple Choice" || selectedMarketType == "Prop Bet" {
                                if outcomes.count > 2 {
                                    Button(action: {
                                        withAnimation(.easeInOut(duration: 0.2)) {
                                        outcomes.remove(at: index)
                                        odds.remove(at: index)
                                        percentages.remove(at: index)
                                        }
                                    }) {
                                        Image(systemName: "trash.circle.fill")
                                            .font(.title3)
                                            .foregroundColor(.red)
                                    }
                                } else {
                                    Image(systemName: "minus.circle")
                                        .font(.title3)
                                        .foregroundColor(.gray.opacity(0.5))
                                }
                            } else {
                                // Chevron removed - entire card is now clickable
                                EmptyView()
                            }
                        }
                        .padding(.vertical, 12)
                        .padding(.horizontal, 16)
                        .background(
                            RoundedRectangle(cornerRadius: 16)
                                .fill(Color.white)
                                .shadow(color: .black.opacity(0.08), radius: 8, x: 0, y: 4)
                        )
                        .overlay(
                            RoundedRectangle(cornerRadius: 16)
                                .stroke(
                                    (selectedMarketType == "Multiple Choice" || selectedMarketType == "Prop Bet") ? 
                                    Color.slingBlue.opacity(0.3) : Color.clear,
                                    lineWidth: 1.5
                                )
                        )
                    }
                    }
                }
                
                // Add new option for Multiple Choice and Prop Bet
                if selectedMarketType == "Multiple Choice" || selectedMarketType == "Prop Bet" {
                    VStack(spacing: 0) {
                    HStack(spacing: 16) {
                            // Add icon
                            ZStack {
                                Circle()
                                    .fill(Color.slingBlue.opacity(0.1))
                                    .frame(width: 36, height: 36)
                                
                                Image(systemName: "plus")
                                    .font(.subheadline)
                                    .fontWeight(.bold)
                                    .foregroundColor(.slingBlue)
                            }
                            
                            // Add option text field
                            VStack(alignment: .leading, spacing: 4) {
                        TextField("Add another option...", text: $newOptionText)
                            .textFieldStyle(PlainTextFieldStyle())
                                    .font(.headline)
                                    .fontWeight(.medium)
                                    .foregroundColor(.black)
                                
                                Text("Tap + to add this option")
                                    .font(.caption2)
                                    .foregroundColor(.gray)
                            }
                            
                            Spacer()
                            
                            // Add button
                        Button(action: {
                                if !newOptionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                                    withAnimation(.easeInOut(duration: 0.3)) {
                                        outcomes.append(newOptionText.trimmingCharacters(in: .whitespacesAndNewlines))
                                odds.append("-110")
                                percentages.append("52.4%")
                                newOptionText = ""
                                    }
                                }
                            }) {
                                ZStack {
                                    Circle()
                                        .fill(Color.slingGradient)
                                        .frame(width: 40, height: 40)
                                    
                                Image(systemName: "plus")
                                    .font(.subheadline)
                                        .fontWeight(.bold)
                            .foregroundColor(.white)
                                }
                            }
                            .disabled(newOptionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                            .opacity(newOptionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty ? 0.5 : 1.0)
                        }
                        .padding(.vertical, 20)
                        .padding(.horizontal, 20)
                        .background(
                            RoundedRectangle(cornerRadius: 16)
                                .fill(Color.slingBlue.opacity(0.05))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 16)
                                        .stroke(Color.slingBlue.opacity(0.3), lineWidth: 1.5)
                                )
                        )
                    }
                }
            }
        }
    }
    
    // MARK: - Step 4: Review
    private var reviewStep: some View {
        VStack(spacing: 24) {
            // Title
            VStack(spacing: 8) {
                Text("Review")
                    .font(.title3)
                    .fontWeight(.bold)
                    .foregroundColor(.black)
                
                Text("Double-check everything before creating")
                    .font(.subheadline)
                    .foregroundColor(.gray)
            }
            
            // Market Details Card
            VStack(spacing: 16) {
                HStack(spacing: 12) {
                    Image(systemName: "questionmark.circle.fill")
                        .font(.title2)
                        .foregroundColor(.slingBlue)
                        .frame(width: 24, height: 24)
                    
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Question")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                        
                        Text(attributedText)
                            .font(.subheadline)
                    }
                    
                    Spacer()
                }
                
                HStack(spacing: 12) {
                    Image(systemName: "target")
                        .font(.title2)
                        .foregroundColor(.slingBlue)
                        .frame(width: 24, height: 24)
                    
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Type")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                        
                        Text(selectedMarketType)
                            .font(.subheadline)
                            .foregroundColor(.black)
                    }
                    
                    Spacer()
                }
                
                HStack(spacing: 12) {
                    Image(systemName: "person.2.fill")
                        .font(.title2)
                        .foregroundColor(.slingBlue)
                        .frame(width: 24, height: 24)
                    
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Community")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                        
                        Text(selectedCommunity)
                            .font(.subheadline)
                            .foregroundColor(.black)
                    }
                    
                    Spacer()
                }
                
                HStack(spacing: 12) {
                    Image(systemName: "list.bullet")
                        .font(.title2)
                        .foregroundColor(.slingBlue)
                        .frame(width: 24, height: 24)
                    
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Outcomes")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                        
                        VStack(alignment: .leading, spacing: 4) {
                            ForEach(Array(outcomes.enumerated()), id: \.offset) { index, outcome in
                                HStack {
                                    Text(outcome)
                                        .font(.subheadline)
                                        .foregroundColor(.black)
                                    
                                    Spacer()
                                    
                                    Text(odds[index])
                                        .font(.subheadline)
                                        .foregroundColor(.slingBlue)
                                        .fontWeight(.medium)
                                    
                                    Text("(\(percentages[index]))")
                                        .font(.caption)
                                        .foregroundColor(.gray)
                                }
                            }
                        }
                    }
                    
                    Spacer()
                }
                
                // Mentioned Users Section (only show if there are mentions)
                if !mentionedUsers.isEmpty {
                    HStack(spacing: 12) {
                        Image(systemName: "at")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                            .frame(width: 24, height: 24)
                        
                        VStack(alignment: .leading, spacing: 4) {
                            Text("Hidden Users")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                            
                            VStack(alignment: .leading, spacing: 2) {
                                ForEach(mentionedUsers, id: \.self) { email in
                                    Text(getUserFullName(from: email))
                                        .font(.subheadline)
                                        .foregroundColor(.black)
                                        .fontWeight(.medium)
                                }
                            }
                        }
                        
                        Spacer()
                    }
                }
            }
            .padding(20)
            .background(Color.white)
            .cornerRadius(16)
            .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
            
            // Deadline Card
            VStack(spacing: 16) {
                HStack(spacing: 12) {
                    Image(systemName: "clock.fill")
                        .font(.title2)
                        .foregroundColor(.slingBlue)
                    
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Deadline")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                        
                        Text("When betting closes")
                            .font(.caption)
                            .foregroundColor(.gray)
                    }
                    
                    Spacer()
                }
                
                Button(action: {
                    showingDatePicker = true
                }) {
                    HStack {
                        Text("Closes: \(formatDateForDisplay(bettingCloseDate))")
                            .font(.subheadline)
                            .foregroundColor(.black)
                        
                        Spacer()
                        
                        Image(systemName: "chevron.right")
                            .font(.caption)
                            .foregroundColor(.gray)
                    }
                    .padding(.vertical, 16)
                    .padding(.horizontal, 16)
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                }
            }
            .padding(20)
            .background(Color.white)
            .cornerRadius(16)
            .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
        }
    }
    
    // MARK: - Helper Functions
    private func getStepTitle() -> String {
        switch currentStep {
        case 1: return "Market Type"
        case 2: return "Details"
        case 3: return "Outcomes"
        case 4: return "Review"
        default: return ""
        }
    }
    
    private func getContinueButtonText() -> String {
        switch currentStep {
        case 1, 2: return "Continue"
        case 3: return "Review & Create"
        case 4: return "Create Market"
        default: return "Continue"
        }
    }
    
    private func canContinueToNextStep() -> Bool {
        switch currentStep {
        case 1:
            return !selectedMarketType.isEmpty
        case 2:
            return !marketQuestion.isEmpty && !selectedCommunity.isEmpty
        case 3:
            return true
        case 4:
            return true
        default:
            return false
        }
    }
    
    private func formatDateForDisplay(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy 'at' h:mm a"
        return formatter.string(from: date)
    }
    
    private func updateOutcomesForMarketType() {
        switch selectedMarketType {
        case "Yes/No":
            outcomes = ["Yes", "No"]
            odds = ["-110", "-110"]
            percentages = ["52.4%", "52.4%"]
            spreadLine = ""
            overUnderLine = ""
        case "Multiple Choice":
            outcomes = ["Option 1", "Option 2", "Option 3"]
            odds = ["-110", "-110", "-110"]
            percentages = ["33.3%", "33.3%", "33.3%"]
            spreadLine = ""
            overUnderLine = ""
        case "Spread":
            outcomes = ["Team A", "Team B"]
            odds = ["-110", "-110"]
            percentages = ["52.4%", "52.4%"]
            spreadLine = ""
            overUnderLine = ""
        case "Over/Under":
            outcomes = ["Over", "Under"]
            odds = ["-110", "-110"]
            percentages = ["52.4%", "52.4%"]
            spreadLine = ""
            overUnderLine = ""
        case "Prop Bet":
            outcomes = ["Option 1", "Option 2"]
            odds = ["-110", "-110"]
            percentages = ["52.4%", "52.4%"]
            spreadLine = ""
            overUnderLine = ""
        default:
            break
        }
        
        // Update outcomes based on spread/over-under lines
        updateSpreadOutcomes()
        updateOverUnderOutcomes()
    }
    
    private func updateSpreadOutcomes() {
        guard selectedMarketType == "Spread" else { return }
        if !spreadLine.isEmpty, let spreadValue = Double(spreadLine) {
            outcomes[0] = "Team A \(spreadValue >= 0 ? "+" : "")\(String(format: "%.1f", spreadValue))"
            outcomes[1] = "Team B \(spreadValue >= 0 ? "-" : "+")\(String(format: "%.1f", abs(spreadValue)))"
        } else {
            outcomes[0] = "Team A"
            outcomes[1] = "Team B"
        }
    }
    
    private func updateOverUnderOutcomes() {
        guard selectedMarketType == "Over/Under" else { return }
        if !overUnderLine.isEmpty, let lineValue = Double(overUnderLine) {
            outcomes[0] = "Over \(String(format: "%.1f", lineValue))"
            outcomes[1] = "Under \(String(format: "%.1f", lineValue))"
        } else {
            outcomes[0] = "Over"
            outcomes[1] = "Under"
        }
    }
    

    
    private func createBet() {
        // Validate required fields
        guard !marketQuestion.isEmpty else { return }
        guard !selectedCommunity.isEmpty else { return }
        
        // Find the selected community
        guard let community = firestoreService.userCommunities.first(where: { $0.name == selectedCommunity }) else {
            print("❌ CreateBet: Community not found for name: \(selectedCommunity)")
            return
        }
        
        // Use community.id if available, otherwise use documentId as fallback
        let communityId = community.id ?? community.documentId ?? ""
        
        print("🔍 CreateBet: Selected community - Name: \(community.name), ID: \(community.id ?? "nil"), DocumentID: \(community.documentId ?? "nil"), Final ID: \(communityId)")
        
        // Convert odds array to dictionary
        var oddsDict: [String: String] = [:]
        for (index, option) in outcomes.enumerated() {
            if index < odds.count {
                oddsDict[option] = odds[index]
            }
        }
        
        // Determine bet type
        let betType: String
        switch selectedMarketType {
        case "Yes/No":
            betType = "yes_no"
        case "Multiple Choice":
            betType = "multiple_choice"
        case "Spread":
            betType = "spread"
        case "Over/Under":
            betType = "over_under"
        case "Prop Bet":
            betType = "prop_bet"
        default:
            betType = "yes_no"
        }
        
        // Ensure deadline is in the future with a 1-hour buffer
        let currentDate = Date()
        let minimumDeadline = currentDate.addingTimeInterval(60 * 60) // At least 1 hour from now
        let finalDeadline = bettingCloseDate > minimumDeadline ? bettingCloseDate : minimumDeadline
        
        let betData: [String: Any] = [
            "title": marketQuestion,
            "community_id": communityId,
            "options": outcomes,
            "odds": oddsDict,
            "deadline": finalDeadline,
            "bet_type": betType,
            "spread_line": spreadLine.isEmpty ? NSNull() : spreadLine,
            "over_under_line": overUnderLine.isEmpty ? NSNull() : overUnderLine,
            "status": "open",
            "created_by": firestoreService.currentUser?.email ?? "",
            "creator_email": firestoreService.currentUser?.email ?? "",
            "created_by_id": firestoreService.currentUser?.id ?? "",
            "description": marketQuestion, // Use the title as description for now
            "image_url": NSNull(), // Will be populated later with Unsplash image
            "pool_by_option": Dictionary(uniqueKeysWithValues: outcomes.map { ($0, 0) }), // Initialize pool with 0 for each option
            "total_pool": 0, // Initialize total pool to 0
            "total_participants": 0, // Initialize total participants to 0
            "winner_option": NSNull(), // Will be set when bet is settled
            "created_date": Date(),
            "updated_date": Date(),
            "mentioned_users": mentionedUsers, // Users who are mentioned and should not see the bet until it expires
            "hidden_from_users": mentionedUsers // Alternative field name for clarity
        ]
        
        print("🔍 CreateBet: Bet data - Title: \(marketQuestion), Community ID: \(communityId)")
        print("🔍 CreateBet: Original deadline: \(bettingCloseDate)")
        print("🔍 CreateBet: Current date: \(currentDate)")
        print("🔍 CreateBet: Minimum deadline: \(minimumDeadline)")
        print("🔍 CreateBet: Final deadline: \(finalDeadline)")
        print("🔍 CreateBet: Final deadline (ISO): \(ISO8601DateFormatter().string(from: finalDeadline))")
        print("🔍 CreateBet: Time difference (seconds): \(finalDeadline.timeIntervalSince(currentDate))")
        print("🔍 CreateBet: Time difference (hours): \(finalDeadline.timeIntervalSince(currentDate) / 3600)")
        print("🔍 CreateBet: Available communities: \(firestoreService.userCommunities.map { "\($0.name): \($0.id ?? "nil")" })")
        
        firestoreService.createBet(betData: betData) { success, betId in
            DispatchQueue.main.async {
                if success, let betId = betId {
                    // After successful bet creation, fetch and update the image
                    self.fetchAndUpdateBetImage(betId: betId, betTitle: marketQuestion)
                    dismiss()
                } else {
                    print("Error creating bet: Unknown error")
                }
            }
        }
    }
    
    private func fetchAndUpdateBetImage(betId: String, betTitle: String) {
        // Create an instance of UnsplashImageService to fetch the image
        let imageService = UnsplashImageService()
        
        imageService.getImageForBet(title: betTitle) { imageURL in
            if let imageURL = imageURL {
                // Update the bet document with the fetched image URL
                self.firestoreService.updateBetImage(betId: betId, imageURL: imageURL) { success in
                    if success {
                        print("✅ Bet image updated successfully: \(imageURL)")
                    } else {
                        print("❌ Failed to update bet image")
                    }
                }
            } else {
                print("⚠️ No image found for bet: \(betTitle)")
            }
        }
    }
    
    // MARK: - Mention System
    
    private var attributedText: AttributedString {
        var attributedString = AttributedString(marketQuestion)
        
        // Only color actual user names that were inserted from dropdown
        // Look for patterns like @FirstName LastName (with proper capitalization)
        let mentionPattern = "@[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)+"
        let regex = try? NSRegularExpression(pattern: mentionPattern)
        let range = NSRange(location: 0, length: marketQuestion.utf16.count)
        
        if let matches = regex?.matches(in: marketQuestion, range: range) {
            for match in matches.reversed() {
                let matchRange = Range(match.range, in: marketQuestion)!
                let mentionText = String(marketQuestion[matchRange])
                
                if let mentionRange = attributedString.range(of: mentionText) {
                    // Apply sling gradient color
                    attributedString[mentionRange].foregroundColor = .slingBlue
                    // Keep the same font size and weight as the base text
                    attributedString[mentionRange].font = .subheadline
                }
            }
        }
        
        return attributedString
    }
    
    private func handleMentionInput(oldValue: String, newValue: String) {
        // Check if user typed "@"
        if newValue.count > oldValue.count && newValue.last == "@" {
            showingMentions = true
            mentionSearchText = ""
            currentMentionPosition = newValue.count - 1
        } else if showingMentions {
            // Check if user is typing after "@"
            if let atIndex = newValue.lastIndex(of: "@") {
                let afterAt = String(newValue[newValue.index(after: atIndex)...])
                if afterAt.contains(" ") || afterAt.contains("\n") {
                    // User typed space or newline, hide mentions
                    showingMentions = false
                } else {
                    // Update search text
                    mentionSearchText = afterAt
                }
            } else {
                // No "@" found, hide mentions
                showingMentions = false
            }
        }
        
        // Check if any mentions were deleted and remove them from mentionedUsers list
        let oldMentions = extractMentions(from: oldValue)
        let newMentions = extractMentions(from: newValue)
        
        // Find mentions that were removed
        let removedMentions = oldMentions.filter { !newMentions.contains($0) }
        
        // Remove corresponding users from mentionedUsers list
        for removedMention in removedMentions {
            // Find the user email for this mention
            for (index, email) in mentionedUsers.enumerated().reversed() {
                let fullName = getUserFullName(from: email)
                if removedMention == "@\(fullName)" {
                    mentionedUsers.remove(at: index)
                    break
                }
            }
        }
    }
    
    private func extractMentions(from text: String) -> [String] {
        let mentionPattern = "@[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)+"
        let regex = try? NSRegularExpression(pattern: mentionPattern)
        let range = NSRange(location: 0, length: text.utf16.count)
        
        var mentions: [String] = []
        if let matches = regex?.matches(in: text, range: range) {
            for match in matches {
                let mentionText = (text as NSString).substring(with: match.range)
                mentions.append(mentionText)
            }
        }
        
        return mentions
    }
    
    private var mentionSuggestionsView: some View {
        VStack(spacing: 0) {
            // Use the loaded community members
            let filteredMembers = filterMembers(allCommunityMembers, searchText: mentionSearchText)
            
            if filteredMembers.isEmpty {
                HStack {
                    Spacer()
                    Text("No members found")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                        .padding(.vertical, 12)
                    Spacer()
                }
                .frame(maxWidth: .infinity)
                .padding(.horizontal, 16)
            } else {
                ScrollView {
                    LazyVStack(spacing: 0) {
                        ForEach(filteredMembers, id: \.email) { member in
                            Button(action: {
                                selectMention(member: member)
                            }) {
                                HStack(spacing: 12) {
                                    // Member avatar
                                    Circle()
                                        .fill(Color.slingGradient)
                                        .frame(width: 32, height: 32)
                                        .overlay(
                                            Text(getMemberInitials(member))
                                                .font(.caption)
                                                .fontWeight(.semibold)
                                                .foregroundColor(.white)
                                        )
                                    
                                    VStack(alignment: .leading, spacing: 2) {
                                        Text(getMemberFullName(member))
                                            .font(.subheadline)
                                            .fontWeight(.medium)
                                            .foregroundColor(.black)
                                        
                                        Text(getUserDisplayName(from: member.email))
                                            .font(.caption)
                                            .foregroundColor(.gray)
                                    }
                                    
                                    Spacer()
                                }
                                .padding(.horizontal, 16)
                                .padding(.vertical, 12)
                                .background(Color.white)
                            }
                            .buttonStyle(PlainButtonStyle())
                            
                            if member.email != filteredMembers.last?.email {
                                Divider()
                                    .padding(.leading, 60)
                            }
                        }
                    }
                }
                .frame(maxHeight: 200)
            }
        }
        .background(Color.white)
        .cornerRadius(12)
        .shadow(color: .black.opacity(0.1), radius: 8, x: 0, y: 4)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(Color.gray.opacity(0.2), lineWidth: 1)
        )
    }
    
    private func loadAllCommunityMembers() {
        var allMembers: [CommunityMemberInfo] = []
        let group = DispatchGroup()
        
        for community in firestoreService.userCommunities {
            if let communityId = community.id {
                group.enter()
                firestoreService.fetchCommunityMembers(communityId: communityId) { members in
                    allMembers.append(contentsOf: members)
                    group.leave()
                }
            }
        }
        
        group.notify(queue: .main) {
            // Remove duplicates based on email
            let uniqueMembers = Dictionary(grouping: allMembers, by: { $0.email })
                .compactMapValues { $0.first }
                .values
                .sorted { $0.name < $1.name }
            
            self.allCommunityMembers = Array(uniqueMembers)
        }
    }
    
    private func filterMembers(_ members: [CommunityMemberInfo], searchText: String) -> [CommunityMemberInfo] {
        if searchText.isEmpty {
            return members
        }
        
        return members.filter { member in
            // Search by display name from Firestore
            getUserDisplayName(from: member.email).localizedCaseInsensitiveContains(searchText) ||
            // Search by email (which contains username)
            member.email.localizedCaseInsensitiveContains(searchText) ||
            // Search by full name from Firestore
            getMemberFullName(member).localizedCaseInsensitiveContains(searchText)
        }
    }
    
    private func getUserFullName(from email: String) -> String {
        // Check cache first
        if let cachedName = userFullNames[email] {
            return cachedName
        }
        
        // Fetch from Firestore
        firestoreService.getUserDetails(email: email) { fullName, username in
            DispatchQueue.main.async {
                self.userFullNames[email] = fullName
            }
        }
        
        // Return email as fallback while fetching
        return email
    }
    
    private func getUserDisplayName(from email: String) -> String {
        // Check cache first
        if let cachedName = userDisplayNames[email] {
            return cachedName
        }
        
        // Fetch from Firestore
        firestoreService.getUserDetails(email: email) { fullName, username in
            DispatchQueue.main.async {
                // Extract display name from the username (remove @)
                let displayName = username.hasPrefix("@") ? String(username.dropFirst()) : username
                self.userDisplayNames[email] = displayName
            }
        }
        
        // Return email username as fallback while fetching
        let emailUsername = email.components(separatedBy: "@").first ?? email
        return emailUsername
    }
    
    private func getMemberFullName(_ member: CommunityMemberInfo) -> String {
        return getUserFullName(from: member.email)
    }
    
    private func getMemberInitials(_ member: CommunityMemberInfo) -> String {
        let components = member.name.components(separatedBy: " ")
        if components.count >= 2 {
            let firstInitial = String(components[0].prefix(1)).uppercased()
            let lastInitial = String(components[1].prefix(1)).uppercased()
            return "\(firstInitial)\(lastInitial)"
        } else if components.count == 1 {
            return String(components[0].prefix(1)).uppercased()
        } else {
            return String(member.email.prefix(1)).uppercased()
        }
    }
    
    private func selectMention(member: CommunityMemberInfo) {
        // Replace the "@" and search text with @FullName
        let fullName = getMemberFullName(member)
        let mentionText = "@\(fullName)"
        
        // Find the position of the "@" in the current text
        if let atIndex = marketQuestion.lastIndex(of: "@") {
            let beforeAt = String(marketQuestion[..<atIndex])
            let afterMention = String(marketQuestion[marketQuestion.index(after: atIndex)...])
            
            // Remove any text after "@" that was part of the search
            if let spaceIndex = afterMention.firstIndex(of: " ") {
                let afterSpace = String(afterMention[spaceIndex...])
                marketQuestion = beforeAt + mentionText + afterSpace
            } else {
                marketQuestion = beforeAt + mentionText
            }
        }
        
        // Add to mentioned users list
        if !mentionedUsers.contains(member.email) {
            mentionedUsers.append(member.email)
        }
        
        // Hide mentions
        showingMentions = false
        mentionSearchText = ""
    }
}

// MARK: - Colored TextField

struct ColoredTextField: UIViewRepresentable {
    @Binding var text: String
    let placeholder: String
    let onTextChange: (String, String) -> Void
    
    func makeUIView(context: Context) -> UITextField {
        let textField = UITextField()
        textField.placeholder = placeholder
        textField.font = UIFont.systemFont(ofSize: 16)
        textField.delegate = context.coordinator
        textField.backgroundColor = UIColor.clear
        textField.borderStyle = .none
        return textField
    }
    
    func updateUIView(_ uiView: UITextField, context: Context) {
        uiView.text = text
        updateTextColor(uiView)
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    private func updateTextColor(_ textField: UITextField) {
        let attributedString = NSMutableAttributedString(string: text)
        
        // Only color actual user names that were inserted from dropdown
        // Look for patterns like @FirstName LastName (with proper capitalization)
        let mentionPattern = "@[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)+"
        let regex = try? NSRegularExpression(pattern: mentionPattern)
        let range = NSRange(location: 0, length: text.utf16.count)
        
        if let matches = regex?.matches(in: text, range: range) {
            for match in matches.reversed() {
                let matchRange = match.range
                let mentionText = (text as NSString).substring(with: matchRange)
                
                // Apply sling blue color to mentions
                let slingBlueColor = UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)
                attributedString.addAttribute(.foregroundColor, value: slingBlueColor, range: matchRange)
                attributedString.addAttribute(.font, value: UIFont.systemFont(ofSize: 16), range: matchRange)
            }
        }
        
        // Set default color for non-mention text
        attributedString.addAttribute(.foregroundColor, value: UIColor.label, range: NSRange(location: 0, length: text.utf16.count))
        
        textField.attributedText = attributedString
    }
    
    class Coordinator: NSObject, UITextFieldDelegate {
        let parent: ColoredTextField
        
        init(_ parent: ColoredTextField) {
            self.parent = parent
        }
        
        func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
            let oldText = textField.text ?? ""
            
            // If user is deleting (string is empty), check if they're deleting part of a mention
            if string.isEmpty && range.length > 0 {
                let mentionPattern = "@[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)+"
                let regex = try? NSRegularExpression(pattern: mentionPattern)
                let textRange = NSRange(location: 0, length: oldText.utf16.count)
                
                if let matches = regex?.matches(in: oldText, range: textRange) {
                    for match in matches {
                        let mentionRange = match.range
                        // Check if the deletion range overlaps with any mention
                        if NSIntersectionRange(range, mentionRange).length > 0 {
                            // Delete the entire mention instead
                            let beforeMention = (oldText as NSString).substring(to: mentionRange.location)
                            let afterMention = (oldText as NSString).substring(from: mentionRange.location + mentionRange.length)
                            let newText = beforeMention + afterMention
                            
                            DispatchQueue.main.async {
                                self.parent.text = newText
                                self.parent.onTextChange(oldText, newText)
                            }
                            
                            return false // Prevent the original deletion
                        }
                    }
                }
            }
            
            let newText = (oldText as NSString).replacingCharacters(in: range, with: string)
            
            DispatchQueue.main.async {
                self.parent.text = newText
                self.parent.onTextChange(oldText, newText)
            }
            
            return true
        }
    }
}

// MARK: - Colored Text View

struct ColoredTextView: UIViewRepresentable {
    @Binding var text: String
    let placeholder: String
    let onTextChange: (String, String) -> Void
    
    func makeUIView(context: Context) -> UITextView {
        let textView = UITextView()
        textView.font = UIFont.systemFont(ofSize: 16)
        textView.delegate = context.coordinator
        textView.backgroundColor = UIColor.clear
        textView.textContainerInset = UIEdgeInsets.zero
        textView.textContainer.lineFragmentPadding = 0
        textView.isScrollEnabled = true
        textView.showsVerticalScrollIndicator = false
        return textView
    }
    
    func updateUIView(_ uiView: UITextView, context: Context) {
        // Handle placeholder
        if text.isEmpty {
            uiView.text = placeholder
            uiView.textColor = UIColor.placeholderText
        } else {
            if uiView.text != text {
                uiView.text = text
                updateTextColor(uiView)
            }
        }
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    private func updateTextColor(_ textView: UITextView) {
        let attributedString = NSMutableAttributedString(string: text)
        
        // Set consistent font for entire text first
        let baseFont = UIFont.systemFont(ofSize: 16)
        attributedString.addAttribute(.font, value: baseFont, range: NSRange(location: 0, length: text.utf16.count))
        attributedString.addAttribute(.foregroundColor, value: UIColor.label, range: NSRange(location: 0, length: text.utf16.count))
        
        // Only color actual user names that were inserted from dropdown
        // Look for patterns like @FirstName LastName (with proper capitalization)
        let mentionPattern = "@[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)+"
        let regex = try? NSRegularExpression(pattern: mentionPattern)
        let range = NSRange(location: 0, length: text.utf16.count)
        
        if let matches = regex?.matches(in: text, range: range) {
            for match in matches.reversed() {
                let matchRange = match.range
                let mentionText = (text as NSString).substring(with: matchRange)
                
                // Apply sling blue color to mentions (keep same font)
                let slingBlueColor = UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)
                attributedString.addAttribute(.foregroundColor, value: slingBlueColor, range: matchRange)
                // Don't change font - keep the base font
            }
        }
        
        textView.attributedText = attributedString
    }
    
    class Coordinator: NSObject, UITextViewDelegate {
        let parent: ColoredTextView
        
        init(_ parent: ColoredTextView) {
            self.parent = parent
        }
        
        func textViewDidChange(_ textView: UITextView) {
            let newText = textView.text ?? ""
            let oldText = parent.text
            
            DispatchQueue.main.async {
                self.parent.text = newText
                self.parent.onTextChange(oldText, newText)
            }
        }
        
        func textViewDidBeginEditing(_ textView: UITextView) {
            // Clear placeholder when user starts typing
            if textView.text == parent.placeholder {
                textView.text = ""
                textView.textColor = UIColor.label
                parent.text = ""
            }
        }
        
        func textViewDidEndEditing(_ textView: UITextView) {
            // Show placeholder if empty
            if textView.text.isEmpty {
                textView.text = parent.placeholder
                textView.textColor = UIColor.placeholderText
            }
        }
        
        func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
            let oldText = textView.text ?? ""
            
            // If user is deleting (text is empty), check if they're deleting part of a mention
            if text.isEmpty && range.length > 0 {
                let mentionPattern = "@[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)+"
                let regex = try? NSRegularExpression(pattern: mentionPattern)
                let textRange = NSRange(location: 0, length: oldText.utf16.count)
                
                if let matches = regex?.matches(in: oldText, range: textRange) {
                    for match in matches {
                        let mentionRange = match.range
                        // Check if the deletion range overlaps with any mention
                        if NSIntersectionRange(range, mentionRange).length > 0 {
                            // Delete the entire mention instead
                            let beforeMention = (oldText as NSString).substring(to: mentionRange.location)
                            let afterMention = (oldText as NSString).substring(from: mentionRange.location + mentionRange.length)
                            let newText = beforeMention + afterMention
                            
                            DispatchQueue.main.async {
                                self.parent.text = newText
                                self.parent.onTextChange(oldText, newText)
                            }
                            
                            return false // Prevent the original deletion
                        }
                    }
                }
            }
            
            return true
        }
    }
}

// MARK: - Pool Option Row

struct PoolOptionRow: View {
    let option: String
    let poolByOption: [String: Int]
    let totalPool: Int
    let firestoreService: FirestoreService
    let bet: FirestoreBet
    
    private var optionPool: Int {
        poolByOption[option] ?? 0
    }
    
    private var percentage: Double {
        totalPool > 0 ? Double(optionPool) / Double(totalPool) * 100 : 0.0
    }
    
    private var impliedOdds: Double {
        firestoreService.calculateImpliedOdds(for: bet)[option] ?? 0.5
    }
    
    private var formattedOdds: String {
        firestoreService.formatImpliedOdds(impliedOdds)
    }
    
    var body: some View {
                        HStack {
            Text(option)
                                .font(.caption)
                        .foregroundColor(.black)
                    
                            Spacer()
                            
            Text("\(optionPool) pts")
                                .font(.caption)
                                .foregroundColor(.gray)
            
            Text("(\(String(format: "%.1f", percentage))%)")
                .font(.caption)
                .foregroundColor(.gray)
            
            Text(formattedOdds)
                                    .font(.caption)
                .fontWeight(.medium)
                                    .foregroundColor(.slingBlue)
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 6)
        .background(Color.gray.opacity(0.1))
        .cornerRadius(6)
    }
}

// MARK: - Main Odds Display View

struct MainOddsDisplayView: View {
    let odds: String
    let percentage: String
    let showPercentage: Bool
    let currentInput: String
    
    // Helper function to convert percentage to odds
    private func percentageToOdds(_ percentage: Double) -> String {
        if percentage > 50 {
            // For percentages > 50%, calculate negative odds
            let odds = (percentage / (100 - percentage)) * 100
            return "-\(Int(odds))"
        } else {
            // For percentages <= 50%, calculate positive odds
            let odds = ((100 - percentage) / percentage) * 100
            return "+\(Int(odds))"
        }
    }
    
    var body: some View {
        VStack(spacing: 8) {
            if showPercentage {
                // When showing percentages on preset buttons, display current input as percentage
                HStack(spacing: 0) {
                    Text(currentInput.replacingOccurrences(of: "%", with: ""))
                        .font(.system(size: 80, weight: .bold))
                        .foregroundColor(.black)
                    
                    Text("%")
                        .font(.system(size: 80, weight: .bold))
                        .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                }
                
                // Show equivalent odds below
                if let percentageValue = Double(currentInput.replacingOccurrences(of: "%", with: "")) {
                    Text("\(percentageToOdds(percentageValue)) Odds")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
            } else {
                // When showing odds on preset buttons, display current input as odds
                HStack(spacing: 0) {
                    // Fixed width container for the sign to prevent text shifting
                    HStack {
                        if currentInput.hasPrefix("+") {
                            Text("+")
                                .font(.system(size: 80, weight: .bold))
                                .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                        } else if currentInput.hasPrefix("-") {
                            Text("-")
                                .font(.system(size: 80, weight: .bold))
                                .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                        } else {
                            // Invisible placeholder to maintain consistent spacing
                            Text("+")
                                .font(.system(size: 80, weight: .bold))
                                .foregroundColor(.clear)
                        }
                    }
                    .frame(width: 50) // Fixed width to prevent shifting
                    
                    Text(currentInput.replacingOccurrences(of: "+", with: "").replacingOccurrences(of: "-", with: ""))
                        .font(.system(size: 80, weight: .bold))
                        .foregroundColor(.black)
                }
                
                // Show equivalent percentage below
                if let oddsValue = Double(currentInput.replacingOccurrences(of: "+", with: "").replacingOccurrences(of: "-", with: "")) {
                    let percentage = oddsValue > 0 ? (100 / (oddsValue + 100)) * 100 : (oddsValue / (oddsValue - 100)) * 100
                    Text("\(String(format: "%.0f", percentage))% Chance")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
            }
        }
    }
}

// MARK: - Numeric Keypad View

struct NumericKeypadView: View {
    let selectionFeedback: UISelectionFeedbackGenerator
    let onKeyPress: (String) -> Void
    
    var body: some View {
        VStack(spacing: 0) {
            Spacer()
            
            VStack(spacing: 12) {
                // Row 1: 1, 2, 3
                HStack(spacing: 12) {
                    ForEach(1...3, id: \.self) { number in
                        SimpleKeypadButton(number: "\(number)", action: {
                            onKeyPress("\(number)")
                            selectionFeedback.selectionChanged()
                        })
                    }
                }
                
                // Row 2: 4, 5, 6
                HStack(spacing: 12) {
                    ForEach(4...6, id: \.self) { number in
                        SimpleKeypadButton(number: "\(number)", action: {
                            onKeyPress("\(number)")
                            selectionFeedback.selectionChanged()
                        })
                    }
                }
                
                // Row 3: 7, 8, 9
                HStack(spacing: 12) {
                    ForEach(7...9, id: \.self) { number in
                        SimpleKeypadButton(number: "\(number)", action: {
                            onKeyPress("\(number)")
                            selectionFeedback.selectionChanged()
                        })
                    }
                }
                
                // Row 4: +/-, 0, delete
                HStack(spacing: 12) {
                    SimpleKeypadButton(number: "+/-", action: {
                        onKeyPress("+/-")
                        selectionFeedback.selectionChanged()
                    })
                    
                    SimpleKeypadButton(number: "0", action: {
                        onKeyPress("0")
                        selectionFeedback.selectionChanged()
                    })
                    
                    Button(action: { 
                        onKeyPress("delete")
                        selectionFeedback.selectionChanged()
                    }) {
                        Image(systemName: "delete.left")
                            .font(.title2)
                                        .foregroundColor(.black)
                            .frame(maxWidth: .infinity)
                            .frame(height: 60)
                            .background(Color.white)
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
            .padding(.horizontal, 20)
            .padding(.bottom, 34) // Add padding for home indicator
        }
    }
}

// MARK: - Odds History Chart View

struct OddsHistoryChart: View {
    let bet: FirestoreBet
    let oddsHistory: [OddsHistoryEntry]
    @ObservedObject var firestoreService: FirestoreService
    @State private var selectedOption: String? = nil
    @State private var touchLocation: CGPoint? = nil
    @State private var hoveredOdds: [String: Double] = [:]
    @State private var hoveredDate: Date? = nil
    @State private var selectedTimeframe: String = "ALL"
    
    private var chartData: [(option: String, points: [ChartPoint])] {
        let options = selectedOption != nil ? [selectedOption!] : bet.options
        var result: [(option: String, points: [ChartPoint])] = []
        
        print("📊 chartData: Starting with timeframe: \(selectedTimeframe)")
        print("📊 chartData: Total odds history entries: \(oddsHistory.count)")
        
        // Filter odds history based on selected timeframe
        let filteredHistory = filterOddsHistoryByTimeframe(oddsHistory, timeframe: selectedTimeframe)
        print("📊 chartData: Filtered history entries for \(selectedTimeframe): \(filteredHistory.count)")
        
        // Check if we have meaningful data (more than just initial odds entry)
        let hasRealBettingData = filteredHistory.count > 1 || 
                                (filteredHistory.count == 1 && hasSignificantBettingActivity())
        
        for option in options {
            let points = filteredHistory.map { entry in
                ChartPoint(
                    timestamp: entry.timestamp,
                    odds: entry.odds_by_option[option] ?? 0.0
                )
            }.sorted { $0.timestamp < $1.timestamp }
            
            print("📊 chartData: Option '\(option)' has \(points.count) points after filtering")
            
            // For shorter timeframes, always create data even without betting activity
            // For ALL timeframe, only create data if there's real betting activity
            let shouldCreateData = hasRealBettingData || (selectedTimeframe != "ALL")
            
            if !shouldCreateData {
                print("📊 chartData: No real betting data yet for '\(option)' - skipping artificial data creation")
                continue
            }
            
            // Use granular data only when there's no real data available
            // For ALL timeframe and shorter timeframes, use real data when available
            let shouldUseGranularData = points.isEmpty
            
            if shouldUseGranularData {
                print("📊 chartData: Creating granular data for '\(option)' in \(selectedTimeframe) (points.count: \(points.count))")
                
                // Get the most recent data point and create proper timeframe window
                if let mostRecentEntry = oddsHistory.max(by: { $0.timestamp < $1.timestamp }),
                   let odds = mostRecentEntry.odds_by_option[option] {
                    
                    // Create proper timeframe window (e.g., 7pm-8pm for 1H, 7pm-10pm for 3H)
                    let now = Date()
                    let endTime = now
                    let startTime = endTime.addingTimeInterval(-getTimeframeInterval(selectedTimeframe))
                    
                    let granularPoints = createGranularPoints(
                        startTime: startTime,
                        endTime: endTime,
                        odds: odds,
                        timeframe: selectedTimeframe
                    )
                    
                    result.append((option: option, points: granularPoints))
                    print("📊 chartData: Created \(granularPoints.count) granular points for '\(option)' in \(selectedTimeframe) from \(startTime) to \(endTime)")
                    
                    // Debug: Show sample odds values to verify curves
                    if granularPoints.count > 5 {
                        let sampleIndices = [0, granularPoints.count/4, granularPoints.count/2, 3*granularPoints.count/4, granularPoints.count-1]
                        let sampleOdds = sampleIndices.map { granularPoints[$0].odds }
                        print("📊 chartData: Sample odds for '\(option)': \(sampleOdds.map { String(format: "%.3f", $0) })")
                    }
                } else {
                    // If absolutely no data, create a default granular line for proper timeframe
                    let now = Date()
                    let endTime = now
                    let startTime = endTime.addingTimeInterval(-getTimeframeInterval(selectedTimeframe))
                    
                    let granularPoints = createGranularPoints(
                        startTime: startTime,
                        endTime: endTime,
                        odds: 0.5,
                        timeframe: selectedTimeframe
                    )
                    result.append((option: option, points: granularPoints))
                    print("📊 chartData: Created \(granularPoints.count) default granular points for '\(option)' in \(selectedTimeframe) from \(startTime) to \(endTime)")
                }
            } else if points.count == 1 {
                // If only one point in timeframe, create a second point to form a line
                let singlePoint = points[0]
                let earlierPoint = ChartPoint(
                    timestamp: singlePoint.timestamp.addingTimeInterval(-3600), // 1 hour earlier
                    odds: singlePoint.odds
                )
                result.append((option: option, points: [earlierPoint, singlePoint]))
                print("📊 chartData: Created line from single timeframe point for '\(option)'")
            } else {
                result.append((option: option, points: points))
                print("📊 chartData: Using real data for '\(option)' (\(points.count) points) in \(selectedTimeframe)")
            }
        }
        
        print("📊 chartData: Final result has \(result.count) options")
        for (index, data) in result.enumerated() {
            print("📊 chartData: Option \(index): '\(data.option)' with \(data.points.count) points")
        }
        
        return result
    }
    
    private func getTimeframeInterval(_ timeframe: String) -> TimeInterval {
        switch timeframe {
        case "1H":
            return 3600 // 1 hour
        case "3H":
            return 10800 // 3 hours
        case "6H":
            return 21600 // 6 hours
        case "1D":
            return 86400 // 1 day
        case "ALL":
            return 86400 * 30 // 30 days
        default:
            return 3600 // Default to 1 hour
        }
    }
    
    private func hasSignificantBettingActivity() -> Bool {
        // Check if there's actual betting activity (not just initial odds)
        guard let totalPool = bet.total_pool,
              let poolByOption = bet.pool_by_option else {
            return false
        }
        
        // Consider it significant if total pool is > 0 (someone has actually bet)
        return totalPool > 0
    }
    
    private func createGranularPoints(startTime: Date, endTime: Date, odds: Double, timeframe: String) -> [ChartPoint] {
        let calendar = Calendar.current
        var points: [ChartPoint] = []
        
        let timeInterval: TimeInterval
        let maxPoints: Int
        
        switch timeframe {
        case "1H":
            timeInterval = 300 // 5 minute intervals for smoother curves
            maxPoints = 12 // 12 points for 1 hour (every 5 minutes)
        case "3H":
            timeInterval = 900 // 15 minute intervals
            maxPoints = 12 // 12 points for 3 hours (every 15 minutes)
        case "6H":
            timeInterval = 1800 // 30 minute intervals
            maxPoints = 12 // 12 points for 6 hours (every 30 minutes)
        case "1D":
            timeInterval = 7200 // 2 hour intervals
            maxPoints = 12 // 12 points for 1 day (every 2 hours)
        case "ALL":
            // For ALL, use smart intervals based on total time span
            let totalSpan = endTime.timeIntervalSince(startTime)
            if totalSpan > 86400 * 7 { // More than a week
                timeInterval = 86400 // Daily intervals
                maxPoints = min(30, Int(totalSpan / timeInterval))
            } else if totalSpan > 86400 { // More than a day
                timeInterval = 3600 * 6 // 6 hour intervals
                maxPoints = min(28, Int(totalSpan / timeInterval))
            } else {
                timeInterval = 3600 // Hourly intervals
                maxPoints = min(24, Int(totalSpan / timeInterval))
            }
        default:
            timeInterval = 3600
            maxPoints = 24
        }
        
        // Generate points with smooth, simple progression (like ALL timeframe)
        for i in 0..<maxPoints {
            let timestamp = startTime.addingTimeInterval(TimeInterval(i) * timeInterval)
            if timestamp <= endTime {
                // Create a smooth progression from starting odds to current odds
                let progress = Double(i) / Double(maxPoints - 1)
                
                // Start with equal odds (50/50) and progress to current odds
                let startingOdds = 0.5
                let currentOdds = odds
                
                // Simple, smooth curve using easing function (like ALL timeframe)
                let baseOdds = startingOdds + (currentOdds - startingOdds) * progress
                
                // Add minimal, smooth variation (much less than before)
                let time = Double(i) / Double(maxPoints - 1) * 2 * .pi
                
                // Single, gentle sine wave for smoothness
                let smoothWave = sin(time * 0.5) * 0.02
                
                // Very minimal random variation
                let noise = (Double.random(in: -0.002...0.002))
                
                // Combine with minimal intensity
                let totalVariation = smoothWave + noise
                
                let variedOdds = max(0.01, min(0.99, baseOdds + totalVariation))
                
                points.append(ChartPoint(timestamp: timestamp, odds: variedOdds))
            }
        }
        
        // Always include the end time point with the exact current odds
        if !points.isEmpty && points.last!.timestamp < endTime {
            points.append(ChartPoint(timestamp: endTime, odds: odds))
        }
        
        return points
    }
    
    private var colors: [Color] {
        [Color(red: 0.2, green: 0.7, blue: 0.3), Color(red: 0.1, green: 0.4, blue: 0.8), Color(red: 0.8, green: 0.4, blue: 0.1), Color(red: 0.6, green: 0.3, blue: 0.8)]
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            chartHeader
            
            if oddsHistory.isEmpty {
                emptyStateView
            } else {
                VStack(spacing: 12) {
                    chartLegend
                    chartWithData
                }
            }
        }
    }
    
    private var chartHeader: some View {
        HStack {
            Text("Odds History")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundColor(.black)
            
            Spacer()
        }
        .padding(.horizontal, 20)
        .padding(.bottom, 8)
    }
    
    
    private var emptyStateView: some View {
        VStack(spacing: 12) {
            Image(systemName: "chart.line.uptrend.xyaxis")
                .font(.system(size: 40))
                .foregroundColor(.gray.opacity(0.5))
            
            Text("No odds history available")
                .font(.subheadline)
                .foregroundColor(.gray)
            
            Text("Odds will appear here as participants place bets")
                .font(.caption)
                .foregroundColor(.gray)
                .multilineTextAlignment(.center)
            
                }
                .frame(height: 120)
                .frame(maxWidth: .infinity)
                .background(Color.gray.opacity(0.05))
        .cornerRadius(12)
        .padding(.horizontal, 20)
    }
    
    private var chartWithData: some View {
        VStack(spacing: 0) {
            // Check if we have real betting data
            let filteredHistory = filterOddsHistoryByTimeframe(oddsHistory, timeframe: selectedTimeframe)
            let hasRealBettingData = filteredHistory.count > 1 || 
                                    (filteredHistory.count == 1 && hasSignificantBettingActivity())
            
            // If ALL timeframe doesn't have enough data, show "not enough data" for all timeframes
            // Otherwise, show chart for all timeframes
            let shouldShowChart = hasRealBettingData
            
            if !shouldShowChart {
                // Show graph-like background with overlay message
                ZStack {
                    // Graph-like background with horizontal lines
                    VStack(spacing: 0) {
                        ForEach(0..<5, id: \.self) { index in
                            Rectangle()
                                .fill(Color.gray.opacity(0.1))
                                .frame(height: 1)
                                .frame(maxWidth: .infinity)
                            
                            if index < 4 {
                                Spacer()
                            }
                        }
                    }
                    .frame(height: 140)
                    .frame(maxWidth: .infinity)
                    .background(Color.white)
                    .cornerRadius(12)
                    
                    // Overlay message box
                    VStack(spacing: 8) {
                        Image(systemName: "chart.line.uptrend.xyaxis")
                            .font(.system(size: 24))
                            .foregroundColor(.gray.opacity(0.6))
                        
                        Text("Not enough data yet")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(.gray)
                        
                        Text("Odds will appear here once there's enough data")
                            .font(.caption)
                            .foregroundColor(.gray.opacity(0.7))
                            .multilineTextAlignment(.center)
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 12)
                    .background(Color.white.opacity(0.9))
                    .cornerRadius(8)
                    .shadow(color: .black.opacity(0.1), radius: 4, x: 0, y: 2)
                }
                .frame(height: 140)
                .frame(maxWidth: .infinity)
            } else {
                // 100% label above the graph
                HStack {
                    Text("100%")
                        .font(.caption2)
                        .fontWeight(.medium)
                        .foregroundColor(.gray.opacity(0.6))
                        .lineLimit(1)
                        .fixedSize(horizontal: true, vertical: false)
                        .padding(.horizontal, 16)
                    Spacer()
                }
                .padding(.bottom, 8)
                
                // Chart area only (no Y-axis labels)
                chartArea
                
                // 0% label below the graph
                HStack {
                    Text("0%")
                        .font(.caption2)
                        .fontWeight(.medium)
                        .foregroundColor(.gray.opacity(0.6))
                        .lineLimit(1)
                        .fixedSize(horizontal: true, vertical: false)
                        .padding(.horizontal, 16)
                    Spacer()
                }
                .padding(.top, 8)
            }
            
            // Bottom section with volume and timeframe selector
            HStack {
                // Total volume display (bottom left) - aligned with chart edge
                totalVolumeDisplay
                    .padding(.leading, 16)
                
                Spacer()
                
                // Timeframe selector (bottom right) - aligned with chart edge
                timeframeSelector
                    .padding(.trailing, 16)
            }
            .padding(.top, 12)
        }
        .padding(.horizontal, 8)
    }
    
    private var chartLegend: some View {
        HStack(spacing: 16) {
            ForEach(Array(bet.options.enumerated()), id: \.offset) { index, option in
                Button(action: {
                    if selectedOption == option {
                        selectedOption = nil // Deselect if already selected
                    } else {
                        selectedOption = option
                    }
                }) {
                    HStack(spacing: 6) {
                        Circle()
                            .fill(colors[index % colors.count])
                            .frame(width: 8, height: 8)
                            .opacity(selectedOption == nil || selectedOption == option ? 1.0 : 0.3)
                        
                        Text(option)
                            .font(.caption)
                            .fontWeight(.medium)
                            .foregroundColor(selectedOption == nil || selectedOption == option ? .black : .gray)
                            .lineLimit(1)
                        
                        // Show current odds percentage or hovered odds if dragging
                        Text("\(Int((hoveredOdds[option] ?? firestoreService.calculateImpliedOdds(for: bet)[option] ?? 0.5) * 100))%")
                            .font(.caption2)
                            .fontWeight(.medium)
                            .foregroundColor(.gray)
                    }
                }
                .buttonStyle(PlainButtonStyle())
            }
            
            Spacer()
        }
        .padding(.horizontal, 20)
        .padding(.bottom, 4)
    }
    
    private var chartArea: some View {
        GeometryReader { geometry in
            ZStack {
                gridLines(geometry: geometry)
                chartLines(geometry: geometry)
                
                // Vertical line for touch interaction
                if let touchLoc = touchLocation {
                    Rectangle()
                        .fill(Color.gray.opacity(0.3))
                        .frame(width: 1)
                        .position(x: touchLoc.x, y: geometry.size.height / 2)
                        .allowsHitTesting(false) // Allow drag gesture to pass through
                    
                    // Date label above the line
                    if let date = hoveredDate {
                        VStack {
                            Text(formatDate(date))
                                .font(.caption2)
                                .fontWeight(.medium)
                                .foregroundColor(.gray)
                                .padding(.horizontal, 6)
                                .padding(.vertical, 2)
                                .background(Color.white)
                                .cornerRadius(4)
                                .overlay(
                                    RoundedRectangle(cornerRadius: 4)
                                        .stroke(Color.gray.opacity(0.2), lineWidth: 0.5)
                                )
                            
                            Spacer()
                        }
                        .position(x: touchLoc.x, y: 10)
                        .allowsHitTesting(false) // Allow drag gesture to pass through
                    }
                }
                
                // Transparent overlay to capture all touches
                Rectangle()
                    .fill(Color.clear)
                    .contentShape(Rectangle())
                    .gesture(
                        DragGesture(minimumDistance: 0)
                            .onChanged { value in
                                handleChartTouch(at: value.location, geometry: geometry)
                            }
                            .onEnded { _ in
                                // Clear touch location when drag ends
                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                                    touchLocation = nil
                                    hoveredOdds = [:]
                                    hoveredDate = nil
                                }
                            }
                    )
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
        }
        .frame(height: 140)
        .padding(.horizontal, 16)
    }
    
    private func gridLines(geometry: GeometryProxy) -> some View {
        ZStack {
            // Main grid lines at 0%, 50%, and 100%
            ForEach([0, 2, 4], id: \.self) { i in
                let y = CGFloat(i) * (geometry.size.height / 4)
                Rectangle()
                    .fill(Color.gray.opacity(0.1))
                    .frame(height: 0.5)
                    .offset(y: y - geometry.size.height / 2)
                    .allowsHitTesting(false) // Allow drag gesture to pass through
            }
            
            // Reference lines at 75% and 25%
            ForEach([1, 3], id: \.self) { i in
                let y = CGFloat(i) * (geometry.size.height / 4)
                Rectangle()
                    .fill(Color.gray.opacity(0.05))
                    .frame(height: 0.5)
                    .offset(y: y - geometry.size.height / 2)
                    .allowsHitTesting(false) // Allow drag gesture to pass through
            }
        }
    }
    
    private func chartLines(geometry: GeometryProxy) -> some View {
        ForEach(0..<chartData.count, id: \.self) { index in
            let data = chartData[index]
            if !data.points.isEmpty {
                ZStack {
                    // Only draw path if we have more than one point
                    if data.points.count > 1 {
                        chartPath(data: data, geometry: geometry, colorIndex: index)
                            .animation(.easeInOut(duration: 0.6), value: selectedTimeframe)
                            .allowsHitTesting(false) // Allow drag gesture to pass through
                    }
                    
                    // Always show bouncing dot at the end (or only point)
                    if let lastPoint = data.points.last {
                        bouncingDot(at: lastPoint, geometry: geometry, colorIndex: index)
                            .allowsHitTesting(false) // Allow drag gesture to pass through
                            .onAppear {
                                print("🔴 BouncingDot appeared for \(data.option) in \(selectedTimeframe) timeframe at point: \(lastPoint.timestamp), odds: \(lastPoint.odds)")
                            }
                    }
                }
                .onAppear {
                    // Debug logging moved to onAppear to avoid view builder issues
                    DispatchQueue.main.async {
                        print("🔵 Chart data for \(data.option) in \(selectedTimeframe): \(data.points.count) points")
                        if let first = data.points.first, let last = data.points.last {
                            print("🔵 First point: \(first.timestamp), odds: \(first.odds)")
                            print("🔵 Last point: \(last.timestamp), odds: \(last.odds)")
                        }
                    }
                }
            } else {
                // Debug logging moved to onAppear to avoid view builder issues
                let _ = DispatchQueue.main.async {
                    print("🔵 No points for \(data.option) in \(selectedTimeframe)")
                }
            }
        }
        .onAppear {
            print("🔵 chartLines onAppear - selectedTimeframe: \(selectedTimeframe), chartData.count: \(chartData.count)")
        }
    }
    
    private func chartPath(data: (option: String, points: [ChartPoint]), geometry: GeometryProxy, colorIndex: Int) -> some View {
        Path { path in
            let width = geometry.size.width
            let height = geometry.size.height
            
            guard data.points.count > 1 else { return }
            
            // Start with the first point
            let firstPoint = data.points[0]
            let firstX = CGFloat(0) * (width / CGFloat(data.points.count - 1))
            let firstY = height - (CGFloat(firstPoint.odds) * height)
            path.move(to: CGPoint(x: firstX, y: firstY))
            
            // Create smooth curves between points
            for pointIndex in 1..<data.points.count {
                let currentPoint = data.points[pointIndex]
                let prevPoint = data.points[pointIndex - 1]
                
                let currentX = CGFloat(pointIndex) * (width / CGFloat(data.points.count - 1))
                let currentY = height - (CGFloat(currentPoint.odds) * height)
                
                let prevX = CGFloat(pointIndex - 1) * (width / CGFloat(data.points.count - 1))
                let prevY = height - (CGFloat(prevPoint.odds) * height)
                
                // Create control points for smooth curves
                let controlPoint1X = prevX + (currentX - prevX) * 0.5
                let controlPoint1Y = prevY
                let controlPoint2X = prevX + (currentX - prevX) * 0.5
                let controlPoint2Y = currentY
                
                path.addCurve(
                    to: CGPoint(x: currentX, y: currentY),
                    control1: CGPoint(x: controlPoint1X, y: controlPoint1Y),
                    control2: CGPoint(x: controlPoint2X, y: controlPoint2Y)
                )
            }
        }
        .stroke(colors[colorIndex % colors.count], lineWidth: 2.5)
        .animation(.easeInOut(duration: 0.6).delay(0.1), value: selectedTimeframe)
    }
    
    private func bouncingDot(at point: ChartPoint, geometry: GeometryProxy, colorIndex: Int) -> some View {
        BouncingDotView(
            point: point,
            geometry: geometry,
            colorIndex: colorIndex,
            chartData: chartData,
            colors: colors
        )
    }
    
    
    
    private func handleChartTouch(at location: CGPoint, geometry: GeometryProxy) {
        // Constrain touch location within chart boundaries
        let chartWidth = geometry.size.width
        let chartHeight = geometry.size.height
        
        // Clamp X coordinate to chart width
        let clampedX = max(0, min(location.x, chartWidth))
        // Clamp Y coordinate to chart height (prevent dragging beyond 0% and 100% lines)
        let clampedY = max(0, min(location.y, chartHeight))
        
        let constrainedLocation = CGPoint(x: clampedX, y: clampedY)
        touchLocation = constrainedLocation
        
        // Use the actual chart data that's being displayed (including granular points)
        let currentChartData = chartData
        guard !currentChartData.isEmpty else { return }
        
        let xRatio = clampedX / chartWidth
        
        // Get the first option's data to determine time range (all options have same time range)
        let firstOptionData = currentChartData[0]
        guard firstOptionData.points.count > 1 else { return }
        
        let startTime = firstOptionData.points.first!.timestamp
        let endTime = firstOptionData.points.last!.timestamp
        
        // Calculate the exact time at this position
        let totalTimeSpan = endTime.timeIntervalSince(startTime)
        let targetTime = startTime.addingTimeInterval(xRatio * totalTimeSpan)
        
        // Find the two data points to interpolate between for each option
        var interpolatedOdds: [String: Double] = [:]
        
        for optionData in currentChartData {
            let option = optionData.option
            let points = optionData.points
            
            var leftIndex = 0
            var rightIndex = points.count - 1
            
            // Find the two points that bracket the target time
            for i in 0..<points.count - 1 {
                if points[i].timestamp <= targetTime && points[i + 1].timestamp >= targetTime {
                    leftIndex = i
                    rightIndex = i + 1
                    break
                }
            }
            
            let leftPoint = points[leftIndex]
            let rightPoint = points[rightIndex]
            
            // Calculate interpolation factor
            let leftTime = leftPoint.timestamp.timeIntervalSince(startTime)
            let rightTime = rightPoint.timestamp.timeIntervalSince(startTime)
            let targetTimeRelative = targetTime.timeIntervalSince(startTime)
            
            let interpolationFactor: Double
            if rightTime == leftTime {
                interpolationFactor = 0
            } else {
                interpolationFactor = (targetTimeRelative - leftTime) / (rightTime - leftTime)
            }
            
            // Interpolate odds for this option
            let leftOdds = leftPoint.odds
            let rightOdds = rightPoint.odds
            interpolatedOdds[option] = leftOdds + interpolationFactor * (rightOdds - leftOdds)
        }
        
        hoveredOdds = interpolatedOdds
        hoveredDate = targetTime
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        
        switch selectedTimeframe {
        case "1H":
            // Show minutes for 1H timeframe
            formatter.dateFormat = "h:mm a"
            return formatter.string(from: date)
        case "3H":
            // Show 5-minute increments for 3H timeframe
            let calendar = Calendar.current
            let minute = calendar.component(.minute, from: date)
            let roundedMinute = (minute / 5) * 5 // Round to nearest 5 minutes
            let roundedDate = calendar.date(bySettingHour: calendar.component(.hour, from: date), 
                                          minute: roundedMinute, 
                                          second: 0, 
                                          of: date) ?? date
            formatter.dateFormat = "h:mm a"
            return formatter.string(from: roundedDate)
        case "6H":
            // Show 10-minute increments for 6H timeframe
            let calendar = Calendar.current
            let minute = calendar.component(.minute, from: date)
            let roundedMinute = (minute / 10) * 10 // Round to nearest 10 minutes
            let roundedDate = calendar.date(bySettingHour: calendar.component(.hour, from: date), 
                                          minute: roundedMinute, 
                                          second: 0, 
                                          of: date) ?? date
            formatter.dateFormat = "h:mm a"
            return formatter.string(from: roundedDate)
        case "1D":
            // Show hours for 1D timeframe - round to nearest hour
            let calendar = Calendar.current
            let components = calendar.dateComponents([.year, .month, .day, .hour], from: date)
            let roundedDate = calendar.date(from: components) ?? date
            formatter.dateFormat = "MMM d, h a"
            return formatter.string(from: roundedDate)
        case "ALL":
            // Smart display for ALL timeframe
            let now = Date()
            let daysDifference = Calendar.current.dateComponents([.day], from: date, to: now).day ?? 0
            
            if daysDifference >= 1 {
                formatter.dateFormat = "MMM d"
            } else {
                // Round to nearest hour for recent data
                let calendar = Calendar.current
                let components = calendar.dateComponents([.year, .month, .day, .hour], from: date)
                let roundedDate = calendar.date(from: components) ?? date
                formatter.dateFormat = "MMM d, h a"
                return formatter.string(from: roundedDate)
            }
        default:
            formatter.dateFormat = "MMM d, h a"
        }
        
        return formatter.string(from: date)
    }
    
    
    private func filterOddsHistoryByTimeframe(_ history: [OddsHistoryEntry], timeframe: String) -> [OddsHistoryEntry] {
        let now = Date()
        let cutoffDate: Date
        
        print("📊 filterOddsHistoryByTimeframe: Filtering for timeframe '\(timeframe)'")
        print("📊 filterOddsHistoryByTimeframe: Input history has \(history.count) entries")
        print("📊 filterOddsHistoryByTimeframe: Current time: \(now)")
        
        switch timeframe {
        case "1H":
            cutoffDate = now.addingTimeInterval(-1 * 60 * 60) // 1 hour ago
            print("📊 filterOddsHistoryByTimeframe: 1H cutoff: \(cutoffDate)")
        case "3H":
            cutoffDate = now.addingTimeInterval(-3 * 60 * 60) // 3 hours ago
            print("📊 filterOddsHistoryByTimeframe: 3H cutoff: \(cutoffDate)")
        case "6H":
            cutoffDate = now.addingTimeInterval(-6 * 60 * 60) // 6 hours ago
            print("📊 filterOddsHistoryByTimeframe: 6H cutoff: \(cutoffDate)")
        case "1D":
            cutoffDate = now.addingTimeInterval(-24 * 60 * 60) // 1 day ago
            print("📊 filterOddsHistoryByTimeframe: 1D cutoff: \(cutoffDate)")
        default: // "ALL"
            print("📊 filterOddsHistoryByTimeframe: ALL timeframe - returning all \(history.count) entries")
            return history
        }
        
        let filtered = history.filter { $0.timestamp >= cutoffDate }
        print("📊 filterOddsHistoryByTimeframe: Filtered result has \(filtered.count) entries")
        
        // Log some sample timestamps for debugging
        if !history.isEmpty {
            print("📊 filterOddsHistoryByTimeframe: Sample timestamps:")
            for (index, entry) in history.prefix(3).enumerated() {
                print("📊 filterOddsHistoryByTimeframe: Entry \(index): \(entry.timestamp)")
            }
        }
        
        return filtered
    }
    
    private var totalVolumeDisplay: some View {
        let totalVolume = oddsHistory.reduce(0) { total, entry in
            total + (entry.total_pool ?? 0)
        }
        
        return HStack(spacing: 6) {
            Text("Total Volume")
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(.gray)
            
            HStack(spacing: 4) {
                // Lightning bolt with Sling gradient - moved to front of volume number
                Image(systemName: "bolt.fill")
                    .font(.caption)
                    .foregroundStyle(AnyShapeStyle(Color.slingGradient))
                
                Text("\(totalVolume)")
                    .font(.caption)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
            }
        }
    }
    
     private var timeframeSelector: some View {
         HStack(spacing: 6) {
             ForEach(["1H", "3H", "6H", "1D", "ALL"], id: \.self) { timeframe in
                 Button(action: {
                     withAnimation(.easeInOut(duration: 0.3)) {
                         selectedTimeframe = timeframe
                     }
                 }) {
                     Text(timeframe)
                         .font(.caption2)
                         .fontWeight(.medium)
                         .foregroundColor(selectedTimeframe == timeframe ? .white : .gray)
                         .padding(.horizontal, 6)
                         .padding(.vertical, 3)
                         .background(
                             RoundedRectangle(cornerRadius: 4)
                                 .fill(selectedTimeframe == timeframe ? AnyShapeStyle(Color.slingGradient) : AnyShapeStyle(Color.clear))
                         )
                 }
                 .buttonStyle(PlainButtonStyle())
             }
         }
     }
}

struct ChartPoint {
    let timestamp: Date
    let odds: Double
}

// MARK: - Notification Text View

struct NotificationTextView: View {
    let text: String
    let isUnread: Bool
    
    var body: some View {
        HStack(spacing: 0) {
            let components = parseNotificationText(text)
            
            // Debug logging
            let _ = DispatchQueue.main.async {
                print("🔔 NotificationTextView: Original text: '\(text)'")
                print("🔔 NotificationTextView: Parsed components: \(components.count)")
                for (i, comp) in components.enumerated() {
                    print("🔔 Component \(i): '\(comp.text)' isNumber: \(comp.isNumber)")
                }
            }
            
            ForEach(Array(components.enumerated()), id: \.offset) { index, component in
                if component.isNumber {
                    // Number - show with comma formatting
                    Text(component.text)
                        .font(.system(size: 15, weight: isUnread ? .semibold : .regular))
                        .foregroundColor(isUnread ? .primary : .secondary)
                } else {
                    // Regular text
                    Text(component.text)
                        .font(.system(size: 15, weight: isUnread ? .semibold : .regular))
                        .foregroundColor(isUnread ? .primary : .secondary)
                }
            }
        }
        .multilineTextAlignment(.leading)
        .lineLimit(3)
    }
    
    private func parseNotificationText(_ text: String) -> [TextComponent] {
        var components: [TextComponent] = []
        
        // First, remove any legacy [LIGHTNING_BOLT] placeholders
        let cleanedText = text.replacingOccurrences(of: "[LIGHTNING_BOLT]", with: "")
        
        // Debug logging for notification text cleaning
        if text != cleanedText {
            print("🔔 NotificationTextView: Cleaned legacy [LIGHTNING_BOLT] from: '\(text)' -> '\(cleanedText)'")
        }
        
        // Additional text cleaning for corrupted/garbled text
        let furtherCleanedText = cleanCorruptedText(cleanedText)
        
        // Debug logging for corrupted text cleaning
        if cleanedText != furtherCleanedText {
            print("🔔 NotificationTextView: Cleaned corrupted text from: '\(cleanedText)' -> '\(furtherCleanedText)'")
        }
        
        // Simple approach: just return the cleaned text as a single component
        // This avoids the word-by-word processing that was causing character-by-character display
        if !furtherCleanedText.isEmpty {
            components.append(TextComponent(text: furtherCleanedText, isNumber: false))
        }
        
        return components
    }
    
    private func cleanCorruptedText(_ text: String) -> String {
        // Only clean if the text appears to be corrupted
        // Check if text has excessive non-printable characters
        let printableCount = text.filter { char in
            char.isASCII && char.asciiValue! >= 32
        }.count
        
        let totalCount = text.count
        
        // If more than 30% of characters are non-printable, clean the text
        if totalCount > 0 && Double(printableCount) / Double(totalCount) < 0.7 {
            print("🔔 NotificationTextView: Detected corrupted text, cleaning: '\(text)'")
            
            var cleaned = text
            
            // Remove non-printable characters except spaces and newlines
            cleaned = cleaned.filter { char in
                char.isASCII && (char.asciiValue! >= 32 || char.isWhitespace || char.isNewline)
            }
            
            // Remove excessive whitespace
            cleaned = cleaned.replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
            
            // If text is still mostly garbled, provide a fallback
            let readableCharacterCount = cleaned.filter { $0.isLetter || $0.isNumber || $0.isWhitespace }.count
            let totalCharacterCount = cleaned.count
            
            if totalCharacterCount > 0 && Double(readableCharacterCount) / Double(totalCharacterCount) < 0.5 {
                return "Notification message could not be displayed properly"
            }
            
            return cleaned.trimmingCharacters(in: .whitespaces)
        }
        
        // Text appears normal, return as-is
        return text
    }
}

struct TextComponent {
    let text: String
    let isNumber: Bool
    
    init(text: String, isNumber: Bool = false) {
        self.text = text
        self.isNumber = isNumber
    }
}

struct BouncingDotView: View {
    let point: ChartPoint
    let geometry: GeometryProxy
    let colorIndex: Int
    let chartData: [(option: String, points: [ChartPoint])]
    let colors: [Color]
    
    @State private var pulseScale: CGFloat = 1.0
    
    var body: some View {
        let width = geometry.size.width
        let height = geometry.size.height
        
        // Find the index of this point in the data - use approximate matching for granular data
        guard let dataIndex = chartData.firstIndex(where: { data in
            data.points.contains { chartPoint in
                abs(chartPoint.timestamp.timeIntervalSince(point.timestamp)) < 1.0 // Within 1 second
            }
        }) else {
            print("🔴 BouncingDotView: Could not find point in chartData - timestamp: \(point.timestamp)")
            print("🔴 Available timestamps: \(chartData.flatMap { $0.points.map { $0.timestamp } })")
            return AnyView(Circle().frame(width: 0, height: 0))
        }
        
        guard let pointIndex = chartData[dataIndex].points.firstIndex(where: { chartPoint in
            abs(chartPoint.timestamp.timeIntervalSince(point.timestamp)) < 1.0
        }) else {
            print("🔴 BouncingDotView: Could not find point index for timestamp: \(point.timestamp)")
            return AnyView(Circle().frame(width: 0, height: 0))
        }
        
        let x: CGFloat
        let y = height - (CGFloat(point.odds) * height)
        
        // Handle single point case
        if chartData[dataIndex].points.count == 1 {
            x = width / 2 // Center single points
        } else {
            x = CGFloat(pointIndex) * (width / CGFloat(chartData[dataIndex].points.count - 1))
        }
        
        print("🔴 BouncingDotView positioning - pointIndex: \(pointIndex), totalPoints: \(chartData[dataIndex].points.count), x: \(x), y: \(y), width: \(width), height: \(height)")
        
        return AnyView(
            ZStack {
                // Inner dot - stays fixed in position, no scaling
                Circle()
                    .fill(colors[colorIndex % colors.count])
                    .frame(width: 6, height: 6)
                
                // Outer pulsing ring - this scales around the inner dot
                Circle()
                    .stroke(colors[colorIndex % colors.count], lineWidth: 2)
                    .frame(width: 16, height: 16)
                    .opacity(0.4)
                    .scaleEffect(pulseScale)
                    .onAppear {
                        withAnimation(
                            .easeInOut(duration: 1.0)
                            .repeatForever(autoreverses: true)
                            .delay(Double(colorIndex) * 0.3)
                        ) {
                            pulseScale = 1.08
                        }
                    }
            }
            .position(x: x, y: y)
        )
    }
}

// MARK: - Enhanced Participant List

struct EnhancedParticipantList: View {
    let bet: FirestoreBet
    let firestoreService: FirestoreService
    let getBetParticipants: () -> [BetParticipant]?
    let getUserFullName: (String) -> String
    
    @State private var showingDetailSheet = false
    @State private var selectedOption: String = ""
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Participant List:")
                .font(.headline)
                .fontWeight(.bold)
                .foregroundColor(.black)
                .padding(.horizontal, 16)
            
            if let participants = getBetParticipants() {
                if participants.isEmpty {
                    emptyStateView
                } else {
                    // Group participants by outcome
                    let groupedParticipants = groupParticipantsByOutcome(participants)
                    
                    VStack(spacing: 0) {
                        ForEach(Array(bet.options.enumerated()), id: \.offset) { index, option in
                            let optionParticipants = groupedParticipants[option] ?? []
                            let isLastOption = index == bet.options.count - 1
                            participantOptionRow(
                                option: option,
                                participants: optionParticipants,
                                showDivider: !isLastOption
                            )
                        }
                    }
                }
            } else {
                emptyStateView
            }
        }
        .sheet(isPresented: $showingDetailSheet) {
            ParticipantDetailView(
                option: selectedOption,
                participants: getBetParticipants()?.filter { $0.chosen_option == selectedOption } ?? [],
                getUserFullName: getUserFullName,
                bet: bet,
                firestoreService: firestoreService
            )
        }
    }
    
    private var emptyStateView: some View {
        VStack(spacing: 8) {
            Image(systemName: "person.2.slash")
                .font(.title2)
                .foregroundColor(.gray.opacity(0.6))
            
            Text("No active bettors yet")
                .font(.subheadline)
                .foregroundColor(.gray)
                .fontWeight(.medium)
            
            Text("Be the first to place a bet!")
                .font(.caption)
                .foregroundColor(.gray.opacity(0.8))
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 24)
    }
    
    private func groupParticipantsByOutcome(_ participants: [BetParticipant]) -> [String: [BetParticipant]] {
        var grouped: [String: [BetParticipant]] = [:]
        
        print("🔍 groupParticipantsByOutcome: Processing \(participants.count) participants")
        
        for participant in participants {
            let outcome = participant.chosen_option
            if grouped[outcome] == nil {
                grouped[outcome] = []
            }
            grouped[outcome]?.append(participant)
            print("🔍 groupParticipantsByOutcome: Added \(participant.user_email) to option '\(outcome)'")
        }
        
        // Sort each group by stake amount (largest first)
        for outcome in grouped.keys {
            grouped[outcome]?.sort { $0.stake_amount > $1.stake_amount }
            print("🔍 groupParticipantsByOutcome: Option '\(outcome)' has \(grouped[outcome]?.count ?? 0) participants")
        }
        
        return grouped
    }
    
    private func participantOptionRow(option: String, participants: [BetParticipant], showDivider: Bool = true) -> some View {
        let totalWagered = participants.reduce(0) { $0 + $1.stake_amount }
        let color = getColorForOption(option)
        let icon = getIconForOption(option)
        
        return Button(action: {
            selectedOption = option
            showingDetailSheet = true
        }) {
            VStack(spacing: 0) {
            HStack(spacing: 8) {
                // Option name - regular weight, left aligned
                Text(option)
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .foregroundColor(.primary)
                    .frame(width: 50, alignment: .leading)
                
                // Stacked profile pictures with better overlap - moved closer to option
                if participants.isEmpty {
                    // Show "No bets yet" message when no participants
                    Text("No bets yet")
                        .font(.caption)
                        .fontWeight(.medium)
                        .foregroundColor(.gray)
                        .italic()
                } else {
                    HStack(spacing: -4) {
                        ForEach(Array(participants.prefix(5).enumerated()), id: \.offset) { index, participant in
                            ParticipantProfilePictureView(
                                userEmail: participant.user_email,
                                size: 32,
                                borderWidth: 1.5
                            )
                            .zIndex(Double(5 - index))
                            .overlay(
                                Circle()
                                    .stroke(LinearGradient(
                                        gradient: Gradient(colors: [Color(red: 0.2, green: 0.6, blue: 1.0), Color(red: 0.4, green: 0.8, blue: 1.0)]),
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    ), lineWidth: 1.5)
                            )
                        }
                        
                        // Show "+X more" if there are more than 5 participants
                        if participants.count > 5 {
                            Circle()
                                .fill(Color.slingBlue)
                                .frame(width: 32, height: 32)
                                .overlay(
                                    Text("+\(participants.count - 5)")
                                        .font(.caption2)
                                        .fontWeight(.bold)
                                        .foregroundColor(.white)
                                )
                                .zIndex(0)
                                .overlay(
                                    Circle()
                                        .stroke(LinearGradient(
                                            gradient: Gradient(colors: [Color(red: 0.2, green: 0.6, blue: 1.0), Color(red: 0.4, green: 0.8, blue: 1.0)]),
                                            startPoint: .topLeading,
                                            endPoint: .bottomTrailing
                                        ), lineWidth: 1.5)
                                )
                        }
                    }
                }
                    
                    Spacer()
                    
                    // Total wagered with Sling gradient lightning bolt
                    HStack(spacing: 6) {
                        Image(systemName: "bolt.fill")
                            .font(.caption)
                            .foregroundStyle(AnyShapeStyle(Color.slingGradient))
                        
                        Text(formatNumberWithCommas(totalWagered))
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(.secondary)
                    }
                    
                    // Right arrow to indicate clickability
                    Image(systemName: "chevron.right")
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
                .padding(.horizontal, 16)
                .padding(.vertical, 16)
                .background(Color(.systemBackground))
                
                // Faint horizontal divider line - only show if not last option
                if showDivider {
                    Rectangle()
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 0.5)
                        .padding(.horizontal, 16)
                }
            }
        }
        .buttonStyle(PlainButtonStyle())
    }
    
    private func getColorForOption(_ option: String) -> Color {
        switch option.lowercased() {
        case "yes":
            return Color.slingBlue
        case "no":
            return Color.slingPurple
        default:
            return Color.gray
        }
    }
    
    private func getIconForOption(_ option: String) -> String {
        switch option.lowercased() {
        case "yes":
            return "checkmark.circle.fill"
        case "no":
            return "xmark.circle.fill"
        default:
            return "circle.fill"
        }
    }
    
    private func getUserInitials(from email: String) -> String {
        let fullName = getUserFullName(email)
        let components = fullName.components(separatedBy: " ")
        
        if components.count >= 2 {
            let firstInitial = String(components[0].prefix(1)).uppercased()
            let lastInitial = String(components[1].prefix(1)).uppercased()
            return "\(firstInitial)\(lastInitial)"
        } else if components.count == 1 {
            return String(components[0].prefix(2)).uppercased()
        } else {
            return String(email.prefix(2)).uppercased()
        }
    }
    
    private func formatNumberWithCommas(_ number: Int) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        return formatter.string(from: NSNumber(value: number)) ?? "\(number)"
    }
}

// MARK: - Participant Detail View

struct ParticipantDetailView: View {
    let option: String
    let participants: [BetParticipant]
    let getUserFullName: (String) -> String
    let bet: FirestoreBet
    let firestoreService: FirestoreService
    
    @Environment(\.dismiss) private var dismiss
    
    private var communityName: String {
        if let community = firestoreService.userCommunities.first(where: { $0.id == bet.community_id }) {
            return community.name
        }
        return "Community"
    }
    
    var body: some View {
        VStack(spacing: 0) {
            // Header with X button in top left
            HStack {
                Button(action: {
                    dismiss()
                }) {
                    Image(systemName: "xmark")
                        .font(.title2)
                        .fontWeight(.medium)
                        .foregroundColor(.black)
                }
                
                Spacer()
            }
            .padding(.horizontal, 16)
            .padding(.top, 20)
            .padding(.bottom, 20)
            
            // Bet Choice section - left aligned, larger font
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    HStack(spacing: 4) {
                        Text("Bet Choice:")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                        
                        Text(option)
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                    }
                }
                
                Spacer()
            }
            .padding(.horizontal, 16)
            .padding(.bottom, 12)
            
            // Summary section
            HStack {
                Image(systemName: "person.2")
                    .font(.subheadline)
                    .foregroundColor(.gray)
                
                Text(communityName)
                    .font(.subheadline)
                    .foregroundColor(.gray)
                
                Spacer()
                
                HStack(spacing: 4) {
                    Image(systemName: "bolt.fill")
                        .font(.subheadline)
                        .foregroundStyle(Color.slingGradient)
                    
                    Text("\(formatNumberWithCommas(totalWagered))")
                        .font(.subheadline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                }
            }
            .padding(.horizontal, 16)
            .padding(.bottom, 12)
            
            // Divider
            Rectangle()
                .fill(Color.gray.opacity(0.3))
                .frame(height: 0.5)
                .padding(.horizontal, 16)
            
            // Participants List with fixed bottom button
            VStack(spacing: 0) {
                ScrollView {
                    LazyVStack(spacing: 0) {
                        if participants.isEmpty {
                            // No bets placed message
                            VStack(spacing: 16) {
                                Image(systemName: "person.2.slash")
                                    .font(.system(size: 48))
                                    .foregroundColor(.gray.opacity(0.6))
                                
                                Text("No bets placed yet")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.gray)
                                
                                Text("Be the first to place a bet on this option!")
                                    .font(.subheadline)
                                    .foregroundColor(.gray.opacity(0.8))
                                    .multilineTextAlignment(.center)
                            }
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 40)
                        } else {
                            ForEach(participants, id: \.id) { participant in
                                participantDetailRow(participant: participant)
                            }
                        }
                    }
                    .padding(.bottom, 20) // Bottom padding for content
                }
                
            }
        }
        .background(Color.white)
        .cornerRadius(16, corners: [.topLeft, .topRight])
        .ignoresSafeArea(.all, edges: .bottom)
    }
    
    private var totalWagered: Int {
        participants.reduce(0) { $0 + $1.stake_amount }
    }
    
    private func formatNumberWithCommas(_ number: Int) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        return formatter.string(from: NSNumber(value: number)) ?? "\(number)"
    }
    
    private func participantDetailRow(participant: BetParticipant) -> some View {
        HStack(spacing: 12) {
            // Profile picture with sling gradient border
            ParticipantProfilePictureView(
                userEmail: participant.user_email,
                size: 40,
                borderWidth: 2
            )
            .overlay(
                Circle()
                    .stroke(LinearGradient(
                        gradient: Gradient(colors: [Color(red: 0.2, green: 0.6, blue: 1.0), Color(red: 0.4, green: 0.8, blue: 1.0)]),
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ), lineWidth: 2)
            )
            
            // User info section
            VStack(alignment: .leading, spacing: 2) {
                Text(getUserFullName(participant.user_email))
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(.black)
                    .lineLimit(1)
                
                Text(timeAgoString(from: participant.created_date))
                    .font(.system(size: 13, weight: .medium))
                    .foregroundColor(.gray)
            }
            
            Spacer()
            
            // Black text with lightning bolt in sling gradient
            HStack(spacing: 4) {
                Image(systemName: "bolt.fill")
                    .font(.system(size: 12, weight: .bold))
                    .foregroundStyle(Color.slingGradient)
                
                Text(formatNumberWithCommas(participant.stake_amount))
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(.black)
            }
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
    }
    
    private func getColorForOption(_ option: String) -> Color {
        switch option.lowercased() {
        case "yes":
            return Color.slingBlue
        case "no":
            return Color.slingPurple
        default:
            return Color.slingBlue
        }
    }
    
    private func getIconForOption(_ option: String) -> String {
        switch option.lowercased() {
        case "yes":
            return "checkmark.circle.fill"
        case "no":
            return "xmark.circle.fill"
        default:
            return "circle.fill"
        }
    }
    
    private func getUserInitials(from email: String) -> String {
        let fullName = getUserFullName(email)
        let components = fullName.components(separatedBy: " ")
        
        if components.count >= 2 {
            let firstInitial = String(components[0].prefix(1)).uppercased()
            let lastInitial = String(components[1].prefix(1)).uppercased()
            return "\(firstInitial)\(lastInitial)"
        } else if components.count == 1 {
            return String(components[0].prefix(2)).uppercased()
        } else {
            return String(email.prefix(2)).uppercased()
        }
    }
    
    private func timeAgoString(from date: Date) -> String {
        let now = Date()
        let timeInterval = now.timeIntervalSince(date)
        
        let timeString: String
        if timeInterval < 60 {
            timeString = "just now"
        } else if timeInterval < 3600 {
            let minutes = Int(timeInterval / 60)
            timeString = "\(minutes)m ago"
        } else if timeInterval < 86400 {
            let hours = Int(timeInterval / 3600)
            timeString = "\(hours)h ago"
        } else if timeInterval < 604800 {
            let days = Int(timeInterval / 86400)
            timeString = "\(days)d ago"
        } else if timeInterval < 2592000 {
            let weeks = Int(timeInterval / 604800)
            timeString = "\(weeks)w ago"
        } else {
            let months = Int(timeInterval / 2592000)
            timeString = "\(months)mo ago"
        }
        
        return "Placed a bet \(timeString)"
    }
}

// MARK: - Participant Profile Picture View

struct ParticipantProfilePictureView: View {
    let userEmail: String
    let size: CGFloat
    let borderWidth: CGFloat
    
    @State private var profileImageUrl: String?
    @State private var isLoading = true
    @State private var userFullName: String = ""
    
    var body: some View {
        Group {
            if let imageUrl = profileImageUrl, !imageUrl.isEmpty {
                AsyncImage(url: URL(string: imageUrl)) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    Circle()
                        .fill(Color.slingBlue.opacity(0.2))
                        .overlay(
                            Text(getInitials())
                                .font(.caption2)
                                .fontWeight(.semibold)
                                .foregroundColor(.slingBlue)
                        )
                }
            } else {
                Circle()
                    .fill(Color.slingBlue.opacity(0.2))
                    .overlay(
                        Text(getInitials())
                            .font(.caption2)
                            .fontWeight(.semibold)
                            .foregroundColor(.slingBlue)
                    )
            }
        }
        .frame(width: size, height: size)
        .clipShape(Circle())
        .overlay(
            Circle()
                .stroke(LinearGradient(
                    gradient: Gradient(colors: [Color(red: 0.2, green: 0.6, blue: 1.0), Color(red: 0.4, green: 0.8, blue: 1.0)]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                ), lineWidth: borderWidth)
        )
        .onAppear {
            loadUserData()
        }
    }
    
    private func loadUserData() {
        // Use FirestoreService to get user details and profile picture
        let firestoreService = FirestoreService()
        
        // Get user details for better initials
        firestoreService.getUserDetails(email: userEmail) { fullName, username in
            DispatchQueue.main.async {
                self.userFullName = fullName
            }
        }
        
        // Get profile picture URL from database
        firestoreService.getUserProfilePicture(email: userEmail) { profilePictureUrl in
            DispatchQueue.main.async {
                self.profileImageUrl = profilePictureUrl
                self.isLoading = false
            }
        }
    }
    
    private func getInitials() -> String {
        // Use full name if available, otherwise fall back to email parsing
        if !userFullName.isEmpty {
            let nameComponents = userFullName.components(separatedBy: " ")
            if nameComponents.count >= 2 {
                let firstInitial = String(nameComponents[0].prefix(1)).uppercased()
                let lastInitial = String(nameComponents[1].prefix(1)).uppercased()
                return "\(firstInitial)\(lastInitial)"
            } else if nameComponents.count == 1 {
                return String(nameComponents[0].prefix(2)).uppercased()
            }
        }
        
        // Fallback to email parsing
        let components = userEmail.components(separatedBy: "@")
        let namePart = components.first ?? ""
        let nameComponents = namePart.components(separatedBy: ".")
        
        if nameComponents.count >= 2 {
            let firstInitial = String(nameComponents[0].prefix(1)).uppercased()
            let lastInitial = String(nameComponents[1].prefix(1)).uppercased()
            return "\(firstInitial)\(lastInitial)"
        } else {
            return String(namePart.prefix(2)).uppercased()
        }
    }
}

// MARK: - Keypad Button View

struct KeypadButton: View {
    let text: String?
    let icon: String?
    let action: () -> Void
    
    init(text: String, action: @escaping () -> Void) {
        self.text = text
        self.icon = nil
        self.action = action
    }
    
    init(icon: String, action: @escaping () -> Void) {
        self.text = nil
        self.icon = icon
        self.action = action
    }
    
    var body: some View {
        Button(action: action) {
            if let text = text {
                Text(text)
                    .font(.system(size: text == "+/-" ? 18 : 24, weight: .medium))
                    .foregroundColor(.black)
            } else if let icon = icon {
                Image(systemName: icon)
                    .font(.system(size: 20, weight: .medium))
                    .foregroundColor(.black)
            }
        }
        .frame(width: 60, height: 60)
        .background(Color.white)
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(Color.gray.opacity(0.2), lineWidth: 1)
        )
    }
}

// MARK: - Adjust Odds Header View

struct AdjustOddsHeaderView: View {
    @Binding var isPresented: Bool
    @Binding var showPercentage: Bool
    let selectionFeedback: UISelectionFeedbackGenerator
    
    var body: some View {
        HStack {
            Button("Done") {
                isPresented = false
            }
            .foregroundColor(.slingBlue)
            
            Spacer()
            
            Text("Adjust Odds")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundColor(.black)
            
            Spacer()
            
            // Toggle between odds and percentage
            Button(showPercentage ? "+/-" : "%") {
                withAnimation(.easeInOut(duration: 0.2)) {
                    showPercentage.toggle()
                }
                selectionFeedback.selectionChanged()
            }
            .foregroundColor(.slingBlue)
            .fontWeight(.semibold)
            .padding(.horizontal, 12)
            .padding(.vertical, 6)
            .background(
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.slingBlue.opacity(0.1))
            )
        }
        .padding(.horizontal, 20)
        .padding(.top, 16)
    }
}

// MARK: - Adjust Odds View

struct AdjustOddsView: View {
    @Binding var odds: [String]
    @Binding var percentages: [String]
    @Binding var isPresented: Bool
    let outcomes: [String]
    @State private var selectedOutcomeIndex: Int = 0
    @State private var currentAngle: Double = 0.0
    @State private var isDragging: Bool = false
    @State private var lastAngle: Double = 0.0
    @State private var showPercentage: Bool = false
    @State private var currentInput: String = ""
    
    // Haptic feedback
    private let impactFeedback = UIImpactFeedbackGenerator(style: .light)
    private let selectionFeedback = UISelectionFeedbackGenerator()
    
    // Preset odds - organized in sets of 4
    private let presetOddsSets = [
        ["-110", "-150", "+110", "+150"],
        ["-200", "-250", "+200", "+250"],
        ["-300", "-400", "+300", "+500"]
    ]
    
    // Preset percentage sets - organized in sets of 4
    private let presetPercentageSets = [
        ["52%", "60%", "48%", "40%"],
        ["67%", "71%", "33%", "29%"],
        ["75%", "80%", "25%", "17%"]
    ]
    
    @State private var currentOddsSetIndex = 0
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                AdjustOddsHeaderView(
                    isPresented: $isPresented,
                    showPercentage: $showPercentage,
                    selectionFeedback: selectionFeedback
                )
                
                
                // Main Content
                VStack(spacing: 0) {
                    // Top content area
                    VStack(spacing: 32) {
                        // Outcome Selection Boxes
                        VStack(spacing: 12) {
                                    HStack(spacing: 8) {
                                ForEach(Array(outcomes.enumerated()), id: \.offset) { index, outcome in
                                    Button(action: {
                                        handleOutcomeSelection(index: index)
                                    }) {
                                    HStack(spacing: 8) {
                                            Text(outcome)
                                                .font(.subheadline)
                                                .fontWeight(.medium)
                                                .foregroundColor(selectedOutcomeIndex == index ? .white : .black)
                                            
                                            Text(showPercentage ? percentages[index] : odds[index])
                                                .font(.caption)
                                                .fontWeight(.bold)
                                                .foregroundColor(selectedOutcomeIndex == index ? .white : .slingBlue)
                                        }
                                        .frame(maxWidth: .infinity)
                            .padding(.horizontal, 16)
                            .padding(.vertical, 12)
                                        .background(
                                            RoundedRectangle(cornerRadius: 12)
                                                .fill(selectedOutcomeIndex == index ? Color.slingBlue : Color.white)
                                        )
                                        .overlay(
                                            RoundedRectangle(cornerRadius: 12)
                                                .stroke(selectedOutcomeIndex == index ? Color.clear : Color.gray.opacity(0.3), lineWidth: 1)
                                        )
                                    }
                                    .buttonStyle(PlainButtonStyle())
                                }
                            }
                        }
                        .padding(.top, 20)
                        
                        // Main Odds Display
                        VStack(spacing: 20) {
                            // Large odds display
                            MainOddsDisplayView(
                                odds: odds[selectedOutcomeIndex],
                                percentage: percentages[selectedOutcomeIndex],
                                showPercentage: showPercentage,
                                currentInput: currentInput
                            )
                            .padding(.vertical, 20)
                            
                        Spacer() // Push preset odds down towards keyboard
                        
                        // Preset Odds Buttons with pagination
                        VStack(spacing: 16) {
                            
                            // Preset buttons
                            VStack(spacing: 12) {
                                HStack(spacing: 12) {
                                    ForEach(Array((showPercentage ? presetPercentageSets : presetOddsSets)[currentOddsSetIndex].prefix(2).enumerated()), id: \.offset) { index, preset in
                                        Button(action: {
                                            handlePresetSelection(preset: preset)
                                        }) {
                                            Text(preset)
                                                .font(.subheadline)
                                                .fontWeight(.semibold)
                                                .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                                        }
                                        .frame(maxWidth: .infinity)
                                        .padding(.vertical, 12)
                                        .background(
                                            RoundedRectangle(cornerRadius: 8)
                                                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                                .background(Color.white)
                                        )
                                        .scaleEffect(1.0)
                                        .animation(.spring(response: 0.4, dampingFraction: 0.6), value: currentOddsSetIndex)
                                        .animation(.spring(response: 0.4, dampingFraction: 0.6), value: showPercentage)
                                    }
                                }
                                
                                HStack(spacing: 12) {
                                    ForEach(Array((showPercentage ? presetPercentageSets : presetOddsSets)[currentOddsSetIndex].suffix(2).enumerated()), id: \.offset) { index, preset in
                                        Button(action: {
                                            handlePresetSelection(preset: preset)
                                        }) {
                                            Text(preset)
                                                .font(.subheadline)
                                                .fontWeight(.semibold)
                                                .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                                        }
                                        .frame(maxWidth: .infinity)
                                        .padding(.vertical, 12)
                                        .background(
                                            RoundedRectangle(cornerRadius: 8)
                                                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                                .background(Color.white)
                                        )
                                        .scaleEffect(1.0)
                                        .animation(.spring(response: 0.4, dampingFraction: 0.6), value: currentOddsSetIndex)
                                        .animation(.spring(response: 0.4, dampingFraction: 0.6), value: showPercentage)
                                    }
                                }
                            }
                            
                            // Page indicator
                            HStack(spacing: 4) {
                                ForEach(0..<presetOddsSets.count, id: \.self) { index in
                                    Circle()
                                        .fill(index == currentOddsSetIndex ? Color.slingBlue : Color.gray.opacity(0.3))
                                        .frame(width: 6, height: 6)
                                }
                            }
                        }
                            .padding(.horizontal, 20)
                            .padding(.bottom, 20) // Add space between preset odds and keyboard
                            .gesture(
                                DragGesture()
                                    .onEnded { value in
                                        handleSwipeGesture(value: value)
                                    }
                            )
                        }
                    }
                    .padding(.horizontal, 24)
                    
                    // Numeric Keypad - takes remaining space and positions at bottom
                    NumericKeypadView(selectionFeedback: selectionFeedback) { key in
                        handleKeyPress(key)
                    }
                }
            }
            .background(Color.white)
            .navigationBarHidden(true)
            .onAppear {
                // Initialize angle based on current selected outcome's odds
                currentAngle = getAngleFromOdds(odds[selectedOutcomeIndex])
                // Initialize current input with actual current values
                if showPercentage {
                    let percentageValue = percentages[selectedOutcomeIndex].replacingOccurrences(of: "%", with: "")
                    currentInput = percentageValue.isEmpty ? "1" : percentageValue
                } else {
                    let oddsValue = odds[selectedOutcomeIndex]
                    currentInput = oddsValue.isEmpty ? "-110" : oddsValue
                }
            }
            .onChange(of: showPercentage) { _, newValue in
                // Update currentInput when switching modes
                if newValue {
                    // Switching to percentage mode - convert current odds to percentage
                    if let oddsValue = Double(currentInput.replacingOccurrences(of: "+", with: "").replacingOccurrences(of: "-", with: "")) {
                        let percentageValue = calculatePercentage(from: oddsValue)
                        currentInput = String(format: "%.0f", percentageValue)
                    } else {
                        currentInput = "1" // Default to 1% if no valid odds
                    }
                } else {
                    // Switching to odds mode - convert current percentage to odds
                    if let percentageValue = Double(currentInput.replacingOccurrences(of: "%", with: "")) {
                        currentInput = percentageToOdds(percentageValue)
                    } else {
                        currentInput = "-110" // Default to -110 if no valid percentage
                    }
                }
            }
        }
    }
    
    // MARK: - Helper Functions
    
    private func handleOutcomeSelection(index: Int) {
        // Save current odds before switching
        saveCurrentOdds()
        
        // Switch to new outcome
        selectedOutcomeIndex = index
        
        // Update current input based on current mode
        if showPercentage {
            let percentageValue = percentages[index].replacingOccurrences(of: "%", with: "")
            currentInput = percentageValue.isEmpty ? "1" : percentageValue
        } else {
            let oddsValue = odds[index]
            currentInput = oddsValue.isEmpty ? "-110" : oddsValue
        }
        
        // Update dial to show new odds
        currentAngle = getAngleFromOdds(odds[index])
        
        // Haptic feedback
        selectionFeedback.selectionChanged()
    }
    
    private func handlePresetSelection(preset: String) {
        if showPercentage {
            // If in percentage mode, update percentage and calculate odds
            let percentageValue = Double(preset.replacingOccurrences(of: "%", with: "")) ?? 50.0
            // Prevent 0% and 100% to avoid division by zero
            let clampedPercentage = max(1, min(99, percentageValue))
            
            percentages[selectedOutcomeIndex] = String(format: "%.0f%%", clampedPercentage)
            
            // Convert percentage to odds
            let oddsValue = percentageToOdds(clampedPercentage)
            odds[selectedOutcomeIndex] = oddsValue
            
            // Update currentInput to match the preset
            currentInput = String(format: "%.0f", clampedPercentage)
        } else {
            // If in odds mode, update odds and calculate percentage
            odds[selectedOutcomeIndex] = preset
        
            // Calculate percentage based on odds
            let oddsValue = Int(preset.replacingOccurrences(of: "+", with: "")) ?? 0
            let percentageValue = calculatePercentage(from: Double(oddsValue))
            percentages[selectedOutcomeIndex] = String(format: "%.0f%%", percentageValue)
            
            // Update currentInput to match the preset
            currentInput = preset
        }
        
        selectionFeedback.selectionChanged()
    }
    
    private func handleSwipeGesture(value: DragGesture.Value) {
        let threshold: CGFloat = 50
        
        if value.translation.width > threshold {
            // Swipe right - go to previous page
            withAnimation(.spring(response: 0.6, dampingFraction: 0.8, blendDuration: 0.2)) {
                currentOddsSetIndex = (currentOddsSetIndex - 1 + presetOddsSets.count) % presetOddsSets.count
            }
            selectionFeedback.selectionChanged()
        } else if value.translation.width < -threshold {
            // Swipe left - go to next page
            withAnimation(.spring(response: 0.6, dampingFraction: 0.8, blendDuration: 0.2)) {
                currentOddsSetIndex = (currentOddsSetIndex + 1) % presetOddsSets.count
            }
            selectionFeedback.selectionChanged()
        }
    }
    
    private func handleKeyPress(_ key: String) {
        if key == "delete" {
            if !currentInput.isEmpty {
                currentInput.removeLast()
                
                // Allow empty input - don't force default values
                // Only reset if we're left with just a sign in odds mode
                if !showPercentage && (currentInput == "+" || currentInput == "-") {
                    currentInput = currentInput // Keep the sign
                }
            }
        } else if key == "+/-" {
            // In percentage mode, +/- doesn't make sense, so we'll ignore it
            if !showPercentage {
                if currentInput.hasPrefix("+") {
                    currentInput = "-" + String(currentInput.dropFirst())
                } else if currentInput.hasPrefix("-") {
                    currentInput = "+" + String(currentInput.dropFirst())
                } else if !currentInput.isEmpty {
                    currentInput = "-" + currentInput
                } else {
                    currentInput = "-110" // Default with sign
                }
            }
        } else {
            // If currentInput is empty and we're in odds mode, add a default sign
            if currentInput.isEmpty && !showPercentage {
                currentInput = "-" + key
            } else {
                currentInput += key
            }
        }
        
        // Update the odds and percentages based on current input
        if !currentInput.isEmpty {
            if showPercentage {
                // In percentage mode, currentInput is the percentage value
                if let percentageValue = Double(currentInput.replacingOccurrences(of: "%", with: "")) {
                    // Prevent 0% and 100% to avoid division by zero
                    let clampedPercentage = max(1, min(99, percentageValue))
                    if clampedPercentage != percentageValue {
                        currentInput = String(format: "%.0f", clampedPercentage)
                    }
                    
                    let oddsString = percentageToOdds(clampedPercentage)
                    odds[selectedOutcomeIndex] = oddsString
                    percentages[selectedOutcomeIndex] = String(format: "%.0f%%", clampedPercentage)
                }
            } else {
                // In odds mode, currentInput is the odds value
                // Only update if we have a valid odds value
                if let oddsValue = Int(currentInput.replacingOccurrences(of: "+", with: "").replacingOccurrences(of: "-", with: "")), oddsValue > 0 {
                    odds[selectedOutcomeIndex] = currentInput
                    let percentageValue = calculatePercentage(from: Double(oddsValue))
                    percentages[selectedOutcomeIndex] = String(format: "%.0f%%", percentageValue)
                }
            }
        } else {
            // Handle empty input - keep the previous values but allow the display to be empty
            // This allows users to see an empty field while typing
        }
    }
    
    // MARK: - Circular Dial Helper Functions
    
    private func updateOddsFromAngle(_ angle: Double) {
        // Get the odds directly from the angle (now with 25-increment precision)
        let oddsString = getOddsForAngle(angle)
        let oddsValue = Int(oddsString.replacingOccurrences(of: "+", with: "")) ?? 0
        
        // Update the selected outcome's odds
        odds[selectedOutcomeIndex] = oddsString
        
        // Calculate percentage based on odds
        let percentageValue = calculatePercentage(from: Double(oddsValue))
        percentages[selectedOutcomeIndex] = String(format: "%.1f%%", percentageValue)
    }
    
    private func saveCurrentOdds() {
        // This function is called when switching outcomes to save the current odds
        // The odds are already updated in the array, so this is mainly for any additional logic
    }
    
    private func getOddsForAngle(_ angle: Double) -> String {
        // Map angle to odds with 25-increment steps: +100, +125, +150, +175, +200, ..., +800, -800, -775, ..., -100
        let normalizedAngle = (angle + 360).truncatingRemainder(dividingBy: 360)
        
        // Create full odds range with 25-increment steps
        var oddsRange: [Int] = []
        
        // Positive odds: +100 to +800 in increments of 25
        for i in stride(from: 100, through: 800, by: 25) {
            oddsRange.append(i)
        }
        
        // Negative odds: -800 to -100 in increments of 25
        for i in stride(from: -800, through: -100, by: 25) {
            oddsRange.append(i)
        }
        
        let index = Int((normalizedAngle / 360.0) * Double(oddsRange.count))
        let clampedIndex = max(0, min(index, oddsRange.count - 1))
        let oddsValue = oddsRange[clampedIndex]
        
        return oddsValue > 0 ? "+\(oddsValue)" : "\(oddsValue)"
    }
    
    private func getFontSizeForOdds(_ oddsValue: Int) -> CGFloat {
        let absValue = abs(oddsValue)
        
        // Scale font size based on odds magnitude - much larger
        if absValue < 1000 {
            return 16
        } else if absValue < 5000 {
            return 14
        } else {
            return 12
        }
    }
    
    private func getAngleFromOdds(_ oddsString: String) -> Double {
        let oddsValue = Int(oddsString.replacingOccurrences(of: "+", with: "")) ?? 0
        
        // Create the same odds range as in getOddsForAngle
        var oddsRange: [Int] = []
        
        // Positive odds: +100 to +800 in increments of 25
        for i in stride(from: 100, through: 800, by: 25) {
            oddsRange.append(i)
        }
        
        // Negative odds: -800 to -100 in increments of 25
        for i in stride(from: -800, through: -100, by: 25) {
            oddsRange.append(i)
        }
        
        // Find the index of the odds value in the range
        if let index = oddsRange.firstIndex(of: oddsValue) {
            // Map index to angle (0-360 degrees)
            return (Double(index) / Double(oddsRange.count - 1)) * 360.0
        }
        
        // Fallback to 0 degrees if odds not found
        return 0.0
    }
    
    private func calculatePercentage(from odds: Double) -> Double {
        if odds > 0 {
            return 100.0 / (odds + 100.0) * 100.0
        } else {
            return abs(odds) / (abs(odds) + 100.0) * 100.0
        }
    }
    
    private func percentageToOdds(_ percentage: Double) -> String {
        if percentage > 50 {
            // For percentages > 50%, calculate negative odds
            let odds = (percentage / (100 - percentage)) * 100
            return "-\(Int(odds))"
        } else {
            // For percentages <= 50%, calculate positive odds
            let odds = ((100 - percentage) / percentage) * 100
            return "+\(Int(odds))"
        }
    }
    
    private func getPercentageFromOdds(_ oddsString: String) -> String {
        let oddsValue = Double(oddsString.replacingOccurrences(of: "+", with: "")) ?? 0
        let percentage = calculatePercentage(from: oddsValue)
        return String(format: "%.0f%%", percentage)
    }
}

// MARK: - Date Picker View

struct DatePickerView: View {
    @Binding var selectedDate: Date
    @Binding var isPresented: Bool
    
    var body: some View {
        NavigationView {
            VStack {
                Text("Select a date and time at least 1 hour in the future for betting to close")
                    .font(.caption)
                    .foregroundColor(.gray)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal)
                
                DatePicker("Select Date", selection: $selectedDate, in: Date().addingTimeInterval(60 * 60)..., displayedComponents: [.date, .hourAndMinute])
                    .datePickerStyle(WheelDatePickerStyle())
                    .padding()
                
                Button("Done") {
                    isPresented = false
                }
                .padding()
            }
            .navigationTitle("Select Date")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Cancel") {
                        isPresented = false
                    }
                }
            }
        }
    }
}

// MARK: - Join Community Page

struct JoinCommunityPage: View {
    @Environment(\.dismiss) private var dismiss
    @ObservedObject var firestoreService: FirestoreService
    let onSuccess: (() -> Void)?
    @State private var inviteCode = ""
    @State private var isLoading = false
    @State private var errorMessage = "" {
        didSet {
            print("🔍 JoinCommunity: errorMessage changed from '\(oldValue)' to '\(errorMessage)'")
        }
    }
    @FocusState private var isTextFieldFocused: Bool
    
    // Computed property to validate invite code
    private var isValidInviteCode: Bool {
        let trimmed = inviteCode.trimmingCharacters(in: .whitespacesAndNewlines)
        return trimmed.count == 6 && !trimmed.isEmpty
    }
    
    // Computed property for border color
    private var borderColor: Color {
        if inviteCode.count == 6 {
            return .green
        } else if isTextFieldFocused {
            return .blue
        } else {
            return .clear
        }
    }
    
    // Computed property for validation message
    private var validationMessage: String {
        if inviteCode.isEmpty {
            return ""
        } else if inviteCode.count < 6 {
            return "Enter \(6 - inviteCode.count) more character\(6 - inviteCode.count == 1 ? "" : "s")"
        } else if inviteCode.count == 6 {
            return "Perfect! Code is ready"
        } else {
            return "Code is too long"
        }
    }
    
    init(firestoreService: FirestoreService, onSuccess: (() -> Void)? = nil) {
        self.firestoreService = firestoreService
        self.onSuccess = onSuccess
    }
    
    var body: some View {
            VStack(spacing: 0) {
            // Modern Header - like Sign Up pages
                HStack {
                    Button(action: { dismiss() }) {
                    Image(systemName: "arrow.left")
                            .font(.title2)
                            .fontWeight(.medium)
                            .foregroundColor(.black)
                        .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                }
                .padding(.horizontal, 20)
                .padding(.top, 16)
            
            // Main Content with modern spacing
            VStack(spacing: 40) {
                // Title Section - modern style like Sign Up
                    VStack(spacing: 16) {
                    Text("Join Community")
                        .font(.largeTitle)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                            .multilineTextAlignment(.center)
                        
                        Text("Enter the 6-character invite code to join a betting group")
                        .font(.body)
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                    .padding(.horizontal, 20)
                }
                .padding(.top, 40)
                    
                // Input Section with modern styling
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Invite Code")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                        
                        ZStack(alignment: .trailing) {
                            TextField("ENTER 6-DIGIT CODE", text: $inviteCode)
                                .font(.title3)
                                .fontWeight(.medium)
                                .foregroundColor(.black)
                                .textCase(.uppercase)
                                .autocapitalization(.allCharacters)
                                .disableAutocorrection(true)
                                .padding(.horizontal, 16)
                                .padding(.vertical, 16)
                                .background(
                                    RoundedRectangle(cornerRadius: 12)
                                        .fill(Color.gray.opacity(0.05))
                                        .overlay(
                                            RoundedRectangle(cornerRadius: 12)
                                                .stroke(borderColor, lineWidth: 2)
                                        )
                                )
                                .onChange(of: inviteCode) { _, newValue in
                                    // Limit to 6 characters
                                    if newValue.count > 6 {
                                        inviteCode = String(newValue.prefix(6))
                                        // Show brief feedback that input was truncated
                                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                            errorMessage = "Code limited to 6 characters"
                                            // Clear this message after 2 seconds
                                            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                                                if errorMessage == "Code limited to 6 characters" {
                                                    errorMessage = ""
                                                }
                                            }
                                        }
                                    } else {
                                        // Only clear error message if it's not a validation error or join error
                                        if errorMessage != "Code limited to 6 characters" && errorMessage != "Community not found" {
                                            errorMessage = ""
                                        }
                                    }
                                }
                                .focused($isTextFieldFocused)
                                .onAppear {
                                    isTextFieldFocused = true
                                }
                            
                            // Character counter
                            Text("\(inviteCode.count)/6")
                                .font(.caption)
                                .foregroundColor(inviteCode.count == 6 ? .green : .gray)
                                .fontWeight(.medium)
                                .padding(.trailing, 16)
                        }
                    
                    // Validation message - modern style (only show if no error message)
                    if !validationMessage.isEmpty && errorMessage.isEmpty {
                        Text(validationMessage)
                            .font(.caption)
                            .foregroundColor(inviteCode.count == 6 ? .green : .gray)
                            .animation(.easeInOut(duration: 0.2), value: validationMessage)
                    }
                }
                .padding(.horizontal, 24)
                
                // Error message - modern style (inside main content VStack)
                    if !errorMessage.isEmpty {
                        Text(errorMessage)
                            .font(.subheadline)
                            .foregroundColor(.red)
                            .multilineTextAlignment(.center)
                        .padding(.horizontal, 24)
                        .animation(.easeInOut(duration: 0.2), value: errorMessage)
                        .onAppear {
                            print("🔍 JoinCommunity: Error message view appeared with: '\(errorMessage)'")
                        }
                }
                    }
                    
                    Spacer()
                    
            // Bottom Button Section - like Sign Up pages
            VStack(spacing: 16) {
                    Button(action: joinCommunity) {
                        HStack {
                            if isLoading {
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                    .scaleEffect(0.8)
                            } else {
                                Image(systemName: "person.2")
                                    .font(.title3)
                                    .foregroundColor(.white)
                            }
                            
                            Text(isLoading ? "Joining..." : "Join Community")
                                .font(.headline)
                                .fontWeight(.semibold)
                                .foregroundColor(.white)
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 56)
                        .background(
                            RoundedRectangle(cornerRadius: 28)
                            .fill(isValidInviteCode && !isLoading ? Color.slingBlue : Color.gray.opacity(0.3))
                        )
                    }
                    .disabled(!isValidInviteCode || isLoading)
                .padding(.horizontal, 24)
                    .padding(.bottom, 32)
                }
            }
            .background(Color.white)
            .navigationBarHidden(true)
    }
    
    // MARK: - Actions
    
    private func joinCommunity() {
        let trimmedCode = inviteCode.trimmingCharacters(in: .whitespacesAndNewlines)
        
        print("🔍 JoinCommunity: Attempting to join with code: '\(trimmedCode)'")
        print("🔍 JoinCommunity: Code length: \(trimmedCode.count)")
        
        isLoading = true
        errorMessage = ""
        
        firestoreService.joinCommunity(inviteCode: trimmedCode) { success, error in
            DispatchQueue.main.async {
                print("🔍 JoinCommunity: Result - Success: \(success), Error: \(error ?? "nil")")
                isLoading = false
                if success {
                    print("✅ JoinCommunity: Successfully joined community")
                    dismiss()
                    onSuccess?()
                } else {
                    let errorMsg = error ?? "Invalid community code. Please try again."
                    print("❌ JoinCommunity: Failed to join - \(errorMsg)")
                    print("🔍 JoinCommunity: Setting errorMessage to: '\(errorMsg)'")
                    errorMessage = errorMsg
                    print("🔍 JoinCommunity: errorMessage is now: '\(errorMessage)'")
                    // Clear the invite code on error for better UX
                    withAnimation(.easeInOut(duration: 0.2)) {
                        inviteCode = ""
                    }
                    // Clear error message after 3 seconds (similar to "Code limited to 6 characters")
                    DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {
                        print("🔍 JoinCommunity: Auto-clear triggered, clearing error message")
                        if errorMessage == errorMsg {
                            errorMessage = ""
                        }
                    }
                }
            }
        }
    }
}

// MARK: - Create Community Page

struct CreateCommunityPage: View {
    @Environment(\.dismiss) private var dismiss
    @ObservedObject var firestoreService: FirestoreService
    let onSuccess: (() -> Void)?
    @State private var communityName = ""
    @State private var isLoading = false
    @State private var errorMessage = ""
    @State private var showingShareModal = false
    @State private var createdCommunityId: String?
    @FocusState private var isTextFieldFocused: Bool
    
    init(firestoreService: FirestoreService, onSuccess: (() -> Void)? = nil) {
        self.firestoreService = firestoreService
        self.onSuccess = onSuccess
    }
    
    var body: some View {
            VStack(spacing: 0) {
            // Modern Header - like Sign Up pages
                HStack {
                    Button(action: {
                        isTextFieldFocused = false
                        dismiss()
                    }) {
                    Image(systemName: "arrow.left")
                            .font(.title2)
                            .fontWeight(.medium)
                            .foregroundColor(.black)
                        .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                }
                .padding(.horizontal, 20)
                .padding(.top, 16)
            
            // Main Content with modern spacing
            VStack(spacing: 40) {
                // Title Section - modern style like Sign Up
                    VStack(spacing: 16) {
                    Text("Create Community")
                        .font(.largeTitle)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                            .multilineTextAlignment(.center)
                        
                        Text("Start a betting group for friends, family, or colleagues")
                        .font(.body)
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                    .padding(.horizontal, 20)
                }
                .padding(.top, 40)
                    
                // Input Section with modern styling
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Community Name")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                        
                        TextField("Enter community name", text: $communityName)
                        .textFieldStyle(ModernTextFieldStyle())
                            .overlay(
                                RoundedRectangle(cornerRadius: 12)
                                .stroke(isTextFieldFocused ? Color.slingBlue : Color.clear, lineWidth: 2)
                            )
                            .focused($isTextFieldFocused)
                            .onAppear {
                                isTextFieldFocused = true
                            }
                            .onChange(of: communityName) { _, newValue in
                                errorMessage = ""
                            }
                    
                    // Character count and validation
                    HStack {
                        if !communityName.isEmpty {
                            if isValidCommunityName {
                                HStack(spacing: 4) {
                                    Image(systemName: "checkmark.circle.fill")
                                        .font(.caption)
                                        .foregroundColor(.green)
                                    Text("Looks good!")
                                        .font(.caption)
                                        .foregroundColor(.green)
                                }
                            } else if communityName.count > 50 {
                                Text("Too long")
                                    .font(.caption)
                                    .foregroundColor(.red)
                            }
                        }
                        
                        Spacer()
                        
                        Text("\(communityName.count)/50")
                            .font(.caption)
                            .foregroundColor(communityName.count > 50 ? .red : .gray)
                    }
                    .animation(.easeInOut(duration: 0.2), value: communityName)
                }
                .padding(.horizontal, 24)
                
                // Error message - modern style
                    if !errorMessage.isEmpty {
                        Text(errorMessage)
                            .font(.subheadline)
                            .foregroundColor(.red)
                            .multilineTextAlignment(.center)
                        .padding(.horizontal, 24)
                        .animation(.easeInOut(duration: 0.2), value: errorMessage)
                    }
                    
                    Spacer()
            }
                    
            // Bottom Button Section - like Sign Up pages
            VStack(spacing: 16) {
                    Button(action: createCommunity) {
                        HStack {
                            if isLoading {
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                    .scaleEffect(0.8)
                            } else {
                                Image(systemName: "person.2")
                                    .font(.title3)
                                    .foregroundColor(.white)
                            }
                            
                            Text(isLoading ? "Creating..." : "Create Community")
                                .font(.headline)
                                .fontWeight(.semibold)
                                .foregroundColor(.white)
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 56)
                        .background(
                            RoundedRectangle(cornerRadius: 28)
                            .fill(isValidCommunityName && !isLoading ? Color.slingBlue : Color.gray.opacity(0.3))
                        )
                    }
                    .disabled(!isValidCommunityName || isLoading)
                .padding(.horizontal, 24)
                    .padding(.bottom, 32)
                }
            }
            .background(Color.white)
            .navigationBarHidden(true)
        .sheet(isPresented: $showingShareModal) {
            ShareCommunityModal(
                communityName: communityName,
                communityId: createdCommunityId ?? "",
                onDismiss: {
                    dismiss()
                    onSuccess?()
                }
            )
        }
    }
    
    // MARK: - Computed Properties
    
    private var isValidCommunityName: Bool {
        let trimmed = communityName.trimmingCharacters(in: .whitespacesAndNewlines)
        return !trimmed.isEmpty && trimmed.count <= 50
    }
    
    // MARK: - Actions
    
    private func createCommunity() {
        let trimmedName = communityName.trimmingCharacters(in: .whitespacesAndNewlines)
        
        guard isValidCommunityName else {
            if trimmedName.isEmpty {
            errorMessage = "Please enter a community name"
            } else if trimmedName.count > 50 {
                errorMessage = "Community name must be 50 characters or less"
            }
            return
        }
        
        isLoading = true
        errorMessage = ""
        isTextFieldFocused = false
        
        // Add haptic feedback
        let impactFeedback = UIImpactFeedbackGenerator(style: .medium)
        impactFeedback.impactOccurred()
        
        let inviteCode = UUID().uuidString.prefix(6).uppercased()
        
        SlingLogInfo("Generated 6-character invite code for community: \(trimmedName)")
        
        let communityData: [String: Any] = [
            "name": trimmedName,
            "description": "A new betting community",
            "created_by": firestoreService.currentUser?.email ?? "",
            "created_date": Date(),
            "invite_code": inviteCode,
            "member_count": 1,
            "bet_count": 0,
            "total_bets": 0,
            "is_active": true,
            "is_private": false,
            "updated_date": Date()
        ]
        
        firestoreService.createCommunity(communityData: communityData) { success, error in
            DispatchQueue.main.async {
                isLoading = false
                if success {
                    createdCommunityId = error // The error parameter contains the community ID on success
                    showingShareModal = true
                    
                    // Success haptic feedback
                    let successFeedback = UINotificationFeedbackGenerator()
                    successFeedback.notificationOccurred(.success)
                } else {
                    errorMessage = error ?? "Failed to create community. Please try again."
                    
                    // Error haptic feedback
                    let errorFeedback = UINotificationFeedbackGenerator()
                    errorFeedback.notificationOccurred(.error)
                }
            }
        }
    }
}



// MARK: - Share Community Modal

struct ShareCommunityModal: View {
    @Environment(\.dismiss) private var dismiss
    let communityName: String
    let communityId: String
    let onDismiss: () -> Void

    @State private var showConfetti = false
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                HStack {
                    Button(action: { onDismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title3)
                            .fontWeight(.medium)
                            .foregroundColor(.black.opacity(0.6))
                    }
                    
                    Spacer()
                }
                .padding(.horizontal, 20)
                .padding(.top, 16)
                .padding(.bottom, 32)
                
                // Main Success Content
                VStack(spacing: 32) {
                    // Animated Success Icon with Confetti
                    ZStack {
                        // Confetti effect
                        if showConfetti {
                            ConfettiView()
                                .allowsHitTesting(false)
                        }
                        
                        // Success Icon
                        Image(systemName: "checkmark.circle.fill")
                            .font(.system(size: 80))
                            .foregroundColor(.green)
                            .scaleEffect(showConfetti ? 1.1 : 1.0)
                            .animation(.spring(response: 0.6, dampingFraction: 0.6), value: showConfetti)
                    }
                    .onAppear {
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                            showConfetti = true
                        }
                    }
                    
                    // Personalized Headline
                    VStack(spacing: 12) {
                        Text("Welcome to \(communityName) 🎉")
                            .font(.title)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                            .multilineTextAlignment(.center)
                        
                        Text("Your community is live and ready for action!")
                            .font(.title3)
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                    }
                    .padding(.horizontal, 20)
                    
                    // Quick Share Button
                    Button(action: {
                        shareCommunityLink()
                    }) {
                        HStack(spacing: 12) {
                            Image(systemName: "square.and.arrow.up")
                                .font(.title3)
                                .foregroundColor(.white)
                            
                            Text("Share Community Link")
                                .font(.headline)
                                .fontWeight(.semibold)
                                .foregroundColor(.white)
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 56)
                        .background(Color.slingGradient)
                        .cornerRadius(28)
                    }
                    .padding(.horizontal, 20)
                    

                    
                    // Continue to Community Button
                    Button(action: {
                        onDismiss()
                    }) {
                        Text("Continue to Community")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(.gray)
                    }
                    .padding(.top, 8)
                }
                
                Spacer()
            }
            .background(Color.white)
            .navigationBarHidden(true)
        }

    }
    
    private func shareCommunityLink() {
        let communityLink = "sling://community/\(communityId)"
        let activityVC = UIActivityViewController(
            activityItems: [
                "Join my community \"\(communityName)\" on Sling! \(communityLink)"
            ],
            applicationActivities: nil
        )
        
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let window = windowScene.windows.first {
            window.rootViewController?.present(activityVC, animated: true)
        }
    }
}

// MARK: - Confetti View

struct ConfettiView: View {
    @State private var showConfetti = false
    
    var body: some View {
        ZStack {
            if showConfetti {
                ForEach(0..<20, id: \.self) { index in
                    ConfettiPiece(
                        color: [.red, .blue, .green, .yellow, .orange, .purple, .pink][index % 7],
                        size: CGFloat.random(in: 4...8),
                        delay: Double(index) * 0.1
                    )
                }
            }
        }
        .onAppear {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                showConfetti = true
            }
        }
    }
}

struct ConfettiPiece: View {
    let color: Color
    let size: CGFloat
    let delay: Double
    
    @State private var isAnimating = false
    
    var body: some View {
        Circle()
            .fill(color)
            .frame(width: size, height: size)
            .offset(
                x: isAnimating ? CGFloat.random(in: (-80)...80) : 0,
                y: isAnimating ? CGFloat.random(in: (-120)...(-40)) : 0
            )
            .opacity(isAnimating ? 0 : 1)
            .animation(
                .easeOut(duration: 1.5)
                .delay(delay),
                value: isAnimating
            )
            .onAppear {
                DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
                    isAnimating = true
                }
            }
    }
}

// MARK: - Invite Members Modal

struct InviteMembersModal: View {
    @Environment(\.dismiss) private var dismiss
    let communityName: String
    let communityId: String
    @State private var emailAddresses = ""
    @State private var isLoading = false
    @State private var errorMessage = ""
    @State private var successMessage = ""
    
    var body: some View {
        NavigationView {
            VStack(spacing: 24) {
                // Header
                VStack(spacing: 12) {
                    Text("Invite Members")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Text("Invite friends to join \"\(communityName)\"")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                        .multilineTextAlignment(.center)
                }
                .padding(.top, 20)
                
                // Email Input
                VStack(alignment: .leading, spacing: 12) {
                    Text("Email Addresses")
                        .font(.subheadline)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Text("Enter email addresses separated by commas")
                        .font(.caption)
                        .foregroundColor(.gray)
                    
                    TextEditor(text: $emailAddresses)
                        .frame(minHeight: 100)
                        .padding(8)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(8)
                        .overlay(
                            RoundedRectangle(cornerRadius: 8)
                                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                        )
                }
                .padding(.horizontal, 20)
                
                if !errorMessage.isEmpty {
                    Text(errorMessage)
                        .foregroundColor(.red)
                        .font(.caption)
                        .padding(.horizontal, 20)
                }
                
                if !successMessage.isEmpty {
                    Text(successMessage)
                        .foregroundColor(.green)
                        .font(.caption)
                        .padding(.horizontal, 20)
                }
                
                Spacer()
                
                // Action Buttons
                HStack(spacing: 12) {
                    Button("Cancel") {
                        dismiss()
                    }
                    .foregroundColor(.black)
                    .padding(.horizontal, 24)
                    .padding(.vertical, 12)
                    .frame(maxWidth: .infinity)
                    .background(Color.white)
                    .cornerRadius(10)
                    .overlay(
                        RoundedRectangle(cornerRadius: 10)
                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                    )
                    
                    Button("Send Invites") {
                        sendInvites()
                    }
                    .foregroundColor(.white)
                    .padding(.horizontal, 24)
                    .padding(.vertical, 12)
                    .frame(maxWidth: .infinity)
                    .background(emailAddresses.isEmpty || isLoading ? AnyShapeStyle(Color.gray) : AnyShapeStyle(Color.slingGradient))
                    .cornerRadius(10)
                    .disabled(emailAddresses.isEmpty || isLoading)
                }
                .padding(.horizontal, 20)
                .padding(.bottom, 20)
            }
            .background(Color.white)
            .navigationBarHidden(true)
        }
    }
    
    private func sendInvites() {
        guard !emailAddresses.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            errorMessage = "Please enter at least one email address"
            return
        }
        
        isLoading = true
        errorMessage = ""
        successMessage = ""
        
        // Parse email addresses
        let emails = emailAddresses
            .components(separatedBy: ",")
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
            .filter { !$0.isEmpty }
        
        // Here you would typically call your FirestoreService to send invites
        // For now, we'll simulate the process
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
            isLoading = false
            successMessage = "Invites sent to \(emails.count) email(s)!"
            
            // Clear the form after a delay
            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                emailAddresses = ""
                successMessage = ""
            }
        }
    }
}

// MARK: - Join Bet View

struct JoinBetView: View {
    @Environment(\.dismiss) private var dismiss
    let bet: FirestoreBet
    @ObservedObject var firestoreService: FirestoreService
    let onCommunityTap: (() -> Void)? // Callback for community navigation
    @State private var selectedOption = ""
    @State private var showingBettingInterface = false
    @State private var showingShareSheet = false
    @State private var isRulesExpanded = false
    @State private var betParticipants: [BetParticipant] = []
    @State private var otherBets: [FirestoreBet] = []
    @State private var showingBetDetail = false
    @State private var selectedBetForDetail: FirestoreBet? = nil
    @State private var showingCommunityDetails = false
    @State private var showingCreateBet = false
    @State private var userFullNames: [String: String] = [:]
    @State private var oddsHistory: [OddsHistoryEntry] = []
    
    private var communityName: String {
        if let community = firestoreService.userCommunities.first(where: { $0.id == bet.community_id }) {
            return community.name
        }
        return "Community"
    }
    
    // Function to get user's full name, with caching
    private func getUserFullName(from email: String) -> String {
        // Check cache first
        if let cachedName = userFullNames[email] {
            return cachedName
        }
        
        // For current user, use local data
        if let user = firestoreService.currentUser, user.email == email {
            let fullName = "\(user.first_name ?? "") \(user.last_name ?? "")".trimmingCharacters(in: .whitespaces)
            userFullNames[email] = fullName
            return fullName
        }
        
        // For other users, fetch from Firestore and cache
        firestoreService.getUserDetails(email: email) { fullName, _ in
            DispatchQueue.main.async {
                self.userFullNames[email] = fullName
            }
        }
        
        // Return first name as fallback while fetching
        return email.components(separatedBy: "@").first ?? email
    }
    
    private var creatorName: String {
        let creatorEmail = bet.creator_email
        if let currentUserEmail = firestoreService.currentUser?.email, creatorEmail == currentUserEmail {
            return "You"
        } else {
            return getUserFullName(from: creatorEmail)
        }
    }
    
    private var formattedDeadline: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMMM d, yyyy"
        return formatter.string(from: bet.deadline)
    }
    
    private var isMarketClosed: Bool {
        return bet.status == "settled" || bet.status == "voided" || Date() > bet.deadline
    }
    
    private var shortRulesText: String {
        "Every bet on Sling requires two sides to be matched before it's active. Once both users have staked an equal number of Sling Points, the bet becomes locked and cannot be edited or canceled."
    }
    
    private var fullRulesText: String {
        "Every bet on Sling requires two sides to be matched before it's active. Once both users have staked an equal number of Sling Points, the bet becomes locked and cannot be edited or canceled. If only one person has joined, the bet remains unmatched and inactive. After the event concludes, the outcome must be settled by the users, and Sling Points are awarded to the winner accordingly. All bets are tracked within the community they were created in, and participants are responsible for resolving results honestly."
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Top Navigation Bar
                HStack {
                    Button(action: {
                        dismiss()
                    }) {
                        Image(systemName: "arrow.left")
                            .font(.title3)
                            .foregroundColor(.black)
                    }
                    
                    Spacer()
                    
                    Button(action: {
                        showingShareSheet = true
                    }) {
                        Image(systemName: "square.and.arrow.up")
                            .font(.title3)
                            .foregroundColor(.black)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 16)
                
                ScrollView {
                    VStack(alignment: .leading, spacing: 24) {
                        // Bet Title & Meta Information with Image
                        HStack(alignment: .top, spacing: 16) {
                            BetImageView(title: bet.title, imageURL: bet.image_url, size: 64)
                            
                            VStack(alignment: .leading, spacing: 8) {
                                Text(bet.title)
                                    .font(.title)
                                    .fontWeight(.bold)
                                    .foregroundColor(.black)
                                    .multilineTextAlignment(.leading)
                                
                                HStack(spacing: 4) {
                                    Image(systemName: "person.2")
                                        .font(.caption)
                                        .foregroundColor(.slingBlue)
                                    
                                    // Clickable community name
                                    Button(action: {
                                        onCommunityTap?() // Call the callback for community navigation
                                    }) {
                                        Text(communityName)
                                            .font(.subheadline)
                                            .fontWeight(.medium)
                                            .foregroundColor(.slingBlue)
                                    }
                                    .buttonStyle(.plain)
                                    
                                    Text("• by \(creatorName)")
                                        .font(.subheadline)
                                        .foregroundColor(.gray)
                                }
                                
                                HStack(spacing: 4) {
                                    Image(systemName: "calendar")
                                        .font(.caption)
                                        .foregroundColor(isMarketClosed ? .red : .gray)
                                    
                                    Text(isMarketClosed ? "Market is closed" : "Deadline: \(formattedDeadline)")
                                        .font(.subheadline)
                                        .foregroundColor(isMarketClosed ? .red : .gray)
                                        .fontWeight(.regular)
                                }
                            }
                        }
                        .padding(.leading, 16)
                        
                        // Outcome Selection Section
                        VStack(alignment: .leading, spacing: 12) {
                            Text("Choose an outcome:")
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.gray)
                                .padding(.horizontal, 16)
                            
                            VStack(spacing: 8) {
                                ForEach(bet.options, id: \.self) { option in
                                    Button(action: {
                                        // Only allow clicking if market is not closed
                                        guard !isMarketClosed else { return }
                                        
                                        // 🐛 DEBUG: JoinBetView Option Selection
                                        print("🎯 JOIN_BET_OPTION_CLICK: User clicked on option: '\(option)'")
                                        print("🎯 JOIN_BET_OPTION_CLICK: Bet ID: \(bet.id ?? "nil")")
                                        print("🎯 JOIN_BET_OPTION_CLICK: Bet title: '\(bet.title)'")
                                        print("🎯 JOIN_BET_OPTION_CLICK: All bet options: \(bet.options)")
                                        print("🎯 JOIN_BET_OPTION_CLICK: Previous selectedOption: '\(selectedOption)'")
                                        
                                        selectedOption = option
                                        
                                        print("🎯 JOIN_BET_OPTION_CLICK: New selectedOption: '\(selectedOption)'")
                                        print("🎯 JOIN_BET_OPTION_CLICK: About to show betting interface for option: '\(option)'")
                                        print("🎯 JOIN_BET_OPTION_CLICK: ==========================================")
                                        
                                        showingBettingInterface = true
                                    }) {
                                        HStack {
                                            Text(option)
                                                .font(.subheadline)
                                                .fontWeight(.semibold)
                                                .foregroundColor(isMarketClosed ? .gray : .black)
                                            
                                            Spacer()
                                            
                                            Text(firestoreService.formatImpliedOdds(firestoreService.calculateImpliedOdds(for: bet)[option] ?? 0.5))
                                                .font(.subheadline)
                                                .fontWeight(.semibold)
                                                .foregroundColor(isMarketClosed ? .gray : .black)
                                            
                                            // Show lock icon if market is closed
                                            if isMarketClosed {
                                                Image(systemName: "lock.fill")
                                                    .font(.caption)
                                                    .foregroundColor(.gray)
                                                    .padding(.leading, 8)
                                            }
                                        }
                                        .padding(.horizontal, 16)
                                        .padding(.vertical, 12)
                                        .background(isMarketClosed ? Color.gray.opacity(0.1) : Color.slingLightBlue)
                                        .cornerRadius(12)
                                    }
                                    .buttonStyle(.plain)
                                    .disabled(isMarketClosed)
                                }
                            }
                            .padding(.horizontal, 16)
                        }
                        
                        
                        // Odds History Chart
                        OddsHistoryChart(bet: bet, oddsHistory: oddsHistory, firestoreService: firestoreService)
                        
                        // Show Participant List above Other Bets if no other bets available
                        if let otherBets = getOtherBets(), otherBets.isEmpty {
                            // Enhanced Participant List Section
                            EnhancedParticipantList(
                                bet: bet,
                                firestoreService: firestoreService,
                                getBetParticipants: getBetParticipants,
                                getUserFullName: getUserFullName
                            )
                        }
                        
                        // Betting Rules Section
                        VStack(alignment: .leading, spacing: 12) {
                            Text("How Betting on Sling Works:")
                                .font(.headline)
                                .fontWeight(.bold)
                                .foregroundColor(.black)
                                .padding(.horizontal, 16)
                            
                            VStack(alignment: .leading, spacing: 8) {
                                Text(isRulesExpanded ? fullRulesText : shortRulesText)
                                    .font(.subheadline)
                                    .foregroundColor(.gray)
                                    .lineSpacing(4)
                                    .padding(.horizontal, 16)
                                
                                Button(action: {
                                    withAnimation(.easeInOut(duration: 0.3)) {
                                        isRulesExpanded.toggle()
                                    }
                                }) {
                                    Text(isRulesExpanded ? "Read Less" : "Read More")
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                        .foregroundColor(.blue)
                                }
                                .padding(.horizontal, 16)
                            }
                        }
                        
                        // Other Bets Section
                        VStack(alignment: .leading, spacing: 12) {
                            Text("Other Bets to Trade")
                                .font(.headline)
                                .fontWeight(.bold)
                                .foregroundColor(.black)
                                .padding(.horizontal, 16)
                            
                            if let otherBets = getOtherBets() {
                                if otherBets.isEmpty {
                                    VStack(spacing: 16) {
                                        Image(systemName: "tray")
                                            .font(.title2)
                                            .foregroundColor(.gray.opacity(0.6))
                                        
                                        Text("No other bets available")
                                            .font(.subheadline)
                                            .foregroundColor(.gray)
                                            .fontWeight(.medium)
                                    }
                                    .frame(maxWidth: .infinity)
                                    .padding(.vertical, 24)
                                } else {
                                    VStack(spacing: 12) {
                                        ForEach(otherBets.prefix(3), id: \.id) { otherBet in
                                            Button(action: {
                                                // Navigate to bet details
                                                selectedBetForDetail = otherBet
                                                showingBetDetail = true
                                            }) {
                                            HStack(spacing: 12) {
                                                    // Add bet image
                                                    BetImageView(title: otherBet.title, imageURL: otherBet.image_url, size: 40)
                                                    
                                                VStack(alignment: .leading, spacing: 4) {
                                                    Text(otherBet.title)
                                                        .font(.subheadline)
                                                        .fontWeight(.semibold)
                                                        .foregroundColor(.black)
                                                        .lineLimit(2)
                                                            .multilineTextAlignment(.leading)
                                                    
                                                    Text("\(getCommunityName(for: otherBet)) • Created by \(getCreatorName(for: otherBet))")
                                                        .font(.caption)
                                                        .foregroundColor(.gray)
                                                            .multilineTextAlignment(.leading)
                                                        
                                                        // Add deadline info
                                                        Text("Ends \(formatDate(otherBet.deadline))")
                                                            .font(.caption)
                                                            .foregroundColor(.blue)
                                                }
                                                
                                                Spacer()
                                                    
                                                    // Add navigation chevron
                                                    Image(systemName: "chevron.right")
                                                        .font(.caption)
                                                        .foregroundColor(.gray)
                                            }
                                            .padding(.horizontal, 16)
                                                .padding(.vertical, 12)
                                                .background(Color.white)
                                                .cornerRadius(12)
                                                .overlay(
                                                    RoundedRectangle(cornerRadius: 12)
                                                        .stroke(Color.gray.opacity(0.15), lineWidth: 1)
                                                )
                                            }
                                            .buttonStyle(.plain)
                                        }
                                    }
                                }
                            } else {
                                VStack(spacing: 16) {
                                    Image(systemName: "tray")
                                        .font(.title2)
                                        .foregroundColor(.gray.opacity(0.6))
                                    
                                    Text("No other bets available")
                                        .font(.subheadline)
                                        .foregroundColor(.gray)
                                        .fontWeight(.medium)
                                }
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 24)
                            }
                        }
                        
                        // Show Participant List below Other Bets if there are other bets available
                        if let otherBets = getOtherBets(), !otherBets.isEmpty {
                            // Enhanced Participant List Section
                            EnhancedParticipantList(
                                bet: bet,
                                firestoreService: firestoreService,
                                getBetParticipants: getBetParticipants,
                                getUserFullName: getUserFullName
                            )
                        }
                        
                        Spacer(minLength: 50)
                    }
                    .padding(.top, 20)
                }
            }
            .background(Color.white)
            .navigationBarHidden(true)
            .sheet(isPresented: $showingBettingInterface) {
                if !selectedOption.isEmpty {
                    BettingInterfaceView(
                        bet: bet,
                        selectedOption: selectedOption,
                        firestoreService: firestoreService,
                        onBetPlaced: nil
                    )
                    .onAppear {
                        // 🐛 DEBUG: JoinBetView BettingInterfaceView Initialization
                        print("🎯 JOIN_BET_INTERFACE_INIT: JoinBetView presenting BettingInterfaceView")
                        print("🎯 JOIN_BET_INTERFACE_INIT: selectedOption: '\(selectedOption)'")
                        print("🎯 JOIN_BET_INTERFACE_INIT: Bet ID: \(bet.id ?? "nil")")
                        print("🎯 JOIN_BET_INTERFACE_INIT: Bet title: '\(bet.title)'")
                        print("🎯 JOIN_BET_INTERFACE_INIT: ==========================================")
                    }
                }
            }
            .sheet(isPresented: $showingShareSheet) {
                ShareSheet(activityItems: ["Check out this bet on Sling: \"\(bet.title)\" created by \(creatorName). Join the action!"])
            }
            .sheet(isPresented: $showingBetDetail) {
                if let selectedBet = selectedBetForDetail {
                    JoinBetView(
                        bet: selectedBet, 
                        firestoreService: firestoreService,
                        onCommunityTap: {
                            // Navigate to community details
                            // This will be handled by the parent view
                        }
                    )
                }
            }
            .sheet(isPresented: $showingCreateBet) {
                CreateBetView(firestoreService: firestoreService, preSelectedCommunity: nil)
            }
            .onAppear {
                print("🔍 JoinBetView: onAppear called for bet: \(bet.title)")
                print("🔍 JoinBetView: Bet ID: \(bet.id ?? "nil")")
                loadBetParticipants()
                loadOtherBets()
                loadOddsHistory()
            }
        }
    }
    
    // MARK: - Helper Functions
    
    private func loadOddsHistory() {
        guard let betId = bet.id else { 
            print("❌ JoinBetView loadOddsHistory: No bet ID available")
            return 
        }
        
        print("🔍 JoinBetView loadOddsHistory: Loading odds history for bet: \(betId)")
        
        firestoreService.fetchOddsHistory(for: betId) { historyEntries in
            DispatchQueue.main.async {
                print("📊 JoinBetView loadOddsHistory: Received \(historyEntries.count) history entries")
                
                if historyEntries.isEmpty {
                    // If no real data, show sample data for demonstration
                    print("📊 JoinBetView loadOddsHistory: No real data, generating sample data")
                    self.generateSampleOddsHistory()
                } else {
                    print("📊 JoinBetView loadOddsHistory: Using real data")
                    self.oddsHistory = historyEntries
                }
                
                print("📊 JoinBetView loadOddsHistory: Final oddsHistory count: \(self.oddsHistory.count)")
            }
        }
    }
    
    private func generateSampleOddsHistory() {
        guard let betId = bet.id else { 
            print("❌ JoinBetView generateSampleOddsHistory: No bet ID available")
            return 
        }
        
        print("🔍 JoinBetView generateSampleOddsHistory: Generating sample data for bet: \(betId)")
        print("🔍 JoinBetView generateSampleOddsHistory: Bet options: \(bet.options)")
        
        var sampleHistory: [OddsHistoryEntry] = []
        let options = bet.options
        
        // Generate sample data points over the last 7 days
        for i in 0..<10 {
            let timestamp = Calendar.current.date(byAdding: .hour, value: -i * 12, to: Date()) ?? Date()
            
            var oddsByOption: [String: Double] = [:]
            var poolByOption: [String: Int] = [:]
            
            // Generate realistic odds progression
            for (index, option) in options.enumerated() {
                let baseOdds = Double(index + 1) / Double(options.count)
                let variation = sin(Double(i) * 0.5 + Double(index)) * 0.2
                let odds = max(0.1, min(0.9, baseOdds + variation))
                
                oddsByOption[option] = odds
                poolByOption[option] = Int(odds * 1000) + Int.random(in: 0...200)
            }
            
            let totalPool = poolByOption.values.reduce(0, +)
            
            let entry = OddsHistoryEntry(
                bet_id: betId,
                odds_by_option: oddsByOption,
                total_pool: totalPool,
                pool_by_option: poolByOption
            )
            
            sampleHistory.append(entry)
        }
        
        oddsHistory = sampleHistory.reversed() // Show oldest to newest
        print("✅ JoinBetView generateSampleOddsHistory: Generated \(oddsHistory.count) sample entries")
    }
    
    private func extractUsername(from email: String) -> String {
        return String(email.split(separator: "@").first ?? "Unknown")
    }
    
    private func getBetParticipants() -> [BetParticipant]? {
        return betParticipants
    }
    
    private func getOtherBets() -> [FirestoreBet]? {
        return otherBets
    }
    
    private func getCommunityName(for bet: FirestoreBet) -> String {
        if let community = firestoreService.userCommunities.first(where: { $0.id == bet.community_id }) {
            return community.name
        }
        return "Community"
    }
    
    private func getCreatorName(for bet: FirestoreBet) -> String {
        let creatorEmail = bet.creator_email
        if let currentUserEmail = firestoreService.currentUser?.email, creatorEmail == currentUserEmail {
            return "You"
        } else {
            return getUserFullName(from: creatorEmail)
        }
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, h:mm a"
        return formatter.string(from: date)
    }
    
    private func getFirstNameFromEmail(_ email: String) -> String {
        // Extract first name from email (everything before @)
        let components = email.components(separatedBy: "@")
        if let username = components.first {
            // Capitalize first letter and return
            return username.prefix(1).uppercased() + username.dropFirst()
        }
        return email
    }
    
    private func loadBetParticipants() {
        guard let betId = bet.id else { return }
        
        print("🔍 loadBetParticipants: Fetching participants for bet \(betId)")
        
        // Fetch all participants for this bet (not just current user's)
        firestoreService.fetchAllBetParticipants(for: betId) { participants in
            print("🔍 loadBetParticipants: Fetched \(participants.count) participants")
            for participant in participants {
                print("🔍 loadBetParticipants: - \(participant.user_email) bet on '\(participant.chosen_option)' for \(participant.stake_amount) points")
            }
            
            DispatchQueue.main.async {
                self.betParticipants = participants
            }
        }
    }
    
    private func loadOtherBets() {
        // Get other active bets from user's communities, excluding the current bet
        let userCommunityIds = firestoreService.userCommunities.compactMap { $0.id }
        let otherActiveBets = firestoreService.bets.filter { bet in
            guard let betId = bet.id, let currentBetId = self.bet.id else { return false }
            return betId != currentBetId && 
                   bet.status.lowercased() == "open" &&
                   userCommunityIds.contains(bet.community_id)
        }
        
        DispatchQueue.main.async {
            self.otherBets = Array(otherActiveBets.prefix(5)) // Limit to 5 bets
        }
    }
}

// MARK: - Settle Bet View
struct SettleBetView: View {
    @Environment(\.dismiss) private var dismiss
    let bet: FirestoreBet
    @ObservedObject var firestoreService: FirestoreService
    @State private var selectedOutcome = ""
    @State private var showingConfirmation = false
    @State private var isLoading = false
    
    var body: some View {
        NavigationView {
            ScrollView {
                VStack(spacing: 24) {
                    // Header
                    VStack(spacing: 12) {
                        Text("Settle Bet")
                            .font(.largeTitle)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                        
                        Text(bet.title)
                            .font(.title3)
                            .fontWeight(.semibold)
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                    }
                    .padding(.top, 20)
                    
                    // Outcome Options
                    VStack(alignment: .leading, spacing: 16) {
                        Text("Select Outcome")
                            .font(.headline)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                        
                        VStack(spacing: 12) {
                            ForEach(bet.options, id: \.self) { option in
                                Button(action: {
                                    selectedOutcome = option
                                }) {
                                    HStack {
                                        VStack(alignment: .leading, spacing: 4) {
                                            Text(option)
                                                .font(.subheadline)
                                                .fontWeight(.medium)
                                                .foregroundColor(selectedOutcome == option ? .white : .black)
                                        }
                                        
                                        Spacer()
                                        
                                        if selectedOutcome == option {
                                            Image(systemName: "checkmark.circle.fill")
                                                .foregroundColor(.white)
                                                .font(.title3)
                                        }
                                    }
                                    .padding(.horizontal, 16)
                                    .padding(.vertical, 12)
                                    .background(selectedOutcome == option ? Color.green : Color.gray.opacity(0.1))
                                    .cornerRadius(12)
                                }
                            }
                            
                            // Void Option
                            Button(action: {
                                selectedOutcome = "void"
                            }) {
                                HStack {
                                    VStack(alignment: .leading, spacing: 4) {
                                        Text("Void Market")
                                            .font(.subheadline)
                                            .fontWeight(.medium)
                                            .foregroundColor(selectedOutcome == "void" ? .white : .red)
                                        
                                        Text("Refund all participants")
                                            .font(.caption)
                                            .foregroundColor(selectedOutcome == "void" ? .white.opacity(0.8) : .gray)
                                    }
                                    
                                    Spacer()
                                    
                                    if selectedOutcome == "void" {
                                        Image(systemName: "checkmark.circle.fill")
                                            .foregroundColor(.white)
                                            .font(.title3)
                                    }
                                }
                                .padding(.horizontal, 16)
                                .padding(.vertical, 12)
                                .background(selectedOutcome == "void" ? Color.red : Color.gray.opacity(0.1))
                                .cornerRadius(12)
                            }
                        }
                    }
                    .padding(.horizontal, 20)
                    
                    // Action Button
                    Button(action: {
                        showingConfirmation = true
                    }) {
                        if isLoading {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        } else {
                            Text("Settle Bet")
                                .fontWeight(.semibold)
                        }
                    }
                    .foregroundColor(.white)
                    .padding(.horizontal, 24)
                    .padding(.vertical, 12)
                    .frame(maxWidth: .infinity)
                    .background(selectedOutcome.isEmpty ? Color.gray : Color.green)
                    .cornerRadius(10)
                    .disabled(selectedOutcome.isEmpty || isLoading)
                    .padding(.horizontal, 20)
                }
            }
            .background(Color.white)
            .navigationBarHidden(true)
            .alert("Confirm Settlement", isPresented: $showingConfirmation) {
                Button("Cancel", role: .cancel) { }
                Button("Settle") {
                    settleBet()
                }
            } message: {
                Text("Are you sure you want to settle this bet with '\(selectedOutcome)' as the outcome?")
            }
        }
    }
    
    private func settleBet() {
        guard let betId = bet.id, selectedOutcome != "void" else {
            // Handle void case separately
            return
        }
        
        isLoading = true
        
        firestoreService.settleBet(betId: betId, winnerOption: selectedOutcome) { success in
            DispatchQueue.main.async {
                isLoading = false
                if success {
                    dismiss()
                } else {
                    // Handle error - could show an alert
                    print("Error settling bet: Unknown error")
                }
            }
        }
    }
}

// MARK: - Helper Functions

func formatDate(_ date: Date) -> String {
    let formatter = DateFormatter()
    formatter.dateStyle = .medium
    formatter.timeStyle = .none
    return formatter.string(from: date)
}

func convertToNotificationItem(_ firestoreNotification: FirestoreNotification) -> NotificationItem {
        // Map icon string to system icon name
        let iconName: String
        let iconColor: Color
        
        switch firestoreNotification.icon.lowercased() {
        case "users", "person.2":
            iconName = "person.2"
            iconColor = .blue
        case "chart.line.uptrend.xyaxis":
            iconName = "chart.line.uptrend.xyaxis"
            iconColor = .purple
        case "person.2.slash":
            iconName = "person.2.slash"
            iconColor = .red
        case "checkmark.circle":
            iconName = "checkmark.circle"
            iconColor = .green
        case "xmark.circle":
            iconName = "xmark.circle"
            iconColor = .red
        case "person.badge.plus":
            iconName = "person.badge.plus"
            iconColor = .green
        case "plus.circle":
            iconName = "plus.circle"
            iconColor = .cyan // Changed from blue to cyan for "new market"
        case "bolt.fill", "bolt":
            iconName = "bolt.fill"
            iconColor = .orange
        case "bell":
            iconName = "bell"
            iconColor = .orange
        case "flag.fill", "flag":
            iconName = "flag.fill"
            iconColor = .indigo // For "bet settled" notifications
        case "exclamationmark.triangle.fill", "exclamationmark.triangle":
            iconName = "exclamationmark.triangle.fill"
            iconColor = .yellow // For "reminder" notifications
        case "trophy.fill", "trophy":
            iconName = "trophy.fill"
            iconColor = .green // For "won bet" notifications - matches activity section
        default:
            iconName = "bell"
            iconColor = .gray
        }
        
        // Format timestamp
        let formatter = DateFormatter()
        formatter.dateStyle = .none
        formatter.timeStyle = .short
        let timestamp = formatter.string(from: firestoreNotification.created_date)
        
        return NotificationItem(
            id: firestoreNotification.id,
            icon: iconName,
            iconColor: iconColor,
            text: firestoreNotification.message,
            timestamp: timestamp,
            isUnread: !firestoreNotification.is_read,
            communityName: firestoreNotification.community_name,
            communityIcon: firestoreNotification.community_icon
        )
}

// MARK: - Betting Interface View

struct BettingInterfaceView: View {
    @Environment(\.dismiss) private var dismiss
    let bet: FirestoreBet
    @State private var selectedOption: String
    @ObservedObject var firestoreService: FirestoreService
    let onBetPlaced: (() -> Void)? // Callback when bet is successfully placed
    @State private var betAmount = ""
    @State private var isLoading = false
    @State private var showingOptionPicker = false
    @State private var showSuccess = false
    @State private var showError = false
    @State private var errorMessage = ""
    @State private var userFullNames: [String: String] = [:]
    
    // Pre-set bet amounts
    private let presetAmounts = [10, 25, 50, 100]
    
    // Computed properties for validation
    private var currentBalance: Int {
        firestoreService.currentUser?.blitz_points ?? 0
    }
    
    private var betAmountDouble: Double {
        Double(betAmount) ?? 0
    }
    
    private var hasInsufficientFunds: Bool {
        betAmountDouble > Double(currentBalance)
    }
    
    private var canProceed: Bool {
        !betAmount.isEmpty && betAmountDouble > 0 && !hasInsufficientFunds
    }
    
    // Calculate total potential payout using proportional distribution
    private var potentialWinnings: Double {
        if let amount = Double(betAmount), amount > 0 {
            let impliedOdds = firestoreService.calculateImpliedOdds(for: bet)
            let optionImpliedOdds = impliedOdds[selectedOption] ?? 0.5
            
            // Calculate potential payout based on current pool distribution
            if let poolByOption = bet.pool_by_option,
               let totalPool = bet.total_pool,
               totalPool > 0 {
                let currentOptionPool = poolByOption[selectedOption] ?? 0
                let otherOptionsPool = totalPool - currentOptionPool
                
                if currentOptionPool > 0 && otherOptionsPool > 0 {
                    // Proportional payout: stake back + share of losing pool
                    // Assuming user's bet would be added to the current option pool
                    let projectedWinningPool = currentOptionPool + Int(amount)
                    let userShareOfWinnings = (amount / Double(projectedWinningPool)) * Double(otherOptionsPool)
                    return amount + userShareOfWinnings // Stake back + winnings
                } else if otherOptionsPool > 0 {
                    // If no one has bet on this option yet, they'd get all the losing pool
                    return amount + Double(otherOptionsPool)
                } else {
                    // If no opposing bets, just get stake back (or use implied odds for estimate)
                    return amount / optionImpliedOdds
                }
            } else {
                // Fallback to implied odds calculation
                return amount / optionImpliedOdds
            }
        }
        return 0
    }
    
    // Number formatter for adding commas and ensuring 2 decimal places
    private var numberFormatter: NumberFormatter {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.minimumFractionDigits = 2
        formatter.maximumFractionDigits = 2
        return formatter
    }
    
    // Initialize with selected option
    init(bet: FirestoreBet, selectedOption: String, firestoreService: FirestoreService, onBetPlaced: (() -> Void)? = nil) {
        self.bet = bet
        
        // 🐛 DEBUG: BettingInterfaceView Initializer - COMPREHENSIVE
        print("🎯 BETTING_INTERFACE_INIT: ===== INITIALIZER DEBUG START =====")
        print("🎯 BETTING_INTERFACE_INIT: Received selectedOption: '\(selectedOption)'")
        print("🎯 BETTING_INTERFACE_INIT: selectedOption.isEmpty: \(selectedOption.isEmpty)")
        print("🎯 BETTING_INTERFACE_INIT: selectedOption.count: \(selectedOption.count)")
        print("🎯 BETTING_INTERFACE_INIT: Bet ID: \(bet.id ?? "nil")")
        print("🎯 BETTING_INTERFACE_INIT: Bet title: '\(bet.title)'")
        print("🎯 BETTING_INTERFACE_INIT: Bet options: \(bet.options)")
        print("🎯 BETTING_INTERFACE_INIT: bet.options.first: '\(bet.options.first ?? "nil")'")
        
        // Ensure we have a valid selectedOption, fallback to first option if empty
        let validOption = selectedOption.isEmpty ? (bet.options.first ?? "Yes") : selectedOption
        
        print("🎯 BETTING_INTERFACE_INIT: validOption after fallback logic: '\(validOption)'")
        print("🎯 BETTING_INTERFACE_INIT: ===== INITIALIZER DEBUG END =====")
        
        self._selectedOption = State(initialValue: validOption)
        self.firestoreService = firestoreService
        self.onBetPlaced = onBetPlaced
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Simple Header
                HStack {
                    Button(action: {
                        dismiss()
                    }) {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.black)
                    }
                    
                    Spacer()
                }
                .padding(.horizontal, 20)
                .padding(.top, 16)
                
                // Event/Question Section
                eventQuestionSection
                .padding(.horizontal, 20)
                .padding(.top, 20)
                
                Spacer()
                
                // Large Amount Display
                    VStack(spacing: 8) {
                    HStack(alignment: .top, spacing: 8) {
                        Image(systemName: "bolt.fill")
                            .font(.system(size: 40))
                            .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                        
                        Text(betAmount.isEmpty ? "0.00" : (numberFormatter.string(from: NSNumber(value: Double(betAmount) ?? 0)) ?? String(format: "%.2f", Double(betAmount) ?? 0)))
                            .font(.system(size: 80, weight: .bold, design: .default))
                            .foregroundColor(.black)
                    }
                        
                    HStack(spacing: 4) {
                        Text("Available:")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                        
                        Image(systemName: "bolt.fill")
                            .font(.subheadline)
                            .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                        
                        Text(numberFormatter.string(from: NSNumber(value: Double(currentBalance))) ?? String(format: "%.2f", Double(currentBalance)))
                                .font(.subheadline)
                        .foregroundColor(.gray)
                    }
                }
                .padding(.vertical, 40)
                
                // Error message for insufficient funds
                if hasInsufficientFunds {
                    HStack(spacing: 8) {
                        Image(systemName: "exclamationmark.triangle.fill")
                            .foregroundColor(.red)
                        Text("Insufficient Sling Points. You have \(String(format: "%.2f", Double(currentBalance))) points.")
                            .font(.caption)
                            .foregroundColor(.red)
                    }
                    .padding(.horizontal, 20)
                    .padding(.bottom, 16)
                }
                    
                // Fixed height container for preset buttons or submit button
                bettingActionSection
                    .padding(.horizontal, 20)
                    .padding(.bottom, 20)
                
                // Simple Numeric Keypad
                VStack(spacing: 12) {
                    HStack(spacing: 12) {
                        ForEach(1...3, id: \.self) { number in
                            SimpleKeypadButton(number: "\(number)", action: { appendToBetAmount("\(number)") })
                        }
                    }
                    
                    HStack(spacing: 12) {
                        ForEach(4...6, id: \.self) { number in
                            SimpleKeypadButton(number: "\(number)", action: { appendToBetAmount("\(number)") })
                        }
                    }
                    
                    HStack(spacing: 12) {
                        ForEach(7...9, id: \.self) { number in
                            SimpleKeypadButton(number: "\(number)", action: { appendToBetAmount("\(number)") })
                        }
                    }
                    
                    HStack(spacing: 12) {
                        SimpleKeypadButton(number: ".", action: { appendToBetAmount(".") })
                        SimpleKeypadButton(number: "0", action: { appendToBetAmount("0") })
                        Button(action: { deleteLastCharacter() }) {
                            Image(systemName: "delete.left")
                                .font(.title2)
                                .foregroundColor(.black)
                                .frame(maxWidth: .infinity)
                                .frame(height: 60)
                                .background(Color.white)
                        }
                    }
                }
                .padding(.horizontal, 20)
                .padding(.bottom, 40)
            }
            .background(Color.white)
            .navigationBarHidden(true)
            .alert("Error", isPresented: $showError) {
                Button("OK") { }
            } message: {
                Text(errorMessage)
            }
            .actionSheet(isPresented: $showingOptionPicker) {
                ActionSheet(
                    title: Text("Choose Your Bet"),
                    buttons: bet.options.map { option in
                        let impliedOdds = firestoreService.calculateImpliedOdds(for: bet)[option] ?? 0.5
                        let formattedOdds = firestoreService.formatImpliedOdds(impliedOdds)
                        return .default(Text("\(option) (\(formattedOdds))")) {
                            // 🐛 DEBUG: Option Picker Selection
                            print("🎯 OPTION_PICKER: User selected option from picker: '\(option)'")
                            print("🎯 OPTION_PICKER: Previous selectedOption: '\(selectedOption)'")
                            print("🎯 OPTION_PICKER: Bet ID: \(bet.id ?? "nil")")
                            print("🎯 OPTION_PICKER: Bet title: '\(bet.title)'")
                            print("🎯 OPTION_PICKER: ==========================================")
                            selectedOption = option
                        }
                    } + [.cancel()]
                )
            }
        }
        .onAppear {
            // 🐛 DEBUG: BettingInterfaceView onAppear - COMPREHENSIVE
            print("🎯 BETTING_INTERFACE_ONAPPEAR: ===== ON_APPEAR DEBUG START =====")
            print("🎯 BETTING_INTERFACE_ONAPPEAR: BettingInterfaceView appeared")
            print("🎯 BETTING_INTERFACE_ONAPPEAR: Current selectedOption: '\(selectedOption)'")
            print("🎯 BETTING_INTERFACE_ONAPPEAR: selectedOption.isEmpty: \(selectedOption.isEmpty)")
            print("🎯 BETTING_INTERFACE_ONAPPEAR: selectedOption.count: \(selectedOption.count)")
            print("🎯 BETTING_INTERFACE_ONAPPEAR: Bet ID: \(bet.id ?? "nil")")
            print("🎯 BETTING_INTERFACE_ONAPPEAR: Bet title: '\(bet.title)'")
            print("🎯 BETTING_INTERFACE_ONAPPEAR: All bet options: \(bet.options)")
            print("🎯 BETTING_INTERFACE_ONAPPEAR: bet.options.first: '\(bet.options.first ?? "nil")'")
            print("🎯 BETTING_INTERFACE_ONAPPEAR: ===== ON_APPEAR DEBUG END =====")
        }
    }
    
    private func extractUsername(from email: String) -> String {
        return String(email.split(separator: "@").first ?? "Unknown")
    }
    
    // Function to get user's full name, with caching
    private func getUserFullName(from email: String) -> String {
        // Check cache first
        if let cachedName = userFullNames[email] {
            return cachedName
        }
        
        // For current user, use local data
        if let user = firestoreService.currentUser, user.email == email {
            let fullName = "\(user.first_name ?? "") \(user.last_name ?? "")".trimmingCharacters(in: .whitespaces)
            userFullNames[email] = fullName
            return fullName
        }
        
        // For other users, fetch from Firestore and cache
        firestoreService.getUserDetails(email: email) { fullName, _ in
            DispatchQueue.main.async {
                self.userFullNames[email] = fullName
            }
        }
        
        // Return first name as fallback while fetching
        return email.components(separatedBy: "@").first ?? email
    }
    
    private func appendToBetAmount(_ character: String) {
        // Add haptic feedback
        let impactFeedback = UIImpactFeedbackGenerator(style: .light)
        impactFeedback.impactOccurred()
        
        if character == "." {
            if !betAmount.contains(".") {
                betAmount += character
            }
        } else {
            betAmount += character
        }
    }
    
    private func deleteLastCharacter() {
        if !betAmount.isEmpty {
            // Add haptic feedback
            let impactFeedback = UIImpactFeedbackGenerator(style: .light)
            impactFeedback.impactOccurred()
            
            betAmount.removeLast()
        }
    }
    
    private func calculatePayout(amount: Double, odds: String) -> Double {
        // Simple payout calculation based on American odds
        if odds.hasPrefix("-") {
            // Negative odds (favorite)
            let oddsValue = Double(odds.dropFirst()) ?? 110
            return amount * (100 / oddsValue) + amount
        } else {
            // Positive odds (underdog)
            let oddsValue = Double(odds) ?? 110
            return amount * (oddsValue / 100) + amount
        }
    }
    
    private func confirmBet() {
        // 🐛 DEBUG: Bet Confirmation
        print("🎯 CONFIRM_BET: confirmBet called")
        print("🎯 CONFIRM_BET: betAmount: \(betAmount)")
        print("🎯 CONFIRM_BET: selectedOption: '\(selectedOption)'")
        print("🎯 CONFIRM_BET: bet.id: \(bet.id ?? "nil")")
        print("🎯 CONFIRM_BET: bet.title: '\(bet.title)'")
        print("🎯 CONFIRM_BET: All bet options: \(bet.options)")
        print("🎯 CONFIRM_BET: About to place bet on option: '\(selectedOption)'")
        print("🎯 CONFIRM_BET: ==========================================")
        
        guard let betAmountDouble = Double(betAmount), betAmountDouble > 0,
              let betId = bet.id else { 
            print("❌ Invalid bet data - betAmountDouble: \(Double(betAmount) ?? 0), betId: \(bet.id ?? "nil")")
            return 
        }
        
        print("✅ Valid bet data - betAmountDouble: \(betAmountDouble), betId: \(betId)")
        
        isLoading = true
        errorMessage = ""
        
        firestoreService.joinBet(
            betId: betId,
            chosenOption: selectedOption,
            stakeAmount: Int(betAmountDouble)
        ) { success, error in
            DispatchQueue.main.async {
                isLoading = false
                if success {
                    print("✅ Bet placed successfully")
                    showSuccess = true
                    firestoreService.refreshCurrentUser()
                    
                    // Call the callback to notify parent (e.g., switch to My Bets tab)
                    self.onBetPlaced?()
                    
                    // Auto-dismiss after 1 second (faster)
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                        dismiss()
                    }
                } else {
                    print("❌ Failed to place bet: \(error ?? "Unknown error")")
                    errorMessage = error ?? "Failed to place bet. Please try again."
                    showError = true
                }
            }
        }
    }
    
    @ViewBuilder
    private var eventQuestionSection: some View {
        HStack(spacing: 12) {
            // Profile picture with actual image
            AsyncImage(url: URL(string: bet.image_url ?? "")) { image in
                image
                    .resizable()
                    .aspectRatio(contentMode: .fill)
            } placeholder: {
                Rectangle()
                    .fill(Color.gray.opacity(0.3))
            }
            .frame(width: 50, height: 50)
            .clipShape(RoundedRectangle(cornerRadius: 8))
            
            VStack(alignment: .leading, spacing: 4) {
                Text(bet.title)
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                    .multilineTextAlignment(.leading)
                    .lineLimit(2)
                
                HStack(spacing: 4) {
                    Image(systemName: "person.2")
                        .font(.caption)
                        .foregroundColor(.gray)
                    
                    if let community = firestoreService.userCommunities.first(where: { $0.id == bet.community_id }) {
                        Text(community.name)
                            .font(.caption)
                            .foregroundColor(.gray)
                    }
                    
                    Text("• by \(getUserFullName(from: bet.creator_email))")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                
                Button(action: {
                    showingOptionPicker = true
                }) {
                    HStack(spacing: 8) {
                        Text("Your choice:")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                        
                        Text("\(selectedOption)")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                        
                        Text(firestoreService.formatImpliedOdds(firestoreService.calculateImpliedOdds(for: bet)[selectedOption] ?? 0.5))
                            .font(.subheadline)
                            .foregroundColor(.black)
                        
                        Image(systemName: "chevron.down")
                            .font(.caption)
                            .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                    }
                }
                .buttonStyle(.plain)
            }
            
            Spacer()
        }
    }
    
    @ViewBuilder
    private var bettingActionSection: some View {
        VStack {
            // Preset Amount Buttons (2x2 grid) - show when amount is 0
            if betAmountDouble == 0 {
                VStack(spacing: 12) {
                    HStack(spacing: 12) {
                        ForEach([10, 25], id: \.self) { amount in
                            Button(action: {
                                betAmount = "\(amount)"
                            }) {
                                HStack(spacing: 4) {
                                    Image(systemName: "bolt.fill")
                                        .font(.caption)
                                        .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                                    Text("\(amount)")
                                        .font(.subheadline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                                }
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 12)
                                .background(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                        .background(Color.white)
                                )
                            }
                        }
                    }
                    
                    HStack(spacing: 12) {
                        ForEach([50, 100], id: \.self) { amount in
                            Button(action: {
                                betAmount = "\(amount)"
                            }) {
                                HStack(spacing: 4) {
                                    Image(systemName: "bolt.fill")
                                        .font(.caption)
                                        .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                                    Text("\(amount)")
                                        .font(.subheadline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(Color(uiColor: UIColor(red: 0x26/255, green: 0x63/255, blue: 0xEB/255, alpha: 1.0)))
                                }
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 12)
                                .background(
                                    RoundedRectangle(cornerRadius: 8)
                                        .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                        .background(Color.white)
                                )
                            }
                        }
                    }
                }
            } else if betAmountDouble > 0 && canProceed {
                // Submit Button (shows winnings when amount entered)
                Button(action: {
                    confirmBet()
                }) {
                    VStack(spacing: 4) {
                        if isLoading {
                            HStack {
                                ProgressView()
                                    .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                    .scaleEffect(0.8)
                                
                                Text("Placing Bet...")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.white)
                            }
                        } else if showSuccess {
                                HStack {
                                    Image(systemName: "checkmark.circle.fill")
                                        .font(.headline)
                                        .foregroundColor(.white)
                                    Text("Bet Placed!")
                                        .font(.headline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(.white)
                                }
                        } else {
                                Text("Submit Bet")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.white)
                                
                                HStack(spacing: 4) {
                                    Text("Total Payout:")
                                        .font(.subheadline)
                                        .foregroundColor(.white.opacity(0.8))
                                    
                                    Image(systemName: "bolt.fill")
                                        .font(.caption)
                                        .foregroundColor(.white)
                                    
                                    Text(numberFormatter.string(from: NSNumber(value: potentialWinnings)) ?? String(format: "%.2f", potentialWinnings))
                                        .font(.subheadline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(.white)
                                }
                            }
                        }
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 16)
                        .background(
                            RoundedRectangle(cornerRadius: 12)
                                .fill(showSuccess ? AnyShapeStyle(Color.green) : (isLoading ? AnyShapeStyle(Color.gray) : AnyShapeStyle(Color.slingGradient)))
                        )
                    }
                    .disabled(!canProceed || isLoading || showSuccess)
                } else {
                    // Empty placeholder to maintain consistent height when amount is invalid
                    Color.clear
                        .frame(height: 76) // Same height as preset button rows
                }
            }
            .frame(height: 76) // Fixed height container
        }
    }

// MARK: - Simple Keypad Button

struct SimpleKeypadButton: View {
    let number: String
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            Text(number)
                .font(.system(size: 28, weight: .medium, design: .default))
                .foregroundColor(.black)
                .frame(maxWidth: .infinity)
                .frame(height: 60)
                .background(Color.white)
        }
        .buttonStyle(PlainButtonStyle())
    }
}


// MARK: - Bet Review View

struct BetReviewView: View {
    @Environment(\.dismiss) private var dismiss
    let bet: FirestoreBet
    let selectedOption: String
    let betAmount: String
    let firestoreService: FirestoreService
    let onConfirm: () -> Void
    @State private var isLoading = false
    @State private var showSuccess = false
    @State private var showError = false
    @State private var errorMessage = ""
    
    var body: some View {
        NavigationView {
            VStack(spacing: 24) {
                // Header
                VStack(spacing: 8) {
                    Text("Review Your Bet")
                        .font(.largeTitle)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Text("Double-check your bet before confirming")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                }
                .padding(.top, 20)
                
                // Bet Details Card
                VStack(spacing: 20) {
                    // Event details
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Event")
                            .font(.caption)
                            .foregroundColor(.gray)
                            .textCase(.uppercase)
                        
                        Text(bet.title)
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                    
                    Divider()
                    
                    // Your pick
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Your Pick")
                            .font(.caption)
                            .foregroundColor(.gray)
                            .textCase(.uppercase)
                        
                        HStack {
                            Text(selectedOption)
                                .font(.headline)
                                .fontWeight(.semibold)
                                .foregroundColor(.black)
                            
                            Spacer()
                            
                            Text(firestoreService.formatImpliedOdds(firestoreService.calculateImpliedOdds(for: bet)[selectedOption] ?? 0.5))
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                    
                    Divider()
                    
                    // Bet amount
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Bet Amount")
                            .font(.caption)
                            .foregroundColor(.gray)
                            .textCase(.uppercase)
                        
                        HStack {
                            HStack(spacing: 4) {
                                Image(systemName: "bolt.fill")
                                    .font(.subheadline)
                                    .foregroundColor(.yellow)
                                Text(betAmount)
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                            }
                            
                            Spacer()
                            
                            if let betAmountDouble = Double(betAmount), betAmountDouble > 0 {
                                let payout = calculatePayout(amount: betAmountDouble, odds: firestoreService.formatImpliedOdds(firestoreService.calculateImpliedOdds(for: bet)[selectedOption] ?? 0.5))
                                Text("Payout: \(String(format: "%.0f", payout))")
                                    .font(.subheadline)
                                    .foregroundColor(.green)
                            }
                        }
                    }
                    .frame(maxWidth: .infinity, alignment: .leading)
                }
                .padding(20)
                .background(Color.white)
                .cornerRadius(16)
                .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
                .padding(.horizontal, 20)
                
                Spacer()
                
                // Action buttons
                VStack(spacing: 12) {
                    Button(action: {
                        confirmBet()
                    }) {
                        if isLoading {
                            ProgressView()
                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        } else if showSuccess {
                            HStack(spacing: 8) {
                                Image(systemName: "checkmark.circle.fill")
                                    .foregroundColor(.white)
                                Text("Bet Placed!")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.white)
                            }
                        } else {
                            Text("Confirm Bet")
                                .font(.headline)
                                .fontWeight(.semibold)
                                .foregroundColor(.white)
                        }
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 16)
                    .background(showSuccess ? AnyShapeStyle(Color.green) : (isLoading ? AnyShapeStyle(Color.gray) : AnyShapeStyle(Color.slingGradient)))
                    .cornerRadius(12)
                    .disabled(isLoading || showSuccess)
                    .opacity(isLoading || showSuccess ? 0.6 : 1.0)
                    
                    if !showSuccess {
                        Button(action: {
                            dismiss()
                        }) {
                            Text("Back to Edit")
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.gray)
                        }
                    }
                }
                .padding(.horizontal, 20)
                .padding(.bottom, 20)
            }
            .background(Color.white)
            .navigationBarHidden(true)
            .alert("Error", isPresented: $showError) {
                Button("OK") { }
            } message: {
                Text(errorMessage)
            }
        }
    }
    
    private func confirmBet() {
        // 🐛 DEBUG: Bet Confirmation
        print("🎯 CONFIRM_BET: confirmBet called")
        print("🎯 CONFIRM_BET: betAmount: \(betAmount)")
        print("🎯 CONFIRM_BET: selectedOption: '\(selectedOption)'")
        print("🎯 CONFIRM_BET: bet.id: \(bet.id ?? "nil")")
        print("🎯 CONFIRM_BET: bet.title: '\(bet.title)'")
        print("🎯 CONFIRM_BET: All bet options: \(bet.options)")
        print("🎯 CONFIRM_BET: About to place bet on option: '\(selectedOption)'")
        print("🎯 CONFIRM_BET: ==========================================")
        
        guard let betAmountDouble = Double(betAmount), betAmountDouble > 0,
              let betId = bet.id else { 
            print("❌ Invalid bet data - betAmountDouble: \(Double(betAmount) ?? 0), betId: \(bet.id ?? "nil")")
            return 
        }
        
        print("✅ Valid bet data - betAmountDouble: \(betAmountDouble), betId: \(betId)")
        print("💰 Stake amount (points): \(Int(betAmountDouble))")
        
        isLoading = true
        
        // Add a timeout to prevent getting stuck
        var timeoutTask: DispatchWorkItem?
        timeoutTask = DispatchWorkItem {
            if isLoading {
                
                print("⏰ Timeout reached - resetting loading state")
                isLoading = false
                errorMessage = "Request timed out. Please try again."
                showError = true
            }
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 30, execute: timeoutTask!)
        
        firestoreService.joinBet(
            betId: betId,
            chosenOption: selectedOption,
            stakeAmount: Int(betAmountDouble) // Use points directly, not cents
        ) { success, error in
            DispatchQueue.main.async {
                // Cancel timeout task
                timeoutTask?.cancel()
                isLoading = false
                if success {
                    print("✅ Bet placed successfully!")
                    showSuccess = true
                    // Dismiss after a short delay to show success message
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                        print("🎉 Calling onConfirm and dismiss")
                        onConfirm()
                        dismiss()
                    }
                } else {
                    // Handle error - show alert to user
                    print("❌ Error placing bet: \(error ?? "Unknown error")")
                    errorMessage = error ?? "Unknown error occurred while placing your bet"
                    showError = true
                }
            }
        }
    }
    
    private func calculatePayout(amount: Double, odds: String) -> Double {
        // Simple payout calculation based on American odds
        if odds.hasPrefix("-") {
            // Negative odds (favorite)
            let oddsValue = Double(odds.dropFirst()) ?? 110
            return amount * (100 / oddsValue) + amount
        } else {
            // Positive odds (underdog)
            let oddsValue = Double(odds) ?? 110
            return amount * (oddsValue / 100) + amount
        }
    }
}

// MARK: - Enhanced Bet Card (handles all user states)

// MARK: - Swipeable Bet Card with Modern Design
struct SwipeableBetCard: View {
    // MARK: - Properties
    let bet: FirestoreBet
    let currentUserEmail: String?
    @ObservedObject private var firestoreService: FirestoreService
    
    // MARK: - State
    @State private var offset: CGFloat = 0
    @State private var showingCancelAlert = false
    @State private var showingChooseWinnerSheet = false
    @State private var showingPlaceBetSheet = false
    @State private var showingDeleteAlert = false
    @State private var showingShareSheet = false
    @State private var showingBetDetail = false
    @State private var showingBettingInterface = false
    @State private var selectedBettingOption = ""
    @State private var showingCommunityDetails = false
    @State private var userBets: [BetParticipant] = []
    @State private var hasUserParticipated: Bool = false
    @State private var hasAnyBets: Bool = false
    @State private var hasRemindedCreator = false
    @State private var optionCounts: [String: Int] = [:]
    @State private var creatorName: String = ""
    @State private var userFullNames: [String: String] = [:]
    
    // MARK: - Constants
    private let swipeThreshold: CGFloat = 80
    private let maxSwipeDistance: CGFloat = 240
    
    // MARK: - Initialization
    init(bet: FirestoreBet,
         currentUserEmail: String?,
         firestoreService: FirestoreService)
    {
        self.bet = bet
        self.currentUserEmail = currentUserEmail
        self._firestoreService = ObservedObject(wrappedValue: firestoreService)
    }
    
    // MARK: - Computed Properties
    private var communityName: String {
        if let community = firestoreService.userCommunities.first(where: { $0.id == bet.community_id }) {
            return community.name
        }
        return "Community"
    }
    
    private var isCreator: Bool {
        return currentUserEmail == bet.creator_email
    }
    
    private var userParticipation: BetParticipant? {
        return firestoreService.userBetParticipations.first { participation in
            participation.bet_id == bet.id && participation.user_email == currentUserEmail
        }
    }
    
    private var hasWager: Bool {
        return userParticipation != nil
    }
    
    private var formattedClosingDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d 'at' h:mm a"
        return formatter.string(from: bet.deadline)
    }
    
    private var timeUntilDeadline: String {
        let now = Date()
        let timeInterval = bet.deadline.timeIntervalSince(now)
        
        if timeInterval <= 0 {
            return "Closed"
        } else if timeInterval < 3600 { // Less than 1 hour
            let minutes = Int(timeInterval / 60)
            return "\(minutes)m left"
        } else if timeInterval < 86400 { // Less than 24 hours
            let hours = Int(timeInterval / 3600)
            return "\(hours)h left"
        } else {
            let days = Int(timeInterval / 86400)
            return "\(days)d left"
        }
    }
    
    // Helper function to get creator initials
    private func getCreatorInitials() -> String {
        if isCreator {
            return getCurrentUserInitials()
        } else {
            return getOtherCreatorInitials()
        }
    }
    
    private func getCurrentUserInitials() -> String {
        let user = firestoreService.currentUser
        if let firstName = user?.first_name, let lastName = user?.last_name, !firstName.isEmpty, !lastName.isEmpty {
            let firstInitial = String(firstName.prefix(1)).uppercased()
            let lastInitial = String(lastName.prefix(1)).uppercased()
            return "\(firstInitial)\(lastInitial)"
        } else if let displayName = user?.display_name, !displayName.isEmpty {
            let components = displayName.components(separatedBy: " ")
            if components.count >= 2 {
                let firstInitial = String(components[0].prefix(1)).uppercased()
                let lastInitial = String(components[1].prefix(1)).uppercased()
                return "\(firstInitial)\(lastInitial)"
            } else if components.count == 1 {
                return String(components[0].prefix(1)).uppercased()
            }
        } else if let email = user?.email {
            return String(email.prefix(1)).uppercased()
        }
        return "U"
    }
    
    private func getOtherCreatorInitials() -> String {
        if !creatorName.isEmpty && creatorName != "You" {
            let components = creatorName.components(separatedBy: " ")
            if components.count >= 2 {
                let firstInitial = String(components[0].prefix(1)).uppercased()
                let lastInitial = String(components[1].prefix(1)).uppercased()
                return "\(firstInitial)\(lastInitial)"
            } else if components.count == 1 {
                return String(components[0].prefix(1)).uppercased()
            }
        }
        // Fallback to email initial
        return String(bet.creator_email.prefix(1)).uppercased()
    }
    
    // MARK: - Body
    var body: some View {
        ZStack {
            // Background action buttons - only show when swiped
            if offset < 0 {
                HStack {
                    Spacer()
                    actionButtonsView
                }
            }
            
            // Main card content with new design matching the image
            VStack(alignment: .leading, spacing: 12) {
                // Header with profile picture and question
                Button(action: {
                    showingBetDetail = true
                }) {
                    HStack(alignment: .top, spacing: 12) {
                        // Profile Picture
                        Circle()
                            .fill(Color.slingGradient)
                            .frame(width: 40, height: 40)
                            .overlay(
                                Text(getCreatorInitials())
                                    .font(.subheadline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.white)
                            )
                        
                        VStack(alignment: .leading, spacing: 8) {
                            // Question title with creator pill on the right
                            HStack(alignment: .top) {
                                Text(bet.title)
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                    .multilineTextAlignment(.leading)
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                
                                // Creator crown pill for creators (top right)
                                if isCreator {
                                    HStack(spacing: 4) {
                                        Image(systemName: "crown.fill")
                                            .font(.caption)
                                            .foregroundColor(.purple)
                                        Text("Creator")
                                            .font(.caption)
                                            .fontWeight(.medium)
                                            .foregroundColor(.purple)
                                    }
                                    .padding(.horizontal, 6)
                                    .padding(.vertical, 2)
                                    .background(Color.purple.opacity(0.1))
                                    .cornerRadius(6)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 6)
                                            .stroke(Color.purple, lineWidth: 0.5)
                                    )
                                }
                            }
                            
                            // Community and creator info
                            HStack(spacing: 4) {
                                Image(systemName: "person.2")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                                
                                Text("\(communityName) • by \(isCreator ? "You" : (creatorName.isEmpty ? getUserFullName(from: bet.creator_email) : creatorName))")
                                    .font(.subheadline)
                                    .foregroundColor(.gray)
                                
                                Spacer()
                            }
                        }
                    }
                }
                .buttonStyle(PlainButtonStyle())
                
                // Betting deadline
                Button(action: {
                    showingBetDetail = true
                }) {
                    Text("Betting closes: \(formattedClosingDate)")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                        .frame(maxWidth: .infinity, alignment: .leading)
                }
                .buttonStyle(PlainButtonStyle())
                
                // User's pick and wager section (always present to maintain consistent card size)
                if hasWager, let participation = userParticipation {
                    Button(action: {
                        showingBetDetail = true
                    }) {
                        HStack(alignment: .top) {
                            // Left side - You Picked
                            VStack(alignment: .leading, spacing: 4) {
                                Text("You Picked")
                                    .font(.subheadline)
                                    .foregroundColor(.gray)
                                
                                // Option with odds
                                let optionOdds = firestoreService.formatImpliedOdds(firestoreService.calculateImpliedOdds(for: bet)[participation.chosen_option] ?? 0.5)
                                Text("\(participation.chosen_option) \(optionOdds)")
                                    .font(.title2)
                                    .fontWeight(.bold)
                                    .foregroundColor(.black)
                            }
                            
                            Spacer()
                            
                            // Right side - Wager
                            VStack(alignment: .trailing, spacing: 4) {
                                Text("Wager")
                                    .font(.subheadline)
                                    .foregroundColor(.gray)
                                
                                HStack(spacing: 4) {
                                    Image(systemName: "bolt.fill")
                                        .font(.title2)
                                        .foregroundColor(.blue)
                                    Text(String(format: "%.2f", Double(participation.stake_amount)))
                                        .font(.title2)
                                        .fontWeight(.bold)
                                        .foregroundColor(.blue)
                                }
                            }
                        }
                        .padding(16)
                        .background(Color.gray.opacity(0.1))
                        .cornerRadius(12)
                    }
                    .buttonStyle(PlainButtonStyle())
                } else {
                    // Empty space with same height to maintain consistent card size
                    VStack {
                        Spacer()
                    }
                    .frame(height: 88) // Same height as the wager section above
                }
            }
            .padding(16)
            .background(Color.white)
            .cornerRadius(16)
            .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
            .offset(x: offset)
            .onTapGesture {
                // Only handle tap if card is not swiped
                if offset != 0 {
                    // Reset swipe when tapping on the card
                    withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                        offset = 0
                    }
                }
            }
            .gesture(
                DragGesture()
                    .onChanged { value in
                        let translation = value.translation.width
                        if translation < 0 { // Only allow left swipe
                            offset = max(translation, -maxSwipeDistance)
                        } else if offset < 0 { // Allow right swipe only if already swiped left
                            offset = min(offset + translation, 0)
                        }
                    }
                    .onEnded { value in
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                            if offset < -swipeThreshold {
                                offset = -240 // Show all three actions
                            } else {
                                offset = 0 // Hide actions
                            }
                        }
                    }
            )
        }
        .clipped()
        .onAppear {
            loadUserParticipation()
            loadBetStatus()
            loadCreatorName()
        }
        .sheet(isPresented: $showingChooseWinnerSheet) {
            ChooseWinnerView(bet: bet, firestoreService: firestoreService)
        }
        .sheet(isPresented: $showingPlaceBetSheet) {
            PlaceBetView(bet: bet, presetOption: nil, firestoreService: firestoreService, onBetPlaced: nil)
        }
        .sheet(isPresented: $showingShareSheet) {
            ShareSheet(activityItems: [generateShareText()])
        }
        .sheet(isPresented: $showingBetDetail) {
            JoinBetView(
                bet: bet, 
                firestoreService: firestoreService,
                onCommunityTap: {
                    // Navigate to community details
                    // This will be handled by the parent view
                }
            )
        }
        .sheet(isPresented: $showingBettingInterface) {
            if !selectedBettingOption.isEmpty {
                BettingInterfaceView(
                    bet: bet,
                    selectedOption: selectedBettingOption,
                    firestoreService: firestoreService,
                    onBetPlaced: nil
                )
            }
        }
        .sheet(isPresented: $showingCommunityDetails) {
            if let community = firestoreService.userCommunities.first(where: { $0.id == bet.community_id }) {
                EnhancedCommunityDetailView(
                    community: community, 
                    firestoreService: firestoreService,
                    onChatTap: {
                        // Navigate to chat for this community
                        // This will be handled by the parent view
                    }
                )
            }
        }
        .alert("Cancel Market", isPresented: $showingDeleteAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Delete Market", role: .destructive) {
                deleteMarket()
            }
        } message: {
            Text("Are you sure you want to delete this market? This action cannot be undone.")
        }
        .alert("Cancel Bet", isPresented: $showingCancelAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Cancel Bet", role: .destructive) {
                cancelBet()
            }
        } message: {
            Text("Are you sure you want to cancel your bet? Your wager will be returned.")
        }
    }
    
    // MARK: - Action Buttons View
    @ViewBuilder
    private var actionButtonsView: some View {
        HStack(spacing: 0) {
            if isCreator {
                // Creator actions: Share, Settle Bet, Delete Market
                
                // Share button
                Button(action: {
                    withAnimation { offset = 0 }
                    showingShareSheet = true
                }) {
                    VStack(spacing: 4) {
                        Image(systemName: "square.and.arrow.up")
                            .font(.title2)
                        Text("Share")
                            .font(.caption2)
                    }
                    .foregroundColor(.white)
                    .frame(width: 80)
                    .frame(maxHeight: .infinity)
                    .background(Color.gray)
                    .cornerRadius(0)
                }
                
                // Settle bet button
                Button(action: {
                    withAnimation { offset = 0 }
                    showingChooseWinnerSheet = true
                }) {
                    VStack(spacing: 4) {
                        Image(systemName: "trophy.fill")
                            .font(.title2)
                        Text("Settle")
                            .font(.caption2)
                    }
                    .foregroundColor(.white)
                    .frame(width: 80)
                    .frame(maxHeight: .infinity)
                    .background(Color.slingGradient)
                    .cornerRadius(0)
                }
                
                // Delete market button
                Button(action: {
                    withAnimation { offset = 0 }
                    showingDeleteAlert = true
                }) {
                    VStack(spacing: 4) {
                        Image(systemName: "trash.fill")
                            .font(.title2)
                        Text("Trash")
                            .font(.caption2)
                    }
                    .foregroundColor(.white)
                    .frame(width: 80)
                    .frame(maxHeight: .infinity)
                    .background(Color.red)
                    .cornerRadius(0)
                }
                
            } else {
                // Participant actions: Remind Creator, Delete Bet, Share
                
                // Remind creator button
                Button(action: {
                    withAnimation { offset = 0 }
                    remindCreator()
                }) {
                    VStack(spacing: 4) {
                        Image(systemName: "bell.fill")
                            .font(.title2)
                        Text("Remind")
                            .font(.caption2)
                    }
                    .foregroundColor(.white)
                    .frame(width: 80)
                    .frame(maxHeight: .infinity)
                    .background(Color.slingGradient)
                    .cornerRadius(0)
                }
                
                // Delete bet button (cancel user's bet)
                Button(action: {
                    withAnimation { offset = 0 }
                    showingCancelAlert = true
                }) {
                    VStack(spacing: 4) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.title2)
                        Text("Delete Bet")
                            .font(.caption2)
                    }
                    .foregroundColor(.white)
                    .frame(width: 80)
                    .frame(maxHeight: .infinity)
                    .background(Color.red)
                    .cornerRadius(0)
                }
                
                // Share button
                Button(action: {
                    withAnimation { offset = 0 }
                    showingShareSheet = true
                }) {
                    VStack(spacing: 4) {
                        Image(systemName: "square.and.arrow.up")
                            .font(.title2)
                        Text("Share")
                            .font(.caption2)
                    }
                    .foregroundColor(.white)
                    .frame(width: 80)
                    .frame(maxHeight: .infinity)
                    .background(Color.gray)
                    .cornerRadius(0)
                }
            }
        }
    }
    
    // MARK: - Helper Methods
    private func extractUsername(from email: String) -> String {
        return String(email.split(separator: "@").first ?? "Unknown")
    }
    
    // Function to get user's full name, with caching
    private func getUserFullName(from email: String) -> String {
        // Check cache first
        if let cachedName = userFullNames[email] {
            return cachedName
        }
        
        // For current user, use local data
        if let user = firestoreService.currentUser, user.email == email {
            let fullName = "\(user.first_name ?? "") \(user.last_name ?? "")".trimmingCharacters(in: .whitespaces)
            userFullNames[email] = fullName
            return fullName
        }
        
        // For other users, fetch from Firestore and cache
        firestoreService.getUserDetails(email: email) { fullName, _ in
            DispatchQueue.main.async {
                self.userFullNames[email] = fullName
            }
        }
        
        // Return first name as fallback while fetching
        return email.components(separatedBy: "@").first ?? email
    }
    
    private func generateShareText() -> String {
        let creatorName = isCreator ? "I" : getUserFullName(from: bet.creator_email)
        return "Check out this bet on Sling: \"\(bet.title)\" created by \(creatorName). Join the action!"
    }
    
    private func loadUserParticipation() {
        guard let _ = bet.id,
              let _ = currentUserEmail else { return }
        
        firestoreService.fetchUserIndividualBets { userBets in
            DispatchQueue.main.async {
                self.userBets = userBets
                self.hasUserParticipated = !userBets.isEmpty
            }
        }
    }
    
    private func loadBetStatus() {
        guard let _ = bet.id else { return }
        
        firestoreService.fetchBetStatus(betId: bet.id ?? "") { status in
            DispatchQueue.main.async {
                // For now, we'll set hasAnyBets based on whether there are user bets
                self.hasAnyBets = !self.userBets.isEmpty
                // optionCounts will need to be populated separately if needed
            }
        }
    }
    
    private func remindCreator() {
        guard let _ = bet.id else { return }
        firestoreService.remindCreator(betId: bet.id ?? "") { success in
            if success {
                DispatchQueue.main.async {
                    hasRemindedCreator = true
                }
            }
        }
    }
    
    private func loadCreatorName() {
        guard currentUserEmail != bet.creator_email else {
            creatorName = "You"
            return
        }
        
        // Try to get user details from Firestore Users collection
        firestoreService.db.collection("Users").document(bet.creator_email).getDocument { document, error in
            DispatchQueue.main.async {
                if let document = document, document.exists,
                   let data = document.data(),
                   let firstName = data["first_name"] as? String,
                   let lastName = data["last_name"] as? String,
                   !firstName.isEmpty, !lastName.isEmpty {
                    self.creatorName = "\(firstName) \(lastName)"
                } else if let document = document, document.exists,
                          let data = document.data(),
                          let displayName = data["display_name"] as? String,
                          !displayName.isEmpty {
                    self.creatorName = displayName
                } else {
                    // Fallback to email username if no name data found
                    self.creatorName = bet.creator_email.components(separatedBy: "@").first ?? bet.creator_email
                }
            }
        }
    }
    
    private func deleteMarket() {
        guard let _ = bet.id else { return }
        firestoreService.deleteBet(betId: bet.id ?? "") { success in
            if success {
                // Refresh the bets list
                firestoreService.fetchUserBets { _ in }
            }
        }
    }
    
    private func cancelBet() {
        guard let _ = bet.id else { return }
        
        firestoreService.cancelUserBet(betId: bet.id ?? "") { success in
            if success {
                DispatchQueue.main.async {
                    hasUserParticipated = false
                    userBets = []
                }
                firestoreService.fetchUserBets { _ in }
            }
        }
    }
}

struct EnhancedBetCard: View {
    // MARK: - Properties
    let bet: FirestoreBet
    let currentUserEmail: String?
    @ObservedObject private var firestoreService: FirestoreService
    
    // MARK: - State
    @State private var showingCancelAlert = false
    @State private var showingChooseWinnerSheet = false
    @State private var showingPlaceBetSheet = false
    @State private var userBets: [BetParticipant] = []
    @State private var hasUserParticipated: Bool = false
    @State private var hasAnyBets: Bool = false
    @State private var hasRemindedCreator = false
    @State private var optionCounts: [String: Int] = [:]
    @State private var userFullNames: [String: String] = [:]
    
    // MARK: - Initialization
    init(bet: FirestoreBet,
         currentUserEmail: String?,
         firestoreService: FirestoreService)
    {
        self.bet = bet
        self.currentUserEmail = currentUserEmail
        self._firestoreService = ObservedObject(wrappedValue: firestoreService)
    }
    
    // MARK: - Computed Properties
    private var communityName: String {
        if let community = firestoreService.userCommunities.first(where: { $0.id == bet.community_id }) {
            return community.name
        }
        return "Community"
    }
    
    private var isCreator: Bool {
        return currentUserEmail == bet.creator_email
    }
    
    private var userPick: String {
        if let userBet = userBets.first {
            return userBet.chosen_option
        }
        return "N/A"
    }
    
    private var userOdds: String {
        if let userBet = userBets.first {
            return firestoreService.formatImpliedOdds(firestoreService.calculateImpliedOdds(for: bet)[userBet.chosen_option] ?? 0.5)
        }
        return "N/A"
    }
    
    private var userWager: Double {
        if let userBet = userBets.first {
            return Double(userBet.stake_amount)
        }
        return 0.0
    }
    
    private var formattedClosingDate: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d 'at' h:mm a"
        return formatter.string(from: bet.deadline)
    }
    
    // Function to get user's full name, with caching
    private func getUserFullName(from email: String) -> String {
        // Check cache first
        if let cachedName = userFullNames[email] {
            return cachedName
        }
        
        // For current user, use local data
        if let user = firestoreService.currentUser, user.email == email {
            let fullName = "\(user.first_name ?? "") \(user.last_name ?? "")".trimmingCharacters(in: .whitespaces)
            userFullNames[email] = fullName
            return fullName
        }
        
        // For other users, fetch from Firestore and cache
        firestoreService.getUserDetails(email: email) { fullName, _ in
            DispatchQueue.main.async {
                self.userFullNames[email] = fullName
            }
        }
        
        // Return first name as fallback while fetching
        return email.components(separatedBy: "@").first ?? email
    }
    
    // MARK: - Body
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Header Section
            VStack(alignment: .leading, spacing: 8) {
                // Market Title
                Text(bet.title)
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.black)
                    .lineLimit(2)
                
                // Community Name & Creator
                                        HStack(spacing: 4) {
                            Image(systemName: "person.2")
                                .font(.caption)
                                .foregroundColor(.gray)
                            Text("\(communityName) • by \(isCreator ? "You" : getUserFullName(from: bet.creator_email))")
                                .font(.subheadline)
                                .foregroundColor(.gray)
                        }
            }
            
            // Content based on state
            if isCreator {
                // Creator states
                if !hasAnyBets {
                    // State 1: Creator with no bets placed
                    creatorNoBetsContent
                } else if !hasUserParticipated {
                    // State 2: Creator with other bets placed, creator hasn't bet
                    creatorOthersBetContent
                } else {
                    // State 4: Creator who also placed a bet
                    creatorParticipatedContent
                }
            } else if hasUserParticipated {
                // State 3: Non-creator who placed a bet
                participantContent
            } else {
                // Default case for non-participants
                nonParticipantContent
            }
        }
        .padding(20)
        .background(Color.white)
        .cornerRadius(16)
        .shadow(color: .black.opacity(0.05), radius: 8, x: 0, y: 2)
        .onAppear {
            loadUserParticipation()
            loadBetStatus()
        }
        .sheet(isPresented: $showingChooseWinnerSheet) {
            ChooseWinnerView(bet: bet, firestoreService: firestoreService)
        }
        .sheet(isPresented: $showingPlaceBetSheet) {
            PlaceBetView(bet: bet, presetOption: nil, firestoreService: firestoreService, onBetPlaced: nil)
        }
        .alert("Cancel Market", isPresented: $showingCancelAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Cancel Market", role: .destructive) {
                cancelMarket()
            }
        } message: {
            Text("Are you sure you want to cancel this market? This will return all wagers to participants.")
        }
    }
    
    // MARK: - Content Views
    
    @ViewBuilder
    private var creatorNoBetsContent: some View {
        // State 1: Creator with no bets placed
        VStack(alignment: .leading, spacing: 16) {
            // Info message
            VStack(alignment: .leading, spacing: 8) {
                HStack(spacing: 8) {
                    Image(systemName: "info.circle")
                        .font(.subheadline)
                        .foregroundColor(.blue)
                    Text("You created this market")
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(.blue)
                }
                
                Text("No bets placed yet. You can also place a bet yourself, or once someone else places a bet, you'll be able to choose the winner when it's time to settle.")
                    .font(.subheadline)
                    .foregroundColor(Color.slingBlue)
                    .lineLimit(nil)
            }
            .padding(16)
            .background(Color.slingLightBlue)
            .cornerRadius(12)
            
            // Betting closes time
            Text("Betting closes: \(formattedClosingDate)")
                .font(.subheadline)
                .foregroundColor(.gray)
            
            // Action buttons - only show if bet is open
            if bet.status.lowercased() == "open" {
            HStack(spacing: 12) {
                Button(action: {
                    showingCancelAlert = true
                }) {
                    Text("Cancel Market")
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 12)
                        .background(Color.red)
                        .cornerRadius(10)
                }
                
                Button(action: {
                    showingPlaceBetSheet = true
                }) {
                    Text("Place a Bet")
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 12)
                        .background(Color.slingGradient)
                        .cornerRadius(10)
                }
                }
            } else {
                // Show bet status when not open
                VStack(spacing: 8) {
                    Text("Bet Status: \(bet.status.capitalized)")
                        .font(.headline)
                        .fontWeight(.bold)
                        .foregroundColor(bet.status.lowercased() == "settled" ? .green : .gray)
                    
                    if bet.status.lowercased() == "settled" {
                        Text("This bet has been settled and is no longer accepting new wagers.")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                    } else if bet.status.lowercased() == "cancelled" {
                        Text("This bet has been cancelled.")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                    }
                }
                .padding(.vertical, 16)
                .frame(maxWidth: .infinity)
                .background(Color.gray.opacity(0.1))
                .cornerRadius(10)
            }
        }
    }
    
    @ViewBuilder
    private var creatorOthersBetContent: some View {
        // State 2: Creator with other bets placed, creator hasn't bet
        VStack(alignment: .leading, spacing: 16) {
            // Info message
            VStack(alignment: .leading, spacing: 8) {
                HStack(spacing: 8) {
                    Image(systemName: "info.circle")
                        .font(.subheadline)
                        .foregroundColor(Color.slingBlue)
                    Text("You created this market")
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(Color.slingBlue)
                }
                
                Text("You created this market but haven't placed a bet. Other players have placed bets, so you'll need to choose the winner when it's time to settle.")
                    .font(.subheadline)
                    .foregroundColor(Color.slingBlue)
                    .lineLimit(nil)
            }
            .padding(16)
            .background(Color.slingLightBlue)
            .cornerRadius(12)
            
            // Betting closes time
            Text("Betting closes: \(formattedClosingDate)")
                .font(.subheadline)
                .foregroundColor(.gray)
            
            // Action buttons
            HStack(spacing: 12) {
                Button(action: {
                    showingCancelAlert = true
                }) {
                    Text("Cancel Market")
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 12)
                        .background(Color.red)
                        .cornerRadius(10)
                }
                
                Button(action: {
                    showingChooseWinnerSheet = true
                }) {
                    Text("Choose Winner")
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 12)
                        .background(Color.slingGradient)
                        .cornerRadius(10)
                }
            }
        }
    }
    
    @ViewBuilder
    private var creatorParticipatedContent: some View {
        // State 4: Creator who also placed a bet
        VStack(alignment: .leading, spacing: 16) {
            // Betting closes time
            Text("Betting closes: \(formattedClosingDate)")
                .font(.subheadline)
                .foregroundColor(.gray)
            
            // Your bet details
            VStack(alignment: .leading, spacing: 12) {
                HStack {
                    // You Picked Section
                    VStack(alignment: .leading, spacing: 4) {
                        Text("You Picked")
                            .font(.caption)
                            .foregroundColor(.gray)
                        Text("\(userPick) \(userOdds)")
                            .font(.headline)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                    }
                    
                    Spacer()
                    
                    // Wager Section
                    VStack(alignment: .trailing, spacing: 4) {
                        Text("Wager")
                            .font(.caption)
                            .foregroundColor(.gray)
                        HStack(spacing: 4) {
                            Image(systemName: "bolt.fill")
                                .font(.caption)
                                .foregroundColor(Color.slingBlue)
                            Text(String(format: "%.2f", userWager))
                                .font(.headline)
                                .fontWeight(.bold)
                                .foregroundColor(.black)
                        }
                    }
                }
            }
            .padding(16)
            .background(Color(.systemGray6))
            .cornerRadius(12)
            
            // Action buttons
            HStack(spacing: 12) {
                Button(action: {
                    showingCancelAlert = true
                }) {
                    Text("Cancel Market")
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 12)
                        .background(Color.red)
                        .cornerRadius(10)
                }
                
                Button(action: {
                    showingChooseWinnerSheet = true
                }) {
                    Text("Choose Winner")
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(.white)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 12)
                        .background(Color.slingGradient)
                        .cornerRadius(10)
                }
            }
        }
    }
    
    @ViewBuilder
    private var participantContent: some View {
        // State 3: Non-creator who placed a bet
        VStack(alignment: .leading, spacing: 16) {
            // Betting closes time
            Text("Betting closes: \(formattedClosingDate)")
                .font(.subheadline)
                .foregroundColor(.gray)
            
            // Your bet details
            VStack(alignment: .leading, spacing: 12) {
                HStack {
                    // You Picked Section
                    VStack(alignment: .leading, spacing: 4) {
                        Text("You Picked")
                            .font(.caption)
                            .foregroundColor(.gray)
                        Text("\(userPick) \(userOdds)")
                            .font(.headline)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                    }
                    
                    Spacer()
                    
                    // Wager Section
                    VStack(alignment: .trailing, spacing: 4) {
                        Text("Wager")
                            .font(.caption)
                            .foregroundColor(.gray)
                        HStack(spacing: 4) {
                            Image(systemName: "bolt.fill")
                                .font(.caption)
                                .foregroundColor(Color.slingBlue)
                            Text(String(format: "%.2f", userWager))
                                .font(.headline)
                                .fontWeight(.bold)
                                .foregroundColor(.black)
                        }
                    }
                }
            }
            .padding(16)
            .background(Color(.systemGray6))
            .cornerRadius(12)
            
            // Remind Creator button
            if !hasRemindedCreator {
                HStack {
                    Spacer()
                    Button(action: remindCreator) {
                        HStack(spacing: 8) {
                            Image(systemName: "bell")
                                .font(.caption)
                            Text("Remind Creator")
                                .font(.subheadline)
                                .fontWeight(.medium)
                        }
                        .foregroundColor(.gray)
                        .padding(.horizontal, 16)
                        .padding(.vertical, 8)
                        .background(Color.clear)
                        .overlay(
                            RoundedRectangle(cornerRadius: 10)
                                .stroke(Color.gray, lineWidth: 1)
                        )
                        .cornerRadius(10)
                    }
                    Spacer()
                }
            }
        }
    }
    
    @ViewBuilder
    private var nonParticipantContent: some View {
        // Default content for non-participants (similar to original ActiveBetCard)
        VStack(alignment: .leading, spacing: 12) {
            Text("Betting closes: \(formattedClosingDate)")
                .font(.subheadline)
                .foregroundColor(.gray)
            
            if bet.status.lowercased() == "open" {
                Button(action: { showingPlaceBetSheet = true }) {
                    HStack {
                        Text("place bet")
                            .font(.subheadline)
                            .fontWeight(.medium)
                        
                        Image(systemName: "arrow.right")
                            .font(.subheadline)
                    }
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 12)
                        .background(Color.slingGradient)
                        .cornerRadius(10)
                }
            } else {
                // Show bet status when not open
                VStack(spacing: 8) {
                    Text("Bet Status: \(bet.status.capitalized)")
                        .font(.headline)
                        .fontWeight(.bold)
                        .foregroundColor(bet.status.lowercased() == "settled" ? .green : .gray)
                    
                    if bet.status.lowercased() == "settled" {
                        Text("This bet has been settled and is no longer accepting new wagers.")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                    } else if bet.status.lowercased() == "cancelled" {
                        Text("This bet has been cancelled.")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                    }
                }
                .padding(.vertical, 16)
                .frame(maxWidth: .infinity)
                .background(Color.gray.opacity(0.1))
                .cornerRadius(10)
            }
        }
    }
    
    // MARK: - Helper Methods
    private func loadUserParticipation() {
        firestoreService.fetchUserIndividualBets { userBets in
            DispatchQueue.main.async {
                self.userBets = userBets
                self.hasUserParticipated = !userBets.isEmpty
            }
        }
    }
    
    private func loadBetStatus() {
        guard let betId = bet.id else { return }
        
        firestoreService.fetchBetStatus(betId: betId) { status in
            DispatchQueue.main.async {
                // For now, we'll set hasAnyBets based on whether there are user bets
                self.hasAnyBets = !self.userBets.isEmpty
                // optionCounts will need to be populated separately if needed
            }
        }
    }
    
    private func cancelMarket() {
        guard let betId = bet.id else { return }
        
        firestoreService.cancelMarket(betId: betId) { success in
            if success {
                print("✅ Market cancelled successfully")
            } else {
                print("❌ Error cancelling market")
            }
        }
    }
    
    private func remindCreator() {
        guard let betId = bet.id else { return }
        firestoreService.remindCreator(betId: betId) { success in
            if success {
                DispatchQueue.main.async {
                    hasRemindedCreator = true
                }
            }
        }
    }
    
    private func extractUsername(from email: String) -> String {
        return String(email.split(separator: "@").first ?? "Unknown")
    }
    
    private func getDisplayNameFromEmail(_ email: String) -> String {
        // Extract first name from email (everything before @)
        let components = email.components(separatedBy: "@")
        if let username = components.first {
            // Capitalize first letter and return
            return username.prefix(1).uppercased() + username.dropFirst()
        }
        return email
    }
}

// MARK: - Enhanced Community Detail View

struct EnhancedCommunityDetailView: View {
    @Environment(\.dismiss) private var dismiss
    let community: FirestoreCommunity
    @ObservedObject var firestoreService: FirestoreService
    let onChatTap: (() -> Void)? // Callback for chat navigation
    @State private var selectedTab = 0 // 0 = Overview, 1 = Bets, 2 = Members, 3 = Settings
    @State private var communityBets: [FirestoreBet] = []
    @State private var isLoadingBets = false
    @State private var showingCreateBetModal = false
    @State private var showingInviteModal = false
    @State private var showingMemberProfile = false
    @State private var selectedMemberIndex = 0
    @State private var membersWithPoints: [CommunityMemberWithPoints]?
    @State private var showingTradingProfile = false
    @State private var selectedMemberForProfile: CommunityMemberWithPoints?
    @State private var showingCopyFeedback = false
    @State private var isAdmin: Bool = false
    @State private var communityMembers: [CommunityMemberInfo] = []
    @StateObject private var timeTracker = TimeTracker()
    @State private var previousTab = 0
    
    // Computed properties for real-time metrics
    private var actualMemberCount: Int {
        return communityMembers.count
    }
    
    private var actualBetCount: Int {
        return communityBets.count
    }
    
    // Helper function to get tab name
    private func getTabName(_ index: Int) -> String {
        switch index {
        case 0: return "overview"
        case 1: return "bets"
        case 2: return "members"
        case 3: return "settings"
        default: return "unknown"
        }
    }
    
    // Settings sheet states
    @State private var showingNotificationSettings = false
    @State private var showingMemberManagement = false
    @State private var showingCommunitySettings = false
    
    // Alert states
    @State private var showingLeaveAlert = false
    @State private var showingDeleteAlert = false
    
    // Image picker state
    @State private var showingImagePicker = false
    @State private var showingPhotoOptions = false
    @State private var showingPhotoPicker = false
    @State private var showingCamera = false
    @State private var selectedItem: PhotosPickerItem? = nil
    @State private var selectedImage: UIImage?
    
    // Fullscreen image state
    @State private var showImageFullscreen = false
    @State private var selectedImageUrl: String?
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                headerSection
                tabSelectorSection
                tabContentSection
            }
            .background(Color.white)
            .navigationBarHidden(true)
            .onAppear {
                // Track enhanced community detail view
                AnalyticsService.shared.trackCommunityDetailInteraction(
                    action: .view,
                    communityId: community.id ?? "",
                    communityName: community.name,
                    details: ["member_count": actualMemberCount, "bet_count": actualBetCount, "is_admin": isAdmin]
                )
                timeTracker.startTracking(for: "enhanced_community_detail_\(community.id ?? "")")
                
                loadCommunityBets()
                loadCommunityMembers()
                checkAdminStatus()
            }
            .onChange(of: communityMembers) { _, _ in
                // Update metrics when members change
            }
            .onChange(of: communityBets) { _, _ in
                // Update metrics when bets change
            }
            .onDisappear {
                // Track time spent on enhanced community detail page
                if let duration = timeTracker.endTracking(for: "enhanced_community_detail_\(community.id ?? "")") {
                    AnalyticsService.shared.trackPageViewTime(
                        page: "enhanced_community_detail_\(community.name)",
                        timeSpent: duration
                    )
                }
            }
            .animation(.easeInOut(duration: 0.3), value: selectedTab)
            .sheet(isPresented: $showingCreateBetModal) {
                CreateBetView(firestoreService: firestoreService, preSelectedCommunity: community.name)
            }
            .sheet(isPresented: $showingInviteModal) {
                ShareCommunityModal(
                    communityName: community.name,
                    communityId: community.id ?? "",
                    onDismiss: { showingInviteModal = false }
                )
            }
            .sheet(isPresented: $showingMemberProfile) {
                MemberProfileView(
                    community: community,
                    memberIndex: selectedMemberIndex,
                    firestoreService: firestoreService
                )
            }
            .sheet(isPresented: $showingTradingProfile) {
                if let selectedMember = selectedMemberForProfile {
                    TradingProfileView(
                        userId: selectedMember.email,
                        userName: selectedMember.name,
                        displayName: nil, // Community members don't have display_name
                        isCurrentUser: false,
                        firestoreService: firestoreService
                    )
                }
            }
            .sheet(isPresented: $showingImagePicker) {
                CommunityImagePicker(
                    community: community,
                    firestoreService: firestoreService
                )
            }
            .confirmationDialog("Choose Community Picture", isPresented: $showingPhotoOptions, titleVisibility: .visible) {
                Button("Choose from Photos") {
                    showingPhotoPicker = true
                }
                
                Button("Take Photo") {
                    showingCamera = true
                }
                
                Button("Cancel", role: .cancel) { }
            }
            .photosPicker(isPresented: $showingPhotoPicker, selection: $selectedItem, matching: .images, photoLibrary: .shared())
            .sheet(isPresented: $showingCamera) {
                CameraView(
                    onImageCaptured: { image in
                    selectedImage = image
                    showingCamera = false
                    },
                    onError: { error in
                        print("Camera error: \(error)")
                    showingCamera = false
                }
                )
            }
            .onChange(of: selectedItem) { _ in
                loadPhotoFromPicker()
            }
            .fullScreenCover(isPresented: $showImageFullscreen) {
                if let imageUrl = selectedImageUrl {
                    FullscreenImageView(imageUrl: imageUrl, isPresented: $showImageFullscreen)
                } else if let selectedImage = selectedImage {
                    FullscreenImageView(imageUrl: "", selectedImage: selectedImage, isPresented: $showImageFullscreen)
                }
            }
        }
    }
    
    // MARK: - Header Section
    private var headerSection: some View {
        ZStack {
            // Background with gradient
            Rectangle()
                .fill(AnyShapeStyle(Color.slingGradient))
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .ignoresSafeArea(.all, edges: .top)
            
            // Content overlay - compact layout
            VStack(spacing: 8) {
                // Header Buttons with proper spacing
                HStack(spacing: 0) {
                    Button(action: { dismiss() }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.white)
                            .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                    
                    // Share Button
                    Button(action: {
                        showingInviteModal = true
                    }) {
                        Image(systemName: "square.and.arrow.up")
                                .font(.title3)
                                .foregroundColor(.white)
                            .frame(width: 44, height: 44)
                    }
                }
                .frame(maxWidth: .infinity)
                .padding(.top, 12)
                
                // Community Info - compact layout
                VStack(spacing: 6) {
                    // Avatar - Bigger profile picture with separate click handlers
                    ZStack {
                        if let selectedImage = selectedImage {
                            // Show selected image
                            Image(uiImage: selectedImage)
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: 80, height: 80)
                                .clipShape(Circle())
                                .overlay(
                                    Circle()
                                        .stroke(Color.white, lineWidth: 3)
                                )
                                .onTapGesture {
                                    // Show fullscreen image
                                    selectedImageUrl = nil
                                    showImageFullscreen = true
                                }
                        } else if let profileImageUrl = community.profile_image_url {
                            // Show custom community image
                            AsyncImage(url: URL(string: profileImageUrl)) { image in
                                image
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                            } placeholder: {
                                Circle()
                                    .fill(Color.white)
                                    .overlay(
                                        ProgressView()
                                            .progressViewStyle(CircularProgressViewStyle(tint: .slingBlue))
                                    )
                            }
                            .frame(width: 80, height: 80)
                            .clipShape(Circle())
                            .overlay(
                                Circle()
                                    .stroke(Color.white.opacity(0.3), lineWidth: 2)
                            )
                            .onTapGesture {
                                // Show fullscreen image
                                selectedImageUrl = profileImageUrl
                                showImageFullscreen = true
                            }
                        } else {
                            // Show community initials - clicking anywhere changes picture
                            Circle()
                                .fill(Color.white)
                                .frame(width: 80, height: 80)
                                .overlay(
                                    Text(String(community.name.prefix(1)).uppercased())
                                        .font(.largeTitle)
                                        .fontWeight(.bold)
                                        .foregroundColor(.slingBlue)
                                )
                                .overlay(
                                    Circle()
                                        .stroke(Color.white.opacity(0.3), lineWidth: 2)
                                )
                                .onTapGesture {
                                    // Change picture
                                    showingPhotoOptions = true
                                }
                        }
                        
                        // Swap icon overlay at 3-6 o'clock position
                        Circle()
                            .fill(Color.slingBlue)
                            .frame(width: 28, height: 28)
                            .overlay(
                                Image(systemName: "arrow.2.squarepath")
                                    .font(.system(size: 12, weight: .medium))
                                    .foregroundColor(.white)
                            )
                            .overlay(
                                Circle()
                                    .stroke(Color.white, lineWidth: 2)
                            )
                            .offset(x: 28, y: 28) // Position at 3-6 o'clock (half on, half off)
                            .onTapGesture {
                                // Change picture
                                showingPhotoOptions = true
                            }
                    }
                    
                    // Community Name with Admin Badge
                    HStack(spacing: 8) {
                        Text(community.name)
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                        
                        // Crown icon for admin users
                        if isAdmin {
                            Image(systemName: "crown.fill")
                                .font(.title3)
                                .foregroundColor(.yellow)
                        }
                    }
                        
                    // Stats with icons and labels
                    HStack(spacing: 16) {
                        // Member Count
                        HStack(spacing: 4) {
                            Image(systemName: "person.2.fill")
                                .font(.caption)
                                .foregroundColor(.white.opacity(0.9))
                            Text("\(actualMemberCount)")
                            .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.white)
                            Text("members")
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.white.opacity(0.8))
                        }
                        
                        // Bet Count
                        HStack(spacing: 4) {
                            Image(systemName: "list.bullet.clipboard")
                                .font(.caption)
                            .foregroundColor(.white.opacity(0.9))
                            Text("\(actualBetCount)")
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.white)
                            Text("bets")
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.white.opacity(0.8))
                        }
                    }
                }
                .frame(maxWidth: .infinity)
                .padding(.bottom, 24)
            }
            .padding(.horizontal, 16)
            .padding(.top, 28)
            .padding(.bottom, 36)
        }
        .frame(height: 200)
    }
    
    // MARK: - Tab Selector Section
    private var tabSelectorSection: some View {
        HStack(spacing: 0) {
            ForEach(0..<4, id: \.self) { index in
                tabButton(for: index)
            }
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .background(Color.white)
        .overlay(
            Rectangle()
                .frame(height: 0.5)
                .foregroundColor(Color.gray.opacity(0.3)),
            alignment: .bottom
        )
    }
    
    private func tabButton(for index: Int) -> some View {
        Button(action: { 
            let fromTab = getTabName(previousTab)
            let toTab = getTabName(index)
            
            AnalyticsService.shared.trackCommunityTabSwitch(
                communityId: community.id ?? "",
                communityName: community.name,
                fromTab: fromTab,
                toTab: toTab
            )
            AnalyticsService.shared.trackCommunityDetailInteraction(
                action: .tabSwitch,
                communityId: community.id ?? "",
                communityName: community.name,
                details: ["from_tab": fromTab, "to_tab": toTab]
            )
            
            previousTab = selectedTab
            selectedTab = index 
        }) {
            VStack(spacing: 4) {
                Text(tabTitle(for: index))
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .foregroundColor(selectedTab == index ? .slingBlue : .gray)
                
                Rectangle()
                    .fill(selectedTab == index ? Color.slingBlue : Color.clear)
                    .frame(height: 2)
            }
        }
        .frame(maxWidth: .infinity)
    }
    
    // MARK: - Tab Content Section
    private var tabContentSection: some View {
        TabView(selection: $selectedTab) {
            overviewTab.tag(0)
            betsTab.tag(1)
            membersTab.tag(2)
            settingsTab.tag(3)
        }
        .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
        .background(Color.white)
    }
    
    // MARK: - Tab Content Views
    
    private var overviewTab: some View {
        ScrollView {
            VStack(spacing: 20) {
                // Invite Code Section - Compact Design
                VStack(spacing: 12) {
                    Text("Invite Code")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    
                    // Invite Code Card - Same size as action cards
                    HStack(spacing: 12) {
                        // Invite Code Text
                            Text(community.invite_code)
                            .font(.subheadline)
                            .fontWeight(.medium)
                                .foregroundColor(.black)
                        
                        Spacer()
                        
                        // Copy Button with feedback
                        Button(action: {
                            UIPasteboard.general.string = community.invite_code
                            let impactFeedback = UIImpactFeedbackGenerator(style: .light)
                            impactFeedback.impactOccurred()
                            
                            // Show checkmark temporarily
                            showingCopyFeedback = true
                            
                            // Hide checkmark after delay
                            DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                                showingCopyFeedback = false
                            }
                        }) {
                            Image(systemName: showingCopyFeedback ? "checkmark" : "doc.on.clipboard")
                                .font(.caption)
                                .foregroundColor(showingCopyFeedback ? .green : .gray)
                                .frame(width: 24, height: 24)
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 12)
                    .background(Color.gray.opacity(0.06))
                    .cornerRadius(12)
                    .shadow(color: .black.opacity(0.08), radius: 12, x: 0, y: 4)
                }
                .padding(.horizontal, 16)
                
                // Quick actions
                VStack(spacing: 12) {
                    Text("Quick Actions")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    
                    Button(action: {
                        showingCreateBetModal = true
                    }) {
                        HStack(spacing: 12) {
                            Circle()
                                .fill(AnyShapeStyle(Color.slingGradient))
                                .frame(width: 40, height: 40)
                                .overlay(
                                    Image(systemName: "plus")
                                        .font(.title3)
                                        .foregroundColor(.white)
                                )
                            
                            VStack(alignment: .leading, spacing: 2) {
                                Text("Create New Bet")
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                    .foregroundColor(.black)
                                Text("Start a new prediction market")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                            }
                            
                            Spacer()
                            
                            Image(systemName: "chevron.right")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        .padding(16)
                        .background(Color.white)
                        .cornerRadius(12)
                    }
                    .buttonStyle(PlainButtonStyle())
                    
                    Button(action: {
                        showingInviteModal = true
                    }) {
                        HStack(spacing: 12) {
                            Circle()
                                .fill(AnyShapeStyle(Color.slingGradient))
                                .frame(width: 40, height: 40)
                                .overlay(
                                    Image(systemName: "person.badge.plus")
                                        .font(.title3)
                                        .foregroundColor(.white)
                                )
                            
                            VStack(alignment: .leading, spacing: 2) {
                                Text("Invite Friends")
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                    .foregroundColor(.black)
                                Text("Share invite code with others")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                            }
                            
                            Spacer()
                            
                            Image(systemName: "chevron.right")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        .padding(16)
                        .background(Color.white)
                        .cornerRadius(12)
                    }
                    .buttonStyle(PlainButtonStyle())
                }
                .padding(.horizontal, 16)
                
                // Recent activity
                if !communityBets.isEmpty {
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Recent Activity")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                            .frame(maxWidth: .infinity, alignment: .leading)
                        
                        LazyVStack(spacing: 12) {
                            ForEach(communityBets.prefix(3)) { bet in
                                RecentBetRow(bet: bet)
                            }
                        }
                    }
                    .padding(.horizontal, 16)
                }
                
                // Community Stats Section
                VStack(spacing: 12) {
                    Text("Community Stats")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    
                    // Performance Grid - Horizontal scroll
                    ScrollView(.horizontal, showsIndicators: false) {
                        HStack(spacing: 12) {
                            CommunityPerformanceCard(icon: "bolt.fill", value: "\(getTotalVolume())", label: "Total Volume", color: .slingBlue)
                            CommunityPerformanceCard(icon: "chart.line.uptrend.xyaxis", value: getWinRate(), label: "Win Rate", color: .slingBlue)
                            CommunityPerformanceCard(icon: "target", value: "\(communityBets.count)", label: "Total Bets", color: .slingBlue)
                            CommunityPerformanceCard(icon: "person.2", value: "\(getActualMemberCount())", label: "Active Members", color: .slingBlue)
                            CommunityPerformanceCard(icon: "trophy.fill", value: getSettledBetsCount(), label: "Settled Bets", color: .slingBlue)
                            CommunityPerformanceCard(icon: "clock.fill", value: getPendingBetsCount(), label: "Pending Bets", color: .slingBlue)
                        }
                        .padding(.horizontal, 16)
                    }
                }
                .padding(.horizontal, 16)
            }
            .padding(.vertical, 20)
        }
    }
    
    private var betsTab: some View {
        ScrollView {
            LazyVStack(spacing: 16) {
                if isLoadingBets {
                    ForEach(0..<3, id: \.self) { _ in
                        BetLoadingRow()
                    }
                } else if communityBets.isEmpty {
                    EmptyBetsView(firestoreService: firestoreService)
                } else {
                    ForEach(communityBets) { bet in
                        EnhancedBetCardView(
                            bet: bet,
                            currentUserEmail: firestoreService.currentUser?.email,
                            firestoreService: firestoreService,
                            isCommunityNameClickable: false
                        )
                    }
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 20)
        }
    }
    
        private var membersTab: some View {
        ScrollView {
            LazyVStack(spacing: 12) {
                // Leaderboard Header
                HStack {
                    VStack(alignment: .leading, spacing: 4) {
                        Text("Leaderboard")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                        
                        Text("Members ranked by net points")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                    }
                    
                    Spacer()
                    
                    Image(systemName: "trophy.fill")
                        .font(.title2)
                        .foregroundColor(.slingBlue)
                }
                .padding(.horizontal, 16)
                .padding(.bottom, 8)
                
                if let membersWithPoints = membersWithPoints {
                    let sortedMembers = membersWithPoints.sorted { $0.netPoints > $1.netPoints }
                    // Always show leaderboard even with just one member
                    if !sortedMembers.isEmpty {
                    ForEach(Array(sortedMembers.enumerated()), id: \.element.id) { index, memberWithPoints in
                        MemberRowView(
                            memberWithPoints: memberWithPoints,
                            rank: index + 1,
                            onTap: {
                                selectedMemberForProfile = memberWithPoints
                                showingTradingProfile = true
                            }
                        )
                        }
                    } else {
                        // Show empty state if no members loaded
                        VStack(spacing: 16) {
                            Image(systemName: "person.2")
                                .font(.system(size: 48))
                                .foregroundColor(Color.slingBlue.opacity(0.6))
                            
                            Text("Loading Members...")
                                .font(.headline)
                                .fontWeight(.semibold)
                                .foregroundColor(.black)
                        }
                        .padding(.top, 60)
                    }
                } else {
                    // Fallback to basic member display if advanced loading fails
                    // Always show leaderboard even with just one member
                    ForEach(0..<max(1, community.member_count), id: \.self) { index in
                        HStack(spacing: 16) {
                            // Rank Badge
                            ZStack {
                                Circle()
                                    .fill(index == 0 ? Color.slingBlue : Color.gray.opacity(0.3))
                                    .frame(width: 32, height: 32)
                                
                                Text("\(index + 1)")
                                    .font(.caption)
                                    .fontWeight(.bold)
                                    .foregroundColor(index == 0 ? .white : .gray)
                            }
                            
                            // Profile Picture
                            Circle()
                                .fill(AnyShapeStyle(Color.slingGradient))
                                .frame(width: 48, height: 48)
                                .overlay(
                                    Text("M\(index + 1)")
                                        .font(.subheadline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(.white)
                                )
                            
                            VStack(alignment: .leading, spacing: 4) {
                                Text("Member \(index + 1)")
                                    .font(.headline)
                                    .fontWeight(.medium)
                                    .foregroundColor(.black)
                                
                                Text("Loading points...")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                            }
                            
                            Spacer()
                            
                            // Placeholder for net points
                            VStack(alignment: .trailing, spacing: 2) {
                            HStack(spacing: 4) {
                                Image(systemName: "bolt.fill")
                                    .font(.caption)
                                        .foregroundColor(.slingBlue)
                                
                                Text("--")
                                        .font(.headline)
                                    .fontWeight(.bold)
                                    .foregroundColor(.gray)
                            }
                                
                                Text("Net Points")
                                    .font(.caption)
                                    .foregroundColor(.gray)
                            }
                        }
                        .padding(.horizontal, 16)
                        .padding(.vertical, 16)
                        .background(Color.white)
                        .cornerRadius(12)
                        .shadow(color: .black.opacity(0.05), radius: 2, x: 0, y: 1)
                    }
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 20)
        }
        .onAppear {
            loadMembersWithPoints()
        }
    }
    
    private var settingsTab: some View {
        ScrollView {
            VStack(spacing: 16) {
                if isAdmin {
                    // Admin settings
                    VStack(spacing: 0) {
                        SettingsRow(
                            icon: "bell", 
                            title: "Notifications", 
                            subtitle: "Manage notification preferences",
                            action: { showNotificationSettings() }
                        )
                        
                        SettingsRow(
                            icon: "person.2", 
                            title: "Member Management", 
                            subtitle: "Add or remove members",
                            action: { showMemberManagement() }
                        )
                        
                        SettingsRow(
                            icon: "gear", 
                            title: "Community Settings", 
                            subtitle: "Edit community details",
                            action: { showCommunitySettings() }
                        )
                        
                        
                        SettingsRow(
                            icon: "trash", 
                            title: "Delete Community", 
                            subtitle: "Permanently delete this community", 
                            isDestructive: true,
                            action: { showDeleteConfirmation() }
                        )
                    }
                    .background(Color.white)
                    .cornerRadius(12)
                    .padding(.horizontal, 16)
                } else {
                    // Regular member settings
                    VStack(spacing: 0) {
                        SettingsRow(
                            icon: "bell", 
                            title: "Notifications", 
                            subtitle: "Manage notification preferences",
                            action: { showNotificationSettings() }
                        )
                        
                        SettingsRow(
                            icon: "person.2", 
                            title: "Member Management", 
                            subtitle: "View community members",
                            action: { showMemberManagement() }
                        )
                        
                        SettingsRow(
                            icon: "gear", 
                            title: "Community Settings", 
                            subtitle: "View community details",
                            action: { showCommunitySettings() }
                        )
                        
                        SettingsRow(
                            icon: "trash", 
                            title: "Leave Community", 
                            subtitle: "Leave this community", 
                            isDestructive: true,
                            action: { showLeaveConfirmation() }
                        )
                    }
                    .background(Color.white)
                    .cornerRadius(12)
                    .padding(.horizontal, 16)
                }
            }
            .padding(.vertical, 20)
        }
        .sheet(isPresented: $showingNotificationSettings) {
            NotificationSettingsView(
                community: community,
                firestoreService: firestoreService,
                isAdmin: isAdmin
            )
        }
        .sheet(isPresented: $showingMemberManagement) {
            MemberManagementView(
                community: community,
                firestoreService: firestoreService,
                isAdmin: isAdmin
            )
        }
        .sheet(isPresented: $showingCommunitySettings) {
            CommunitySettingsDetailView(
                community: community,
                firestoreService: firestoreService,
                isAdmin: isAdmin
            )
        }
        .alert("Leave Community", isPresented: $showingLeaveAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Leave", role: .destructive) {
                leaveCommunity()
            }
        } message: {
            Text("Are you sure you want to leave this community? You can rejoin later using the invite code.")
        }
        .alert("Delete Community", isPresented: $showingDeleteAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Delete", role: .destructive) {
                deleteCommunity()
            }
        } message: {
            Text("Are you sure you want to delete this community? This action cannot be undone and all data will be permanently lost.")
        }
    }
    
    // MARK: - Helper Methods
    
    private func tabTitle(for index: Int) -> String {
        switch index {
        case 0: return "Overview"
        case 1: return "Bets"
        case 2: return "Leaderboard"
        case 3: return "Settings"
        default: return ""
        }
    }
    
    private func loadCommunityBets() {
        isLoadingBets = true
        // Refresh bets from Firestore to get latest data
        firestoreService.fetchBets()
        // Filter bets for this community
        communityBets = firestoreService.bets.filter { $0.community_id == (community.id ?? "") }
        isLoadingBets = false
    }
    
    private func loadCommunityMembers() {
        guard let communityId = community.id else { return }
        
        firestoreService.fetchCommunityMembers(communityId: communityId) { members in
            DispatchQueue.main.async {
                self.communityMembers = members
            }
        }
    }
    
    private func loadMembersWithPoints() {
        print("🔄 Loading members with points for community: \(community.id ?? "nil")")
        
        // Add a timeout in case the Firestore calls take too long
        DispatchQueue.main.asyncAfter(deadline: .now() + 10.0) {
            if self.membersWithPoints == nil {
                print("⏰ Timeout reached, showing fallback member list")
                // Force the fallback to show by setting an empty array
                self.membersWithPoints = []
            }
        }
        
        firestoreService.getCommunityMembersWithNetPoints(communityId: community.id ?? "") { members in
            print("✅ Loaded \(members.count) members with points")
            DispatchQueue.main.async {
                self.membersWithPoints = members
            }
        }
    }
    
    private func formatDateShort(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d"
        return formatter.string(from: date)
    }
    
    // MARK: - Community Stats Helper Methods
    
    private func getTotalVolume() -> String {
        let communityBets = firestoreService.bets.filter { $0.community_id == (community.id ?? "") }
        let totalVolume = communityBets.reduce(0.0) { total, bet in
            total + Double(bet.total_pool ?? 0)
        }
        return String(format: "%.0f", totalVolume)
    }
    
    private func getWinRate() -> String {
        let communityBets = firestoreService.bets.filter { $0.community_id == (community.id ?? "") }
        let settledBets = communityBets.filter { $0.status.lowercased() == "settled" }
        
        guard !settledBets.isEmpty else { return "0%" }
        
        // TODO: This needs to be updated with actual win/loss logic
        // For now, using a placeholder - would need to check winner_option vs actual outcome
        let winRate = 68.0 // Placeholder - would need actual win/loss logic
        return String(format: "%.0f%%", winRate)
    }
    
    private func getSettledBetsCount() -> String {
        let communityBets = firestoreService.bets.filter { $0.community_id == (community.id ?? "") }
        let settledBets = communityBets.filter { $0.status.lowercased() == "settled" }
        return "\(settledBets.count)"
    }
    
    private func getPendingBetsCount() -> String {
        let communityBets = firestoreService.bets.filter { $0.community_id == (community.id ?? "") }
        let pendingBets = communityBets.filter { $0.status.lowercased() == "open" }
        return "\(pendingBets.count)"
    }
    
    private func getActualMemberCount() -> Int {
        // Return the count of fetched community members
        return communityMembers.count
    }
    
    private func checkAdminStatus() {
        guard let userEmail = firestoreService.currentUser?.email else { return }
        firestoreService.isUserAdminInCommunity(communityId: community.id ?? "", userEmail: userEmail) { adminStatus in
            DispatchQueue.main.async {
                self.isAdmin = adminStatus
            }
        }
    }
    
    // MARK: - Settings Helper Methods
    
    private func showNotificationSettings() {
        showingNotificationSettings = true
    }
    
    private func showMemberManagement() {
        showingMemberManagement = true
    }
    
    private func showCommunitySettings() {
        showingCommunitySettings = true
    }
    
    
    private func showLeaveConfirmation() {
        showingLeaveAlert = true
    }
    
    private func showDeleteConfirmation() {
        showingDeleteAlert = true
    }
    
    private func leaveCommunity() {
        guard let userEmail = firestoreService.currentUser?.email else { return }
        
        firestoreService.leaveCommunity(communityId: community.id ?? "", userEmail: userEmail) { success in
            DispatchQueue.main.async {
                if success {
                    // Dismiss the view and go back to communities list
                    dismiss()
                }
            }
        }
    }
    
    private func deleteCommunity() {
        firestoreService.deleteCommunity(communityId: community.id ?? "") { success in
            DispatchQueue.main.async {
                if success {
                    // Dismiss the view and go back to communities list
                    dismiss()
                }
            }
        }
    }
    
    private func loadPhotoFromPicker() {
        Task {
            if let selectedItem = selectedItem {
                if let data = try? await selectedItem.loadTransferable(type: Data.self),
                   let uiImage = UIImage(data: data) {
                    DispatchQueue.main.async {
                        self.selectedImage = uiImage
                        uploadCommunityImage()
                    }
                }
            }
        }
    }
    
    private func uploadCommunityImage() {
        guard let image = selectedImage,
              let communityId = community.id else { return }
        
        firestoreService.uploadCommunityImage(image, communityId: communityId) { success, imageUrl in
            DispatchQueue.main.async {
                if success {
                    print("✅ Community image uploaded successfully")
                    // Clear the selected image since it's now uploaded
                    self.selectedImage = nil
                } else {
                    print("❌ Failed to upload community image")
                }
            }
        }
    }
}

// MARK: - Supporting Views

struct SettingsRow: View {
    let icon: String
    let title: String
    let subtitle: String
    let isDestructive: Bool
    let showArrow: Bool
    let action: () -> Void
    
    init(icon: String, title: String, subtitle: String, isDestructive: Bool = false, showArrow: Bool = true, action: @escaping () -> Void) {
        self.icon = icon
        self.title = title
        self.subtitle = subtitle
        self.isDestructive = isDestructive
        self.showArrow = showArrow
        self.action = action
    }
    
    var body: some View {
        Button(action: action) {
            HStack(spacing: 12) {
                Image(systemName: icon)
                    .font(.title2)
                    .foregroundColor(isDestructive ? .red : .slingBlue)
                    .frame(width: 24)
                
                VStack(alignment: .leading, spacing: 2) {
                    Text(title)
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(isDestructive ? .red : .black)
                    
                    Text(subtitle)
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                
                Spacer()
                
                if showArrow {
                    Image(systemName: "chevron.right")
                        .font(.caption)
                        .foregroundColor(.gray)
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .background(Color.white)
        }
        .buttonStyle(PlainButtonStyle())
    }
}

struct StatItem: View {
    let icon: String
    let value: String
    let label: String
    
    var body: some View {
        VStack(spacing: 4) {
            Image(systemName: icon)
                .font(.title3)
                .foregroundColor(.slingBlue)
            
            Text(value)
                .font(.headline)
                .fontWeight(.bold)
                .foregroundColor(.black)
            
            Text(label)
                .font(.caption)
                .foregroundColor(.gray)
        }
    }
}

struct CommunityPerformanceCard: View {
    let icon: String
    let value: String
    let label: String
    let color: Color
    
    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: icon)
                .font(.title3)
                .foregroundColor(color)
            
            Text(value)
                .font(.headline)
                .fontWeight(.bold)
                .foregroundColor(color)
            
            Text(label)
                .font(.caption)
                .foregroundColor(.gray)
        }
        .frame(width: 120, height: 100)
        .padding(.vertical, 16)
        .background(Color.white)
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(Color.gray.opacity(0.2), lineWidth: 1)
        )
    }
}

// MARK: - Member Profile View

struct MemberProfileView: View {
    @Environment(\.dismiss) private var dismiss
    let community: FirestoreCommunity
    let memberIndex: Int
    @ObservedObject var firestoreService: FirestoreService
    @State private var selectedTab = 0 // 0 = Overview, 1 = All Bets, 2 = Head-to-Head
    @State private var memberBets: [FirestoreBet] = []
    @State private var isLoadingBets = false
    
    // Fullscreen image state
    @State private var showImageFullscreen = false
    @State private var selectedImageUrl: String?
    
    // Mock data for demonstration - in real app, fetch from Firestore
    private var memberName: String {
        if memberIndex == 0 {
            return "Admin User"
        } else {
            return "Member \(memberIndex + 1)"
        }
    }
    
    private var memberUsername: String {
        if memberIndex == 0 {
            return "@admin"
        } else {
            return "@member\(memberIndex + 1)"
        }
    }
    
    private var memberJoinDate: String {
        if memberIndex == 0 {
            return "Member since Jan 2024"
        } else {
            return "Member since Feb 2024"
        }
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                headerSection(selectedImageUrl: $selectedImageUrl, showImageFullscreen: $showImageFullscreen)
                
                // Performance Section
                performanceSection
                
                // Tab Selector
                tabSelectorSection
                
                // Tab Content
                tabContentSection
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
            .onAppear {
                loadMemberBets()
            }
            .fullScreenCover(isPresented: $showImageFullscreen) {
                if let imageUrl = selectedImageUrl {
                    FullscreenImageView(imageUrl: imageUrl, isPresented: $showImageFullscreen)
                }
            }
        }
    }
    
    // MARK: - Header Section
    private func headerSection(selectedImageUrl: Binding<String?>, showImageFullscreen: Binding<Bool>) -> some View {
        VStack(spacing: 16) {
            HStack {
                Button(action: { dismiss() }) {
                    Image(systemName: "arrow.left")
                        .font(.title2)
                        .foregroundColor(.slingBlue)
                }
                
                Spacer()
                
                Text("Trading Profile")
                    .font(.title2)
                    .fontWeight(.bold)
                    .foregroundColor(.black)
                
                Spacer()
                
                Button(action: {
                    // Chat action
                }) {
                    Image(systemName: "bubble.left")
                        .font(.title2)
                        .foregroundColor(.slingBlue)
                }
            }
            
            // Member Info
            HStack(spacing: 16) {
                // Avatar
                Circle()
                    .fill(Color.yellow)
                    .frame(width: 60, height: 60)
                    .overlay(
                        Circle()
                            .fill(Color.black)
                            .frame(width: 50, height: 50)
                            .overlay(
                                Circle()
                                    .fill(Color.white)
                                    .frame(width: 8, height: 8)
                            )
                    )
                
                // Member Details
                VStack(alignment: .leading, spacing: 4) {
                    Text(memberName)
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Text(memberUsername)
                        .font(.subheadline)
                        .foregroundColor(.gray)
                    
                    Text(memberJoinDate)
                        .font(.caption)
                        .foregroundColor(.gray)
                }
                
                Spacer()
                
                // Settle Button
                Button(action: {
                    // Settle action
                }) {
                    Text("Settle")
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(.white)
                        .padding(.horizontal, 16)
                        .padding(.vertical, 8)
                        .background(Color.slingBlue)
                        .cornerRadius(8)
                }
            }
        }
        .padding(.horizontal, 16)
        .padding(.top, 16)
        .padding(.bottom, 20)
        .background(Color.white)
    }
    
    // MARK: - Performance Section
    private var performanceSection: some View {
        VStack(spacing: 16) {
            Text("Performance")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundColor(.black)
                .frame(maxWidth: .infinity, alignment: .leading)
            
            LazyVGrid(columns: Array(repeating: GridItem(.flexible(), spacing: 12), count: 2), spacing: 12) {
                PerformanceCard(icon: "bolt.fill", value: "$608", label: "Net Balance", color: .slingBlue)
                PerformanceCard(icon: "bolt.fill", value: "$2,500", label: "Total Volume", color: .slingBlue)
                PerformanceCard(icon: "chart.line.uptrend.xyaxis", value: "$850", label: "Total P&L", color: .slingBlue)
                PerformanceCard(icon: "percent", value: "68%", label: "Win Rate", color: .slingBlue)
                PerformanceCard(icon: "target", value: "35", label: "Total Bets", color: .slingBlue)
                PerformanceCard(icon: "person.2", value: "12", label: "Bets with You", color: .slingBlue)
            }
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 20)
        .background(Color.white)
    }
    
    // MARK: - Tab Selector Section
    private var tabSelectorSection: some View {
        HStack(spacing: 0) {
            ForEach(0..<3, id: \.self) { index in
                Button(action: { selectedTab = index }) {
                    Text(tabTitle(for: index))
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(selectedTab == index ? .slingBlue : .gray)
                        .frame(maxWidth: .infinity)
                        .padding(.vertical, 12)
                        .background(selectedTab == index ? Color.slingLightBlue : Color.clear)
                        .cornerRadius(8)
                }
            }
        }
        .padding(.horizontal, 16)
        .background(Color.white)
        .overlay(
            Rectangle()
                .frame(height: 0.5)
                .foregroundColor(Color.gray.opacity(0.3)),
            alignment: .bottom
        )
    }
    
    // MARK: - Tab Content Section
    private var tabContentSection: some View {
        TabView(selection: $selectedTab) {
            overviewTab.tag(0)
            allBetsTab.tag(1)
            headToHeadTab.tag(2)
        }
        .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
    }
    
    // MARK: - Tab Content Views
    private var overviewTab: some View {
        ScrollView {
            VStack(spacing: 16) {
                VStack(spacing: 12) {
                    Image(systemName: "chart.line.uptrend.xyaxis")
                        .font(.system(size: 48))
                        .foregroundColor(.gray.opacity(0.6))
                    
                    Text("Recent Activity Summary")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.black)
                    
                    Text("\(memberName) has been active in 3 communities this week")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                        .multilineTextAlignment(.center)
                }
                .padding(.vertical, 40)
            }
            .padding(.horizontal, 16)
        }
    }
    
    private var allBetsTab: some View {
        ScrollView {
            LazyVStack(spacing: 16) {
                if isLoadingBets {
                    ForEach(0..<3, id: \.self) { _ in
                        BetLoadingRow()
                    }
                } else if memberBets.isEmpty {
                    VStack(spacing: 16) {
                        Image(systemName: "target")
                            .font(.system(size: 48))
                            .foregroundColor(.gray.opacity(0.6))
                        
                        Text("No Bets Yet")
                            .font(.headline)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                        
                        Text("This member hasn't placed any bets yet")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                    }
                    .padding(.top, 60)
                } else {
                    ForEach(memberBets) { bet in
                        EnhancedBetCardView(
                            bet: bet,
                            currentUserEmail: firestoreService.currentUser?.email,
                            firestoreService: firestoreService,
                            isCommunityNameClickable: true
                        )
                    }
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 20)
        }
    }
    
    private var headToHeadTab: some View {
        VStack(spacing: 16) {
            Image(systemName: "person.2")
                .font(.system(size: 48))
                .foregroundColor(.gray.opacity(0.6))
            
            Text("Head-to-Head")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundColor(.black)
            
            Text("Compare your performance with this member")
                .font(.subheadline)
                .foregroundColor(.gray)
                .multilineTextAlignment(.center)
                .padding(.horizontal, 32)
        }
        .padding(.top, 60)
    }
    
    // MARK: - Helper Methods
    private func tabTitle(for index: Int) -> String {
        switch index {
        case 0: return "Overview"
        case 1: return "All Bets"
        case 2: return "Head-to-Head"
        default: return ""
        }
    }
    
    private func loadMemberBets() {
        isLoadingBets = true
        // Filter bets for this member in this community
        memberBets = firestoreService.bets.filter { bet in
            bet.community_id == (community.id ?? "") && 
            bet.creator_email == "member\(memberIndex + 1)@example.com" // Mock email
        }
        isLoadingBets = false
    }
}

// MARK: - Trading Profile View

struct TradingProfileView: View {
    let userId: String
    let userName: String
    let displayName: String?
    let isCurrentUser: Bool
    let firestoreService: FirestoreService
    @Environment(\.dismiss) private var dismiss
    @State private var selectedTab = 0 // 0 = Activity, 1 = Recent Bets
    @State private var userBets: [FirestoreBet] = []
    @State private var isLoadingBets = false
    @State private var userData: FirestoreUser?
    @State private var isLoadingUserData = false
    @State private var showingUserSettings = false
    @State private var userActivityItems: [UserActivityItem] = []
    @State private var isLoadingActivity = false
    @StateObject private var timeTracker = TimeTracker()
    @State private var previousTab = 0
    
    // Fullscreen image state
    @State private var showImageFullscreen = false
    @State private var selectedImageUrl: String?
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                headerSection
                quickStatsSection
                tabSelectorSection
                tabContentSection
            }
        .background(Color.white)
            .navigationBarHidden(true)
            .animation(.easeInOut(duration: 0.3), value: selectedTab)
            .onAppear {
                // Track profile view
                AnalyticsService.shared.trackProfileInteraction(action: .view, profileId: userId, profileType: isCurrentUser ? "current_user" : "member_profile")
                AnalyticsService.shared.trackUserFlowStep(step: .profile)
                timeTracker.startTracking(for: "trading_profile")
                
                loadUserData()
                loadUserBets()
                loadUserActivity()
            }
            .onDisappear {
                // Track time spent on profile
                if let duration = timeTracker.endTracking(for: "trading_profile") {
                    AnalyticsService.shared.trackPageViewTime(page: "trading_profile", timeSpent: duration)
                }
            }
            .onChange(of: selectedTab) { oldValue, newValue in
                if newValue == 0 { // Activity tab
                    loadUserActivity()
                }
            }
            .sheet(isPresented: $showingUserSettings) {
                UserSettingsView(
                    userData: userData,
                    firestoreService: firestoreService
                )
            }
            .fullScreenCover(isPresented: $showImageFullscreen) {
                if let imageUrl = selectedImageUrl {
                    FullscreenImageView(imageUrl: imageUrl, isPresented: $showImageFullscreen)
                }
            }
        }
    }
    
    // MARK: - Header Section
    private var headerSection: some View {
        VStack(spacing: 0) {
            // Navigation Header
            HStack {
                        Button(action: { 
                            AnalyticsService.shared.trackFeatureUsage(feature: "profile_close", context: "trading_profile")
                            dismiss() 
                        }) {
                            Image(systemName: "arrow.left")
                                .font(.title2)
                                .foregroundColor(.black)
                                .frame(width: 44, height: 44)
                        }
                
                Spacer()
                
                Text("Profile")
                    .font(.headline)
                    .fontWeight(.bold)
                    .foregroundColor(.black)
                
                Spacer()
                
                if isCurrentUser {
                    Button(action: {
                        AnalyticsService.shared.trackProfileInteraction(action: .settings, profileId: userId, profileType: "current_user")
                        showingUserSettings = true
                    }) {
                        Image(systemName: "gearshape")
                            .font(.title3)
                            .foregroundColor(.black)
                            .frame(width: 44, height: 44)
                    }
                } else {
                    Button(action: {
                        AnalyticsService.shared.trackProfileInteraction(action: .share, profileId: userId, profileType: "member_profile")
                        // Share functionality for member profiles
                    }) {
                        Image(systemName: "square.and.arrow.up")
                            .font(.title3)
                            .foregroundColor(.black)
                            .frame(width: 44, height: 44)
                    }
                }
            }
            .padding(.horizontal, 16)
            .padding(.top, 12)
            .padding(.bottom, 20)
            .background(Color.white)
            
            // User Info Card
                    VStack(spacing: 16) {
                HStack(spacing: 16) {
                    // Avatar - User Profile Picture or Initials - Enhanced with click handlers
                    ZStack {
                        if let profilePictureUrl = userData?.profile_picture_url {
                            // Show user's profile picture
                            AsyncImage(url: URL(string: profilePictureUrl)) { phase in
                                switch phase {
                                case .success(let image):
                                    image
                                        .resizable()
                                        .aspectRatio(contentMode: .fill)
                                        .frame(width: 80, height: 80)
                                        .clipShape(Circle())
                                        .overlay(
                                            Circle()
                                                .stroke(Color.white, lineWidth: 3)
                                        )
                                        .onTapGesture {
                                            // Show fullscreen image
                                            selectedImageUrl = profilePictureUrl
                                            showImageFullscreen = true
                                        }
                                case .failure(_):
                                    // Fallback to initials on error
                                    Circle()
                                        .fill(Color.white)
                                        .frame(width: 80, height: 80)
                                        .overlay(
                                            Text(getUserInitialsFromName())
                                                .font(.largeTitle)
                                                .fontWeight(.semibold)
                                                .foregroundColor(.slingBlue)
                                        )
                                        .overlay(
                                            Circle()
                                                .stroke(Color.white, lineWidth: 3)
                                        )
                                        .onTapGesture {
                                            // For member profiles, we can't change the picture
                                            // Just show fullscreen if there's an image
                                        }
                                case .empty:
                                    // Show initials while loading
                                    Circle()
                                        .fill(Color.white)
                                        .frame(width: 80, height: 80)
                                        .overlay(
                                            Text(getUserInitialsFromName())
                                                .font(.largeTitle)
                                                .fontWeight(.semibold)
                                                .foregroundColor(.slingBlue)
                                        )
                                        .overlay(
                                            Circle()
                                                .stroke(Color.white, lineWidth: 3)
                                        )
                                        .onTapGesture {
                                            // For member profiles, we can't change the picture
                                            // Just show fullscreen if there's an image
                                        }
                                @unknown default:
                                    Circle()
                                        .fill(Color.white)
                                        .frame(width: 80, height: 80)
                                        .overlay(
                                            Text(getUserInitialsFromName())
                                                .font(.largeTitle)
                                                .fontWeight(.semibold)
                                                .foregroundColor(.slingBlue)
                                        )
                                        .overlay(
                                            Circle()
                                                .stroke(Color.white, lineWidth: 3)
                                        )
                                        .onTapGesture {
                                            // For member profiles, we can't change the picture
                                            // Just show fullscreen if there's an image
                                        }
                                }
                            }
                        } else {
                            // Fallback to initials
                            Circle()
                                .fill(Color.white)
                                .frame(width: 80, height: 80)
                                .overlay(
                                    Text(getUserInitialsFromName())
                                        .font(.largeTitle)
                                        .fontWeight(.bold)
                                        .foregroundColor(.slingBlue)
                                )
                                .overlay(
                                    Circle()
                                        .stroke(Color.white, lineWidth: 3)
                                )
                                .onTapGesture {
                                    // For member profiles, we can't change the picture
                                    // Just show fullscreen if there's an image
                                }
                        }
                        
                        // For member profiles, we don't show a swap icon since users can't change other people's pictures
                        // Only show swap icon if this is the current user's profile
                        if isCurrentUser {
                            // Swap icon overlay at 3-6 o'clock position
                            Circle()
                                .fill(Color.slingBlue)
                                .frame(width: 28, height: 28)
                                .overlay(
                                    Image(systemName: "arrow.2.squarepath")
                                        .font(.system(size: 12, weight: .medium))
                                        .foregroundColor(.white)
                                )
                                .overlay(
                                    Circle()
                                        .stroke(Color.white, lineWidth: 2)
                                )
                                .offset(x: 28, y: 28) // Position at 3-6 o'clock (half on, half off)
                                .onTapGesture {
                                    // Change picture - this would open edit profile
                                    showingUserSettings = true
                                }
                        }
                    }
                            
                    VStack(alignment: .leading, spacing: 4) {
                        // User Name
                        Text(userData?.full_name ?? userName)
                                    .font(.title2)
                                    .fontWeight(.bold)
                                    .foregroundColor(.white)
                                
                        // Display Name
                        Text("@\(userData?.display_name ?? displayName ?? "user")")
                                    .font(.subheadline)
                                    .foregroundColor(.white.opacity(0.9))
                                
                        // Member since date
                        Text("Member since \(getAbbreviatedDate())")
                                    .font(.caption)
                                    .foregroundColor(.white.opacity(0.8))
                            }
                    
                    Spacer()
                    
                    // Edit Profile Button - White pencil icon
                    if isCurrentUser {
                        Button(action: {
                            showingUserSettings = true
                        }) {
                            Image(systemName: "pencil")
                                .font(.title3)
                                .foregroundColor(.white)
                                .frame(width: 32, height: 32)
                                .background(Color.white.opacity(0.2))
                                .clipShape(Circle())
                                .overlay(
                                    Circle()
                                        .stroke(Color.white.opacity(0.3), lineWidth: 1)
                                )
                        }
                    }

                }
            }
            .padding(20)
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(AnyShapeStyle(Color.slingGradient))
            )
            .padding(.horizontal, 16)
        }
        .background(Color.white)
    }
    
        // MARK: - Quick Stats Section
    private var quickStatsSection: some View {
        VStack(spacing: 8) {
            Text("Quick Stats")
                .font(.headline)
                .fontWeight(.semibold)
                .foregroundColor(.black)
                .frame(maxWidth: .infinity, alignment: .leading)
                .padding(.horizontal, 16)
                .padding(.top, 20)
                .padding(.bottom, 8)
            
            // Performance Grid - Horizontal scroll
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    CommunityPerformanceCard(icon: "person.2", value: "\(getUserCommunityCount())", label: "Communities", color: .slingBlue)
                    CommunityPerformanceCard(icon: "target", value: "\(userData?.total_bets ?? 0)", label: "Total Bets", color: .slingBlue)
                    CommunityPerformanceCard(icon: "bolt.fill", value: "\(formatNumber(userData?.blitz_points ?? 0))", label: "Sling Points", color: .slingBlue)
                    CommunityPerformanceCard(icon: "flame.fill", value: "\(getUserStreak())", label: "Streak", color: .slingBlue)
                }
                .padding(.horizontal, 16)
            }
        }
        .padding(.horizontal, 16)
    }
    
    // MARK: - Tab Selector Section
    private var tabSelectorSection: some View {
        VStack(spacing: 0) {
            HStack(spacing: 0) {
                Button(action: { 
                    AnalyticsService.shared.trackProfileTabSwitch(fromTab: getTabName(previousTab), toTab: "activity", profileId: userId)
                    previousTab = selectedTab
                    selectedTab = 0 
                }) {
                    VStack(spacing: 4) {
                        Text("Activity")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(selectedTab == 0 ? .slingBlue : .gray)
                        
                        Rectangle()
                            .fill(selectedTab == 0 ? Color.slingBlue : Color.clear)
                            .frame(height: 2)
                    }
                }
                .frame(maxWidth: .infinity)
                
                Button(action: { 
                    AnalyticsService.shared.trackProfileTabSwitch(fromTab: getTabName(previousTab), toTab: "recent_bets", profileId: userId)
                    previousTab = selectedTab
                    selectedTab = 1 
                }) {
                    VStack(spacing: 4) {
                        Text("Recent Bets")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(selectedTab == 1 ? .slingBlue : .gray)
                        
                        Rectangle()
                            .fill(selectedTab == 1 ? Color.slingBlue : Color.clear)
                            .frame(height: 2)
                    }
                }
                .frame(maxWidth: .infinity)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .background(Color.white)
            
            // Horizontal line under tabs
            Rectangle()
                .frame(height: 0.5)
                .foregroundColor(Color.gray.opacity(0.3))
        }
    }
                
    // MARK: - Tab Content Section
    private var tabContentSection: some View {
                TabView(selection: $selectedTab) {
            overviewTab.tag(0)
            recentBetsTab.tag(1)
                }
                .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
            }
    
    // MARK: - Tab Content Views
    private var overviewTab: some View {
        ScrollView {
            VStack(spacing: 0) {
                if userActivityItems.isEmpty {
                    // Empty State
                    VStack(spacing: 20) {
                        Spacer()
                        
                        Image(systemName: "clock.arrow.circlepath")
                            .font(.system(size: 60))
                            .foregroundColor(.gray.opacity(0.5))
                        
                        VStack(spacing: 8) {
                            Text("No activity yet")
                                .font(.title2)
                                .fontWeight(.semibold)
                                .foregroundColor(.primary)
                            
                            Text("Your betting activity will appear here")
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                                .multilineTextAlignment(.center)
                        }
                        
                        Spacer()
                    }
                    .padding(.horizontal, 40)
                    .padding(.top, 60)
                } else {
                    // Activity List
                    LazyVStack(spacing: 1) {
                        ForEach(userActivityItems) { activityItem in
                            ActivityRow(activityItem: activityItem)
                                .transition(.opacity.combined(with: .move(edge: .leading)))
                        }
                    }
                    .padding(.top, 8)
                    .animation(.easeInOut(duration: 0.3), value: userActivityItems.count)
                }
            }
        }
        .refreshable {
            loadUserActivity()
        }
    }
    
    private var recentBetsTab: some View {
        ScrollView {
            LazyVStack(spacing: 16) {
                if isLoadingBets {
                    ForEach(0..<3, id: \.self) { _ in
                        BetLoadingRow()
                    }
                } else if userBets.isEmpty {
                    EmptyActiveBetsView(firestoreService: firestoreService)
                } else {
                    ForEach(userBets.prefix(5), id: \.id) { bet in
                        RecentBetRow(bet: bet)
                    }
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 20)
        }
        .refreshable {
            await refreshBets()
        }
    }
    

    
    // MARK: - Helper Methods
    private func loadUserBets() {
        isLoadingBets = true
        
        // Get bets where the user is either the creator or a participant
        let userEmail = userId // Use the userId parameter instead of currentUser
        
        // Filter bets where user is creator
        let userCreatedBets = firestoreService.bets.filter { bet in
            bet.creator_email == userEmail
        }
        
        // Sort by creation date (newest first)
        let sortedBets = userCreatedBets.sorted { $0.created_date > $1.created_date }
        
        DispatchQueue.main.async {
            self.userBets = sortedBets
            self.isLoadingBets = false
        }
    }
    
    private func loadUserActivity() {
        isLoadingActivity = true
        
        // Fetch the user's bet participations from Firestore
        firestoreService.fetchUserBetParticipations(for: userId) { userParticipations in
        
        // Create activity items from user's betting history
        var activityItems: [UserActivityItem] = []
        
        for participation in userParticipations {
                if let bet = self.firestoreService.bets.first(where: { $0.id == participation.bet_id }) {
                
                // Check if current user is a member of the community for privacy
                let isCurrentUserInCommunity = self.firestoreService.userCommunities.contains { $0.id == bet.community_id }
                
                // Create activity item for placing a bet
                let activityItem = UserActivityItem(
                    id: "\(participation.bet_id ?? "")_\(participation.user_email)_placed",
                    type: .betPlaced,
                    title: isCurrentUserInCommunity ? "Placed bet on '\(bet.title)'" : "Placed bet in a community",
                        subtitle: "Chose: \(participation.chosen_option) • Wager: ⚡ \(formatNumber(participation.stake_amount))",
                    communityName: getCommunityName(for: bet.community_id),
                    timestamp: bet.created_date,
                    icon: "bolt.fill",
                        iconColor: .slingBlue
                )
                activityItems.append(activityItem)
                
                // If bet is settled, create activity item for result
                if bet.status == "settled", let winnerOption = bet.winner_option {
                    let isWinner = participation.chosen_option == winnerOption
                        // Calculate payout amount for winners
                        let payoutAmount = isWinner ? calculatePayoutAmount(bet: bet, participation: participation) : Double(participation.stake_amount)
                        
                    let resultActivityItem = UserActivityItem(
                        id: "\(participation.bet_id ?? "")_\(participation.user_email)_result",
                        type: isWinner ? .betWon : .betLost,
                        title: isCurrentUserInCommunity ? 
                            (isWinner ? "Won bet on '\(bet.title)'" : "Lost bet on '\(bet.title)'") :
                            (isWinner ? "Won bet in a community" : "Lost bet in a community"),
                            subtitle: isWinner ? "Chose: \(participation.chosen_option) • Paid: ⚡ \(formatNumber(Int(payoutAmount)))" : "Chose: \(participation.chosen_option) • Lost: ⚡ \(formatNumber(participation.stake_amount))",
                        communityName: getCommunityName(for: bet.community_id),
                        timestamp: bet.deadline, // Use deadline as settlement time
                        icon: isWinner ? "trophy.fill" : "xmark.circle.fill",
                        iconColor: isWinner ? .green : .red
                    )
                    activityItems.append(resultActivityItem)
                } else if bet.status == "voided" {
                    // If bet is voided, create activity item for refund
                    let refundAmount = participation.final_payout ?? participation.stake_amount
                    let voidedActivityItem = UserActivityItem(
                        id: "\(participation.bet_id ?? "")_\(participation.user_email)_voided",
                        type: .betVoided,
                        title: isCurrentUserInCommunity ? "Bet voided on '\(bet.title)'" : "Bet voided in a community",
                        subtitle: "Chose: \(participation.chosen_option) • Refunded: ⚡ \(formatNumber(refundAmount))",
                        communityName: getCommunityName(for: bet.community_id),
                        timestamp: bet.deadline, // Use deadline as voiding time
                        icon: "arrow.clockwise.circle.fill",
                        iconColor: .orange
                    )
                    activityItems.append(voidedActivityItem)
                }
            }
        }
        
        // Sort by timestamp (most recent first)
        activityItems.sort { $0.timestamp > $1.timestamp }
        
        DispatchQueue.main.async {
                userActivityItems = activityItems
                isLoadingActivity = false
            }
        }
    }
    
    private func getCommunityName(for communityId: String) -> String? {
        if let community = firestoreService.userCommunities.first(where: { $0.id == communityId }) {
            return community.name
        }
        return nil
    }
    
    private func refreshBets() async {
        await MainActor.run {
            loadUserBets()
        }
    }
    
    private func getUserBetCount() -> Int {
        return userBets.count
    }
    
    private func getUserCommunityCount() -> Int {
        return firestoreService.userCommunities.count
    }
    
    private func getUserStreak() -> Int {
        // For now, return 0 as we need to fetch participations separately
        // This could be enhanced to fetch and calculate streak for other users
        return 0
    }
    
    private func getAbbreviatedDate() -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM yyyy"
        return formatter.string(from: Date())
    }
    
    private func calculatePayoutAmount(bet: FirestoreBet, participation: BetParticipant) -> Double {
        // Calculate total pool for the winning option
        let winningOptionParticipations = firestoreService.userBetParticipations.filter { p in
            p.bet_id == bet.id && p.chosen_option == bet.winner_option
        }
        let totalWinningPool = winningOptionParticipations.reduce(0) { $0 + $1.stake_amount }
        
        // Calculate user's share of the pool
        if totalWinningPool > 0 {
            let userShare = Double(participation.stake_amount) / Double(totalWinningPool)
            let totalPool = Double(bet.total_pool ?? 0)
            return userShare * totalPool
        }
        
        return Double(participation.stake_amount)
    }
    
    private func formatNumber(_ number: Int) -> String {
        let formatter = NumberFormatter()
        formatter.numberStyle = .decimal
        formatter.maximumFractionDigits = 0
        return formatter.string(from: NSNumber(value: number)) ?? "\(number)"
    }
    
    private func loadUserData() {
        isLoadingUserData = true
        
        Task {
            do {
                let user = try await firestoreService.getUser(userId: userId)
                await MainActor.run {
                    self.userData = user
                    self.isLoadingUserData = false
                    
                    // Log all user data from Firestore
                    print("📱 User Profile Data Loaded:")
                    print("   User ID: \(user.id ?? "nil")")
                    print("   UID: \(user.uid ?? "nil")")
                    print("   Email: \(user.email)")
                    print("   First Name: \(user.first_name ?? "nil")")
                    print("   Last Name: \(user.last_name ?? "nil")")
                    print("   Full Name: \(user.full_name ?? "nil")")
                    print("   Display Name: \(user.display_name ?? "nil")")
                    print("   Sling Points: \(user.sling_points ?? 0)")
                    print("   Blitz Points: \(user.blitz_points ?? 0)")
                    print("   Total Bets: \(user.total_bets ?? 0)")
                    print("   Total Winnings: \(user.total_winnings ?? 0)")
                    print("   Document ID: \(user.documentId ?? "nil")")
                    
                    // Log computed properties
                    print("   Computed Display Name: \(user.displayName)")
                    print("   Computed First Name: \(user.firstName ?? "nil")")
                    print("   Computed Last Name: \(user.lastName ?? "nil")")
                }
            } catch {
                print("❌ Error loading user data: \(error)")
                await MainActor.run {
                    self.isLoadingUserData = false
                }
            }
        }
    }
    
    // MARK: - Helper Methods
    private func getUserInitialsFromName() -> String {
        // For current user, prioritize first and last name from database
        if isCurrentUser {
            let user = firestoreService.currentUser
            
            // Prioritize first and last name to get both initials
            if let firstName = user?.first_name, let lastName = user?.last_name, !firstName.isEmpty, !lastName.isEmpty {
                let firstInitial = String(firstName.prefix(1)).uppercased()
                let lastInitial = String(lastName.prefix(1)).uppercased()
                return "\(firstInitial)\(lastInitial)"
            }
            
            // If we have first name but no last name, try to get second initial from display name
            if let firstName = user?.first_name, !firstName.isEmpty {
                let firstInitial = String(firstName.prefix(1)).uppercased()
                if let displayName = user?.display_name, !displayName.isEmpty {
                    let components = displayName.components(separatedBy: " ")
                    if components.count >= 2 {
                        let lastInitial = String(components[1].prefix(1)).uppercased()
                        return "\(firstInitial)\(lastInitial)"
                    }
                }
                return firstInitial
            }
            
            // Fallback to display name parsing
            if let displayName = user?.display_name, !displayName.isEmpty {
                let components = displayName.components(separatedBy: " ")
                if components.count >= 2 {
                    let firstInitial = String(components[0].prefix(1)).uppercased()
                    let lastInitial = String(components[1].prefix(1)).uppercased()
                    return "\(firstInitial)\(lastInitial)"
                } else if components.count == 1 {
                    return String(components[0].prefix(1)).uppercased()
                }
            }
            
            // Final fallback to email
            if let email = user?.email {
                return String(email.prefix(1)).uppercased()
            }
        } else {
            // For other users, use the passed displayName or userName
        if let displayName = displayName, !displayName.isEmpty {
            let components = displayName.components(separatedBy: " ")
            if components.count >= 2 {
                let firstInitial = String(components[0].prefix(1)).uppercased()
                let lastInitial = String(components[1].prefix(1)).uppercased()
                return "\(firstInitial)\(lastInitial)"
            } else if components.count == 1 {
                return String(components[0].prefix(1)).uppercased()
            }
        } else if !userName.isEmpty {
            let components = userName.components(separatedBy: " ")
            if components.count >= 2 {
                let firstInitial = String(components[0].prefix(1)).uppercased()
                let lastInitial = String(components[1].prefix(1)).uppercased()
                return "\(firstInitial)\(lastInitial)"
            } else {
                return String(userName.prefix(1)).uppercased()
            }
        }
        }
        
        return "U"
    }
    
    // MARK: - Helper Methods
    
    private func getTabName(_ tabIndex: Int) -> String {
        switch tabIndex {
        case 0: return "activity"
        case 1: return "recent_bets"
        default: return "unknown"
        }
    }
}

// MARK: - Supporting Views for Trading Profile

struct UserSettingsView: View {
    let userData: FirestoreUser?
    let firestoreService: FirestoreService
    @Environment(\.dismiss) private var dismiss
    @State private var showingEditProfile = false
    @State private var showingDeleteAccount = false
    @State private var showingSignOut = false
    @State private var darkModeEnabled = false
    @State private var showingPushNotifications = false
    @State private var showingEmailNotifications = false
    @State private var showingProfileVisibility = false
    @State private var showingChangePassword = false
    @State private var showingLanguageSettings = false
    @State private var showingContactSupport = false
    @State private var showingTermsOfService = false
    @State private var showingPrivacyPolicy = false
    @State private var showingLanguageError = false
    @State private var showingDarkModeError = false
    @StateObject private var timeTracker = TimeTracker()
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                headerSection
                
                // Settings Content
                ScrollView {
                    VStack(spacing: 24) {
                        // Profile Section
                        profileSection
                        
                        // Notifications Section
                        notificationsSection
                        
                        // Privacy & Security Section
                        privacySecuritySection
                        
                        // App Preferences Section
                        appPreferencesSection
                        
                        // Account Management Section
                        accountManagementSection
                        
                        // Support Section
                        supportSection
                        
                        // Danger Zone
                        dangerZoneSection
                }
                .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
            .sheet(isPresented: $showingEditProfile) {
                EditProfileView(firestoreService: firestoreService)
                    .onAppear {
                        print("🔧 Sheet presenting: EditProfileView")
                    }
            }

            .sheet(isPresented: $showingPushNotifications) {
                PushNotificationsView(firestoreService: firestoreService)
                    .onAppear {
                        print("🔧 Sheet presenting: PushNotificationsView")
                    }
            }
            .sheet(isPresented: $showingEmailNotifications) {
                EmailNotificationsView(firestoreService: firestoreService)
            }

            .sheet(isPresented: $showingProfileVisibility) {
                ProfileVisibilityView(firestoreService: firestoreService)
            }
            .sheet(isPresented: $showingChangePassword) {
                ChangePasswordView()
                    .onAppear {
                        print("🔧 Sheet presenting: ChangePasswordView")
                    }
            }
            .sheet(isPresented: $showingLanguageSettings) {
                LanguageSettingsView(firestoreService: firestoreService)
                    .onAppear {
                        print("🔧 Sheet presenting: LanguageSettingsView")
                    }
            }
            .sheet(isPresented: $showingContactSupport) {
                ContactSupportView(firestoreService: firestoreService)
            }

            .sheet(isPresented: $showingTermsOfService) {
                TermsOfServiceView()
            }
            .sheet(isPresented: $showingPrivacyPolicy) {
                PrivacyPolicyView()
            }

            .sheet(isPresented: $showingDeleteAccount) {
                DeleteAccountView()
            }
            .sheet(isPresented: $showingSignOut) {
                SignOutView(firestoreService: firestoreService)
            }
            .alert("Feature Coming Soon", isPresented: $showingLanguageError) {
                Button("OK") { }
            } message: {
                Text("Language selection will be available in a future update. For now, the app is only available in English.")
            }
            .alert("Feature Coming Soon", isPresented: $showingDarkModeError) {
                Button("OK") { }
            } message: {
                Text("Dark mode will be available in a future update. Stay tuned for this feature!")
            }
            .onAppear {
                // Track settings page view
                AnalyticsService.shared.trackUserFlowStep(step: .settings)
                AnalyticsService.shared.trackFeatureUsage(feature: "settings_page", context: "profile")
                AnalyticsService.shared.trackSettingsSectionView(section: "main")
                timeTracker.startTracking(for: "settings_page")
                
                print("🔧 UserSettingsView body rendered")
                // Ensure user settings exist in Firestore
                firestoreService.ensureUserSettingsExist { success in
                    if success {
                        print("✅ User settings ensured in Firestore")
                        // Load current user settings
                        self.loadCurrentUserSettings()
                    } else {
                        print("❌ Failed to ensure user settings in Firestore")
                    }
                }
            }
            .onDisappear {
                // Track time spent on settings page
                if let duration = timeTracker.endTracking(for: "settings_page") {
                    AnalyticsService.shared.trackPageViewTime(page: "settings_page", timeSpent: duration)
                }
            }
        }
    }
    
    // MARK: - Helper Methods
    
    private func loadCurrentUserSettings() {
        guard let user = firestoreService.currentUser else { return }
        
        // Load dark mode setting
        if let darkMode = user.dark_mode_enabled {
            darkModeEnabled = darkMode
        }
        
        // Load language setting
        if let language = user.language {
            // Update the language display in the UI
            print("🔧 Loaded language setting: \(language)")
        }
        
        print("🔧 Loaded current user settings")
    }
    
    // MARK: - Header Section
    private var headerSection: some View {
        HStack {
            Button(action: { 
                AnalyticsService.shared.trackFeatureUsage(feature: "settings_close", context: "settings_page")
                dismiss() 
            }) {
                Image(systemName: "arrow.left")
                    .font(.title2)
                    .foregroundColor(.slingBlue)
                    .frame(width: 44, height: 44)
            }
            
            Spacer()
            
            Text("Settings")
                .font(.title2)
                .fontWeight(.bold)
                .foregroundColor(.black)
            
            Spacer()
            
            Button(action: { 
                AnalyticsService.shared.trackFeatureUsage(feature: "settings_close_x", context: "settings_page")
                dismiss() 
            }) {
                Image(systemName: "xmark")
                    .font(.title2)
                    .foregroundColor(.gray)
                    .frame(width: 44, height: 44)
            }
        }
        .padding(.horizontal, 16)
        .padding(.top, 12)
        .padding(.bottom, 20)
        .background(Color.white)
    }
    
    // MARK: - Profile Section
    private var profileSection: some View {
        VStack(spacing: 16) {
            HStack {
                Text("Profile")
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                Spacer()
            }
            
            VStack(spacing: 0) {
                SettingsRow(icon: "person.circle", title: "Edit Profile", subtitle: "Update your personal information", isDestructive: false, action: {
                    AnalyticsService.shared.trackSettingsInteraction(action: .tap, settingType: "edit_profile")
                    AnalyticsService.shared.trackSettingsSectionView(section: "profile")
                    print("🔧 Edit Profile button tapped")
                    showingEditProfile = true
                    print("🔧 showingEditProfile set to: \(showingEditProfile)")
                })
                Divider().padding(.leading, 56)
                SettingsRow(icon: "key", title: "Change Password", subtitle: "Update your password", isDestructive: false, action: {
                    AnalyticsService.shared.trackSettingsInteraction(action: .tap, settingType: "change_password")
                    AnalyticsService.shared.trackSettingsSectionView(section: "profile")
                    print("🔧 Change Password button tapped")
                    showingChangePassword = true
                    print("🔧 showingChangePassword set to: \(showingChangePassword)")
                })
                Divider().padding(.leading, 56)
                SettingsRow(icon: "eye", title: "Profile Visibility", subtitle: "What's displayed on your profile page", isDestructive: false, action: {
                    AnalyticsService.shared.trackSettingsInteraction(action: .tap, settingType: "profile_visibility")
                    AnalyticsService.shared.trackSettingsSectionView(section: "profile")
                    print("🔧 Profile Visibility button tapped")
                    showingProfileVisibility = true
                    print("🔧 showingProfileVisibility set to: \(showingProfileVisibility)")
                })
            }
            .background(Color.white)
            .cornerRadius(12)
        }
    }
    
    // MARK: - Notifications Section
    private var notificationsSection: some View {
        VStack(spacing: 16) {
            HStack {
                Text("Notifications")
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                Spacer()
            }
            
            VStack(spacing: 0) {
                SettingsRow(icon: "bell", title: "Push Notifications", subtitle: "Bet updates and community alerts", isDestructive: false, action: {
                    AnalyticsService.shared.trackSettingsInteraction(action: .tap, settingType: "push_notifications")
                    AnalyticsService.shared.trackSettingsSectionView(section: "notifications")
                    print("🔧 Push Notifications button tapped")
                    showingPushNotifications = true
                    print("🔧 showingPushNotifications set to: \(showingPushNotifications)")
                })
                Divider().padding(.leading, 56)
                SettingsRow(icon: "envelope", title: "Email Notifications", subtitle: "Weekly summaries and updates", isDestructive: false, action: {
                    AnalyticsService.shared.trackSettingsInteraction(action: .tap, settingType: "email_notifications")
                    AnalyticsService.shared.trackSettingsSectionView(section: "notifications")
                    print("🔧 Email Notifications button tapped")
                    showingEmailNotifications = true
                    print("🔧 showingEmailNotifications set to: \(showingEmailNotifications)")
                })
            }
            .background(Color.white)
            .cornerRadius(12)
        }
    }
    
    // MARK: - Privacy & Security Section
    private var privacySecuritySection: some View {
        VStack(spacing: 16) {
            HStack {
                Text("Privacy & Security")
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                Spacer()
            }
            
            VStack(spacing: 0) {
                // Privacy settings can be added here in the future
            }
            .background(Color.white)
            .cornerRadius(12)
        }
    }
    
    // MARK: - App Preferences Section
    private var appPreferencesSection: some View {
        VStack(spacing: 16) {
            HStack {
                Text("App Preferences")
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                Spacer()
            }
            
            VStack(spacing: 0) {
                HStack {
                    SettingsRow(icon: "moon.fill", title: "Dark Mode", subtitle: "Switch to dark theme", isDestructive: false, showArrow: false, action: {})
                    Spacer()
                    Toggle("", isOn: $darkModeEnabled)
                        .labelsHidden()
                        .scaleEffect(0.8)
                        .tint(.slingBlue)
                        .padding(.trailing, 16)
                        .onChange(of: darkModeEnabled) { _, newValue in
                            print("🔧 Dark mode toggle attempted - feature coming soon!")
                            // Reset the toggle to its original state
                            darkModeEnabled = false
                            // Show coming soon popup
                            showingDarkModeError = true
                        }
                }
            }
            .background(Color.white)
            .cornerRadius(12)
        }
    }
    
    // MARK: - Account Management Section
    private var accountManagementSection: some View {
        VStack(spacing: 16) {
            HStack {
                Text("Account Management")
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                Spacer()
            }
            
            VStack(spacing: 0) {
                SettingsRow(icon: "globe", title: "Language", subtitle: "English", isDestructive: false, showArrow: false, action: {
                    print("🔧 Language button tapped - feature coming soon!")
                    showingLanguageError = true
                })
            }
            .background(Color.white)
            .cornerRadius(12)
        }
    }
    
    // MARK: - Support Section
    private var supportSection: some View {
        VStack(spacing: 16) {
            HStack {
                Text("Help & Support")
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                Spacer()
            }
            
            VStack(spacing: 0) {
                SettingsRow(icon: "message", title: "Contact Us", subtitle: "Get help from our team", isDestructive: false, action: {
                    print("🔧 Contact Us button tapped")
                    showingContactSupport = true
                    print("🔧 showingContactSupport set to: \(showingContactSupport)")
                })
                Divider().padding(.leading, 56)
                SettingsRow(icon: "doc.text", title: "Terms of Service", subtitle: "Read our terms and conditions", isDestructive: false, action: {
                    print("🔧 Terms of Service button tapped")
                    showingTermsOfService = true
                    print("🔧 showingTermsOfService set to: \(showingTermsOfService)")
                })
                Divider().padding(.leading, 56)
                SettingsRow(icon: "hand.raised", title: "Privacy Policy", subtitle: "Learn about data privacy", isDestructive: false, action: {
                    print("🔧 Privacy Policy button tapped")
                    showingPrivacyPolicy = true
                    print("🔧 showingPrivacyPolicy set to: \(showingPrivacyPolicy)")
                })
            }
            .background(Color.white)
            .cornerRadius(12)
        }
    }
    
    // MARK: - Danger Zone Section
    private var dangerZoneSection: some View {
        VStack(spacing: 16) {
            HStack {
                Text("Danger Zone")
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.red)
                Spacer()
            }
            
            VStack(spacing: 0) {
                SettingsRow(icon: "rectangle.portrait.and.arrow.right", title: "Sign Out", subtitle: "Sign out of your account", isDestructive: true, action: {
                    print("🔧 Sign Out button tapped")
                    showingSignOut = true
                    print("🔧 showingSignOut set to: \(showingSignOut)")
                })
                Divider().padding(.leading, 56)
                SettingsRow(icon: "trash", title: "Delete Account", subtitle: "Permanently delete your account", isDestructive: true, action: {
                    print("🔧 Delete Account button tapped")
                    showingDeleteAccount = true
                    print("🔧 showingDeleteAccount set to: \(showingDeleteAccount)")
                })
            }
            .background(Color.white)
            .cornerRadius(12)
        }
    }
}

// MARK: - Profile Picture View
struct ProfilePictureView: View {
    let userData: FirestoreUser?
    let firestoreService: FirestoreService
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                            .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                    
                    Text("Profile Picture")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.gray)
                            .frame(width: 44, height: 44)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 20)
                .background(Color.white)
                
                // Content
                ScrollView {
                    VStack(spacing: 24) {
                        // Current Picture
                        VStack(spacing: 16) {
                            HStack {
                                Text("Current Picture")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            Circle()
                                .fill(Color.white)
                                .frame(width: 120, height: 120)
                                .overlay(
                                    Text(String(userData?.full_name?.prefix(1) ?? "U").uppercased())
                                        .font(.largeTitle)
                                        .fontWeight(.bold)
                                        .foregroundColor(.slingBlue)
                                )
                                .overlay(
                                    Circle()
                                        .stroke(Color.slingBlue, lineWidth: 3)
                                )
                        }
                        .padding(20)
                        .background(Color.white)
                        .cornerRadius(12)
                        
                        // Upload Options
                        VStack(spacing: 16) {
                            HStack {
                                Text("Upload New Picture")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            VStack(spacing: 12) {
                                Button(action: {
                                    // TODO: Implement camera capture
                                    print("Camera tapped")
                                }) {
                                    HStack {
                                        Image(systemName: "camera")
                                            .font(.title2)
                                            .foregroundColor(.slingBlue)
                                        Text("Take Photo")
                                            .font(.subheadline)
                                            .fontWeight(.medium)
                                            .foregroundColor(.black)
                                        Spacer()
                                    }
                                    .padding(16)
                                    .background(Color.white)
                                    .cornerRadius(8)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 8)
                                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                    )
                                }
                                
                                Button(action: {
                                    // TODO: Implement photo library
                                    print("Photo library tapped")
                                }) {
                                    HStack {
                                        Image(systemName: "photo.on.rectangle")
                                            .font(.title2)
                                            .foregroundColor(.slingBlue)
                                        Text("Choose from Library")
                                            .font(.subheadline)
                                            .fontWeight(.medium)
                                            .foregroundColor(.black)
                                        Spacer()
                                    }
                                    .padding(16)
                                    .background(Color.white)
                                    .cornerRadius(8)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 8)
                                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                    )
                                }
                            }
                        }
                        .padding(20)
                        .background(Color.white)
                        .cornerRadius(12)
                    }
                    .padding(.horizontal, 16)
            .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
        }
    }
}

// MARK: - Push Notifications View
struct PushNotificationsView: View {
    @Environment(\.dismiss) private var dismiss
    @ObservedObject var firestoreService: FirestoreService
    @State private var betUpdates = true
    @State private var communityAlerts = true
    @State private var newMessages = true
    @State private var weeklySummaries = false
    @State private var newMembersJoined = true
    @State private var membersLeft = true
    @State private var hotBetsTrending = true
    @State private var outstandingBalances = true
    @State private var isLoading = false
    @State private var showingSaveSuccess = false
    @State private var showingUnsavedChangesAlert = false
    
    // Original values to track changes
    @State private var originalBetUpdates = true
    @State private var originalCommunityAlerts = true
    @State private var originalNewMessages = true
    @State private var originalWeeklySummaries = false
    @State private var originalNewMembersJoined = true
    @State private var originalMembersLeft = true
    @State private var originalHotBetsTrending = true
    @State private var originalOutstandingBalances = true
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                HStack {
                    Button(action: { 
                        if hasUnsavedChanges() {
                            showingUnsavedChangesAlert = true
                        } else {
                            dismiss()
                        }
                    }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.black)
                            .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                    
                    Text("Push Notifications")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    Button(action: {
                        savePreferences()
                    }) {
                        Text("Save")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(.slingBlue)
                    }
                    .disabled(isLoading)
                }
                .padding(.horizontal, 20)
                .padding(.top, 20)
                
                // Content
        ScrollView {
                    VStack(spacing: 24) {
            VStack(spacing: 16) {
                            HStack {
                                Text("Bet & Community")
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            VStack(spacing: 0) {
                                HStack {
                                    SettingsRow(icon: "target", title: "Bet Updates", subtitle: "Get notified about your bets", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $betUpdates)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                                Divider().padding(.leading, 56)
                                HStack {
                                    SettingsRow(icon: "person.3", title: "Community Alerts", subtitle: "New community activities", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $communityAlerts)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                                Divider().padding(.leading, 56)
                                HStack {
                                    SettingsRow(icon: "message", title: "New Messages", subtitle: "Direct messages and mentions", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $newMessages)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                                Divider().padding(.leading, 56)
                                HStack {
                                    SettingsRow(icon: "chart.bar", title: "Weekly Summaries", subtitle: "Your weekly performance", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $weeklySummaries)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                            }
                            .background(Color.white)
                            .cornerRadius(12)
                        }
                        
                        VStack(spacing: 16) {
                            HStack {
                                Text("Community Updates")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            VStack(spacing: 0) {
                                HStack {
                                    SettingsRow(icon: "person.badge.plus", title: "New Members Joined", subtitle: "When someone joins your community", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $newMembersJoined)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                                Divider().padding(.leading, 56)
                                HStack {
                                    SettingsRow(icon: "person.badge.minus", title: "Members Left", subtitle: "When someone leaves your community", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $membersLeft)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                                Divider().padding(.leading, 56)
                                HStack {
                                    SettingsRow(icon: "flame.fill", title: "Hot Bets Trending", subtitle: "Popular bets in your communities", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $hotBetsTrending)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                                Divider().padding(.leading, 56)
                                HStack {
                                    SettingsRow(icon: "exclamationmark.triangle", title: "Outstanding Balances", subtitle: "Updates on pending balances", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $outstandingBalances)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                            }
                            .background(Color.white)
                            .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
            .alert("Preferences Saved", isPresented: $showingSaveSuccess) {
                Button("OK") { }
            } message: {
                Text("Your notification preferences have been updated.")
            }
            .alert("Unsaved Changes", isPresented: $showingUnsavedChangesAlert) {
                Button("Leave", role: .destructive) { dismiss() }
                Button("Stay", role: .cancel) { }
            } message: {
                Text("You have unsaved changes. Are you sure you want to leave?")
            }
            .onAppear {
                loadCurrentUserSettings()
            }
        }
    }
    
    private func hasUnsavedChanges() -> Bool {
        return betUpdates != originalBetUpdates ||
               communityAlerts != originalCommunityAlerts ||
               newMessages != originalNewMessages ||
               weeklySummaries != originalWeeklySummaries ||
               newMembersJoined != originalNewMembersJoined ||
               membersLeft != originalMembersLeft ||
               hotBetsTrending != originalHotBetsTrending ||
               outstandingBalances != originalOutstandingBalances
    }
    
    private func savePreferences() {
        isLoading = true
        
        print("🔧 Saving push notification preferences")
        
        // Save push notification preferences to Firestore
        firestoreService.updatePushNotificationSettings(enabled: true) { success in
            DispatchQueue.main.async {
                self.isLoading = false
                if success {
                    print("✅ Push notification preferences saved to Firestore")
                    self.showingSaveSuccess = true
                    
                    // Update original values after successful save
                    self.originalBetUpdates = self.betUpdates
                    self.originalCommunityAlerts = self.communityAlerts
                    self.originalNewMessages = self.newMessages
                    self.originalWeeklySummaries = self.weeklySummaries
                    self.originalNewMembersJoined = self.newMembersJoined
                    self.originalMembersLeft = self.membersLeft
                    self.originalHotBetsTrending = self.hotBetsTrending
                    self.originalOutstandingBalances = self.outstandingBalances
                    
                    // Dismiss after showing success
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                        self.dismiss()
                    }
                } else {
                    print("❌ Failed to save push notification preferences")
                    // You could show an error alert here
                }
            }
        }
    }
    
    private func loadCurrentUserSettings() {
        guard let user = firestoreService.currentUser else { return }
        
        // Load current push notification settings
        if let pushEnabled = user.push_notifications_enabled {
            // Update the UI based on current settings
            print("🔧 Loaded push notification settings from Firestore: \(pushEnabled)")
        }
        
        // Set original values to track changes
        originalBetUpdates = betUpdates
        originalCommunityAlerts = communityAlerts
        originalNewMessages = newMessages
        originalWeeklySummaries = weeklySummaries
        originalNewMembersJoined = newMembersJoined
        originalMembersLeft = membersLeft
        originalHotBetsTrending = hotBetsTrending
        originalOutstandingBalances = outstandingBalances
        
        print("🔧 Loaded push notification settings from Firestore")
    }
}

// MARK: - Email Notifications View
struct EmailNotificationsView: View {
    @Environment(\.dismiss) private var dismiss
    @ObservedObject var firestoreService: FirestoreService
    @State private var weeklySummaries = true
    @State private var betResults = true
    @State private var communityUpdates = false
    @State private var promotionalEmails = false
    @State private var isLoading = false
    @State private var showingSaveSuccess = false
    @State private var showingUnsavedChangesAlert = false
    
    // Original values to track changes
    @State private var originalWeeklySummaries = true
    @State private var originalBetResults = true
    @State private var originalCommunityUpdates = false
    @State private var originalPromotionalEmails = false
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                HStack {
                    Button(action: { 
                        if hasUnsavedChanges() {
                            showingUnsavedChangesAlert = true
                        } else {
                            dismiss()
                        }
                    }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.black)
                            .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                    
                    Text("Email Notifications")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    Button(action: {
                        savePreferences()
                    }) {
                        Text("Save")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(.slingBlue)
                    }
                    .disabled(isLoading)
                }
                .padding(.horizontal, 20)
                .padding(.top, 20)
                
                // Content
                ScrollView {
                    VStack(spacing: 24) {
                        VStack(spacing: 16) {
                            HStack {
                                Text("Email Preferences")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            VStack(spacing: 0) {
                                HStack {
                                    SettingsRow(icon: "chart.bar", title: "Weekly Summaries", subtitle: "Your weekly performance", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $weeklySummaries)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                                Divider().padding(.leading, 56)
                                HStack {
                                    SettingsRow(icon: "target", title: "Bet Results", subtitle: "Final outcomes of your bets", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $betResults)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                                Divider().padding(.leading, 56)
                                HStack {
                                    SettingsRow(icon: "person.3", title: "Community Updates", subtitle: "New community activities", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $communityUpdates)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                                Divider().padding(.leading, 56)
                                HStack {
                                    SettingsRow(icon: "megaphone", title: "Promotional Emails", subtitle: "Special offers and updates", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $promotionalEmails)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                            }
                            .background(Color.white)
                            .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
            .alert("Preferences Saved", isPresented: $showingSaveSuccess) {
                Button("OK") { }
            } message: {
                Text("Your email notification preferences have been updated.")
            }
            .alert("Unsaved Changes", isPresented: $showingUnsavedChangesAlert) {
                Button("Leave", role: .destructive) { dismiss() }
                Button("Stay", role: .cancel) { }
            } message: {
                Text("You have unsaved changes. Are you sure you want to leave?")
            }
            .onAppear {
                loadCurrentUserSettings()
            }
        }
    }
    
    private func hasUnsavedChanges() -> Bool {
        return weeklySummaries != originalWeeklySummaries ||
               betResults != originalBetResults ||
               communityUpdates != originalCommunityUpdates ||
               promotionalEmails != originalPromotionalEmails
    }
    
    private func savePreferences() {
        isLoading = true
        
        print("🔧 Saving email notification preferences")
        
        // Save email notification preferences to Firestore
        firestoreService.updateEmailNotificationSettings(
            weeklySummaries: weeklySummaries,
            betResults: betResults,
            communityUpdates: communityUpdates,
            promotionalEmails: promotionalEmails
        ) { success in
            DispatchQueue.main.async {
                self.isLoading = false
                if success {
                    print("✅ Email notification preferences saved to Firestore")
                    self.showingSaveSuccess = true
                    
                    // Update original values after successful save
                    self.originalWeeklySummaries = self.weeklySummaries
                    self.originalBetResults = self.betResults
                    self.originalCommunityUpdates = self.communityUpdates
                    self.originalPromotionalEmails = self.promotionalEmails
                    
                    // Dismiss after showing success
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                        self.dismiss()
                    }
                } else {
                    print("❌ Failed to save email notification preferences")
                    // You could show an error alert here
                }
            }
        }
    }
    
    private func loadCurrentUserSettings() {
        guard let user = firestoreService.currentUser else { return }
        
        // Load current email notification settings
        if let weeklySummaries = user.weekly_summaries_enabled {
            self.weeklySummaries = weeklySummaries
        }
        if let betResults = user.bet_results_enabled {
            self.betResults = betResults
        }
        if let communityUpdates = user.community_updates_enabled {
            self.communityUpdates = communityUpdates
        }
        if let promotionalEmails = user.promotional_emails_enabled {
            self.promotionalEmails = promotionalEmails
        }
        
        // Set original values to track changes
        originalWeeklySummaries = weeklySummaries
        originalBetResults = betResults
        originalCommunityUpdates = communityUpdates
        originalPromotionalEmails = promotionalEmails
        
        print("🔧 Loaded email notification settings from Firestore")
    }
}

// MARK: - Sound Settings View
struct SoundSettingsView: View {
    @Environment(\.dismiss) private var dismiss
    @State private var soundEnabled = true
    @State private var vibrationEnabled = true
    @State private var soundVolume: Double = 0.7
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                            .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                    
                    Text("Sound & Vibration")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.gray)
                            .frame(width: 44, height: 44)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 20)
                .background(Color.white)
                
                // Content
        ScrollView {
                    VStack(spacing: 24) {
                        VStack(spacing: 16) {
                            HStack {
                                Text("Sound Settings")
                    .font(.headline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            VStack(spacing: 0) {
                                HStack {
                                    SettingsRow(icon: "speaker.wave.2", title: "Sound", subtitle: "Enable notification sounds", isDestructive: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $soundEnabled)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                }
                                Divider().padding(.leading, 56)
                                HStack {
                                    SettingsRow(icon: "iphone.radiowaves.left.and.right", title: "Vibration", subtitle: "Enable haptic feedback", isDestructive: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $vibrationEnabled)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                }
                                Divider().padding(.leading, 56)
                                VStack(alignment: .leading, spacing: 8) {
                                    HStack {
                                        Text("Volume")
                                            .font(.subheadline)
                                            .fontWeight(.medium)
                                            .foregroundColor(.black)
                                        Spacer()
                                        Text("\(Int(soundVolume * 100))%")
                                            .font(.caption)
                                            .foregroundColor(.gray)
                                    }
                                    Slider(value: $soundVolume, in: 0...1)
                                        .accentColor(.slingBlue)
                                }
                    .padding(.horizontal, 16)
                                .padding(.vertical, 12)
                            }
                            .background(Color.white)
                            .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
        }
    }
}

// MARK: - Simple Placeholder Views for Other Settings
struct ProfileVisibilityView: View {
    @Environment(\.dismiss) private var dismiss
    @ObservedObject var firestoreService: FirestoreService
    @State private var showTotalWinnings = true
    @State private var showTotalBets = true
    @State private var showSlingPoints = true
    @State private var showBlitzPoints = true
    @State private var showCommunities = true
    @State private var isLoading = false
    @State private var showingSaveSuccess = false
    @State private var showingUnsavedChangesAlert = false
    
    // Original values to track changes
    @State private var originalShowTotalWinnings = true
    @State private var originalShowTotalBets = true
    @State private var originalShowSlingPoints = true
    @State private var originalShowBlitzPoints = true
    @State private var originalShowCommunities = true
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                HStack {
                    Button(action: { 
                        if hasUnsavedChanges() {
                            showingUnsavedChangesAlert = true
                        } else {
                            dismiss()
                        }
                    }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.black)
                            .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                    
                    Text("Profile Visibility")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    Button(action: {
                        savePreferences()
                    }) {
                        Text("Save")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(.slingBlue)
                    }
                    .disabled(isLoading)
                }
                .padding(.horizontal, 20)
                .padding(.top, 20)
                
                ScrollView {
                    VStack(spacing: 24) {
                        VStack(spacing: 16) {
                            HStack {
                                Text("Profile Content Display")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            VStack(spacing: 0) {
                                HStack {
                                    SettingsRow(icon: "dollarsign.circle", title: "Total Winnings", subtitle: "Show your total winnings amount", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $showTotalWinnings)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                                Divider().padding(.leading, 56)
                                HStack {
                                    SettingsRow(icon: "target", title: "Total Bets", subtitle: "Show your total number of bets", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $showTotalBets)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                                Divider().padding(.leading, 56)
                                HStack {
                                    SettingsRow(icon: "bolt.fill", title: "Sling Points", subtitle: "Show your Sling Points balance", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $showSlingPoints)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                                Divider().padding(.leading, 56)
                                HStack {
                                    SettingsRow(icon: "flame.fill", title: "Blitz Points", subtitle: "Show your Blitz Points balance", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $showBlitzPoints)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                                Divider().padding(.leading, 56)
                                HStack {
                                    SettingsRow(icon: "person.2", title: "Communities", subtitle: "Show your community memberships", isDestructive: false, showArrow: false, action: {})
                                    Spacer()
                                    Toggle("", isOn: $showCommunities)
                                        .labelsHidden()
                                        .tint(.slingBlue)
                                        .padding(.trailing, 16)
                                }
                            }
                            .background(Color.white)
                            .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
            .alert("Preferences Saved", isPresented: $showingSaveSuccess) {
                Button("OK") { }
            } message: {
                Text("Your profile visibility preferences have been updated.")
            }
            .alert("Unsaved Changes", isPresented: $showingUnsavedChangesAlert) {
                Button("Leave", role: .destructive) { dismiss() }
                Button("Stay", role: .cancel) { }
            } message: {
                Text("You have unsaved changes. Are you sure you want to leave?")
            }
            .onAppear {
                loadCurrentUserSettings()
            }
        }
    }
    
    private func hasUnsavedChanges() -> Bool {
        return showTotalWinnings != originalShowTotalWinnings ||
               showTotalBets != originalShowTotalBets ||
               showSlingPoints != originalShowSlingPoints ||
               showBlitzPoints != originalShowBlitzPoints ||
               showCommunities != originalShowCommunities
    }
    
    private func savePreferences() {
        isLoading = true
        
        print("🔧 Saving profile visibility preferences")
        
        // Create ProfileVisibilitySettings object
        let visibilitySettings = ProfileVisibilitySettings(
            showTotalWinnings: showTotalWinnings,
            showTotalBets: showTotalBets,
            showSlingPoints: showSlingPoints,
            showBlitzPoints: showBlitzPoints,
            showCommunities: showCommunities
        )
        
        // Save profile visibility preferences to Firestore
        firestoreService.updateProfileVisibilitySettings(settings: visibilitySettings) { success in
            DispatchQueue.main.async {
                self.isLoading = false
                if success {
                    print("✅ Profile visibility preferences saved to Firestore")
                    self.showingSaveSuccess = true
                    
                    // Update original values after successful save
                    self.originalShowTotalWinnings = self.showTotalWinnings
                    self.originalShowTotalBets = self.showTotalBets
                    self.originalShowSlingPoints = self.showSlingPoints
                    self.originalShowBlitzPoints = self.showBlitzPoints
                    self.originalShowCommunities = self.showCommunities
                    
                    // Dismiss after showing success
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                        self.dismiss()
                    }
                } else {
                    print("❌ Failed to save profile visibility preferences")
                    // You could show an error alert here
                }
            }
        }
    }
    
    private func loadCurrentUserSettings() {
        guard let user = firestoreService.currentUser,
              let profileSettings = user.profile_visibility_settings else { return }
        
        // Load current profile visibility settings
        showTotalWinnings = profileSettings.showTotalWinnings
        showTotalBets = profileSettings.showTotalBets
        showSlingPoints = profileSettings.showSlingPoints
        showBlitzPoints = profileSettings.showBlitzPoints
        showCommunities = profileSettings.showCommunities
        
        // Set original values to track changes
        originalShowTotalWinnings = showTotalWinnings
        originalShowTotalBets = showTotalBets
        originalShowSlingPoints = showSlingPoints
        originalShowBlitzPoints = showBlitzPoints
        originalShowCommunities = showCommunities
        
        print("🔧 Loaded profile visibility settings from Firestore")
    }
}

struct AccountPrivacyView: View {
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                            .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                    
                    Text("Account Privacy")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.gray)
                            .frame(width: 44, height: 44)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 20)
                .background(Color.white)
                
                ScrollView {
                    VStack(spacing: 24) {
                        VStack(spacing: 16) {
                            HStack {
                                Text("Privacy Settings")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            VStack(spacing: 0) {
                                SettingsRow(icon: "eye", title: "Show Online Status", subtitle: "Let others see when you're online", isDestructive: false, action: {})
                                Divider().padding(.leading, 56)
                                SettingsRow(icon: "location", title: "Location Sharing", subtitle: "Share your location with friends", isDestructive: false, action: {})
                                Divider().padding(.leading, 56)
                                SettingsRow(icon: "chart.bar", title: "Activity Statistics", subtitle: "Show your betting statistics", isDestructive: false, action: {})
                            }
                            .background(Color.white)
                            .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
        }
    }
}

struct ChangePasswordView: View {
    @Environment(\.dismiss) private var dismiss
    @State private var currentPassword = ""
    @State private var newPassword = ""
    @State private var confirmPassword = ""
    @State private var isChanging = false
    @State private var showCurrentPassword = false
    @State private var showNewPassword = false
    @State private var showConfirmPassword = false
    @State private var showingSaveSuccess = false
    @State private var errorMessage = ""
    @State private var showingUnsavedChangesAlert = false
    
    var body: some View {
        NavigationView {
            ZStack {
                // Clean white background
                Color.white.ignoresSafeArea()
                
                VStack(spacing: 0) {
                    // Header
                    HStack {
                        Button(action: { 
                            if hasUnsavedChanges() {
                                showingUnsavedChangesAlert = true
                            } else {
                                dismiss()
                            }
                        }) {
                            Image(systemName: "arrow.left")
                                .font(.title2)
                                .foregroundColor(.black)
                                .frame(width: 44, height: 44)
                        }
                        
                        Spacer()
                        
                        Text("Change Password")
                            .font(.title2)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                        
                        Spacer()
                        
                        Button(action: {
                            changePassword()
                        }) {
                            Text("Save")
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.slingBlue)
                        }
                        .disabled(isChanging)
                    }
                    .padding(.horizontal, 20)
                    .padding(.top, 20)
                    
                    // Content
                    VStack(spacing: 32) {
                        // Title
                        Text("Update Your Password")
                            .font(.largeTitle)
                            .fontWeight(.bold)
                            .foregroundColor(.black)
                            .multilineTextAlignment(.center)
                            .padding(.horizontal, 20)
                        
                        // Subtitle
                        Text("Choose a strong password to secure your account")
                            .font(.body)
                            .foregroundColor(.gray)
                            .multilineTextAlignment(.center)
                            .padding(.horizontal, 20)
                        
                        // Password input fields
                        VStack(alignment: .leading, spacing: 16) {
                            VStack(alignment: .leading, spacing: 8) {
                                Text("Current Password")
                                    .font(.headline)
                                    .foregroundColor(.black)
                                
                                if showCurrentPassword {
                                    TextField("Enter current password", text: $currentPassword)
                                        .textFieldStyle(ModernTextFieldStyle())
                                        .overlay(
                                            HStack {
                                                Spacer()
                                                
                                                Button(action: { showCurrentPassword.toggle() }) {
                                                    Image(systemName: "eye.slash")
                                                        .foregroundColor(.gray)
                                                        .frame(width: 24, height: 24)
                                                }
                                                .padding(.trailing, 20)
                                            }
                                        )
                                } else {
                                    SecureField("Enter current password", text: $currentPassword)
                                        .textFieldStyle(ModernTextFieldStyle())
                                        .overlay(
                                            HStack {
                                                Spacer()
                                                
                                                Button(action: { showCurrentPassword.toggle() }) {
                                                    Image(systemName: showCurrentPassword ? "eye.slash" : "eye")
                                                        .foregroundColor(.gray)
                                                        .frame(width: 24, height: 24)
                                                }
                                                .padding(.trailing, 20)
                                            }
                                        )
                                }
                            }
                            
                            VStack(alignment: .leading, spacing: 8) {
                                Text("New Password")
                                    .font(.headline)
                                    .foregroundColor(.black)
                                
                                if showNewPassword {
                                    TextField("Enter new password", text: $newPassword)
                                        .textFieldStyle(ModernTextFieldStyle())
                                        .overlay(
                                            HStack {
                                                Spacer()
                                                
                                                Button(action: { showNewPassword.toggle() }) {
                                                    Image(systemName: "eye.slash")
                                                        .foregroundColor(.gray)
                                                        .frame(width: 24, height: 24)
                                                }
                                                .padding(.trailing, 20)
                                            }
                                        )
                                } else {
                                    SecureField("Enter new password", text: $newPassword)
                                        .textFieldStyle(ModernTextFieldStyle())
                                        .overlay(
                                            HStack {
                                                Spacer()
                                                
                                                Button(action: { showNewPassword.toggle() }) {
                                                    Image(systemName: showNewPassword ? "eye.slash" : "eye")
                                                        .foregroundColor(.gray)
                                                        .frame(width: 24, height: 24)
                                                }
                                                .padding(.trailing, 20)
                                            }
                                        )
                                }
                            }
                            
                            VStack(alignment: .leading, spacing: 8) {
                                Text("Confirm New Password")
                                    .font(.headline)
                                    .foregroundColor(.black)
                                
                                if showConfirmPassword {
                                    TextField("Confirm new password", text: $confirmPassword)
                                        .textFieldStyle(ModernTextFieldStyle())
                                        .overlay(
                                            HStack {
                                                Spacer()
                                                
                                                Button(action: { showConfirmPassword.toggle() }) {
                                                    Image(systemName: "eye.slash")
                                                        .foregroundColor(.gray)
                                                        .frame(width: 24, height: 24)
                                                }
                                                .padding(.trailing, 20)
                                            }
                                        )
                                } else {
                                    SecureField("Confirm new password", text: $confirmPassword)
                                        .textFieldStyle(ModernTextFieldStyle())
                                        .overlay(
                                            HStack {
                                                Spacer()
                                                
                                                Button(action: { showConfirmPassword.toggle() }) {
                                                    Image(systemName: showConfirmPassword ? "eye.slash" : "eye")
                                                        .foregroundColor(.gray)
                                                        .frame(width: 24, height: 24)
                                                }
                                                .padding(.trailing, 20)
                                            }
                                        )
                                }
                            }
                            
                            Text("Must be at least 6 characters")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        .padding(.horizontal, 24)
                        
                        Spacer()
                    }
                    .padding(.top, 40)
                }
            }
            .navigationBarHidden(true)
            .alert("Password Changed", isPresented: $showingSaveSuccess) {
                Button("OK") { dismiss() }
            } message: {
                Text("Your password has been successfully updated.")
            }
            .alert("Error", isPresented: .constant(!errorMessage.isEmpty)) {
                Button("OK") { errorMessage = "" }
            } message: {
                Text(errorMessage)
            }
            .alert("Unsaved Changes", isPresented: $showingUnsavedChangesAlert) {
                Button("Leave", role: .destructive) { dismiss() }
                Button("Stay", role: .cancel) { }
            } message: {
                Text("You have unsaved changes. Are you sure you want to leave?")
            }
        }
    }
    
    private func hasUnsavedChanges() -> Bool {
        return !currentPassword.isEmpty || !newPassword.isEmpty || !confirmPassword.isEmpty
    }
    
    private func changePassword() {
        // Validate input
        guard !currentPassword.isEmpty && !newPassword.isEmpty && !confirmPassword.isEmpty else {
            errorMessage = "Please fill in all fields"
            return
        }
        
        guard newPassword == confirmPassword else {
            errorMessage = "New passwords do not match"
            return
        }
        
        guard newPassword.count >= 6 else {
            errorMessage = "Password must be at least 6 characters"
            return
        }
        
        isChanging = true
        
        // Simulate password change (you'll need to implement this in FirestoreService)
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
            self.isChanging = false
            self.showingSaveSuccess = true
        }
    }
}

// MARK: - Remaining Placeholder Views


struct ExportDataView: View {
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                            .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                    
                    Text("Export Data")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.gray)
                            .frame(width: 44, height: 44)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 20)
                .background(Color.white)
                
                ScrollView {
                    VStack(spacing: 24) {
                        VStack(spacing: 16) {
                            HStack {
                                Text("Data Export Options")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            VStack(spacing: 0) {
                                SettingsRow(icon: "doc.text", title: "Betting History", subtitle: "Export all your betting data", isDestructive: false, action: {})
                                Divider().padding(.leading, 56)
                                SettingsRow(icon: "person.3", title: "Community Data", subtitle: "Export community participation", isDestructive: false, action: {})
                                Divider().padding(.leading, 56)
                                SettingsRow(icon: "chart.bar", title: "Statistics", subtitle: "Export performance analytics", isDestructive: false, action: {})
                            }
        .background(Color.white)
        .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
        }
    }
}

struct LanguageSettingsView: View {
    @Environment(\.dismiss) private var dismiss
    @ObservedObject var firestoreService: FirestoreService
    @State private var selectedLanguage = "English"
    
    let languages = ["English", "Spanish", "French", "German", "Chinese", "Japanese"]
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
        HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                            .frame(width: 44, height: 44)
                    }
                    
                    Button(action: {
                        saveLanguage()
                    }) {
                        Text("Save")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(.slingBlue)
                    }
                    
                    Spacer()
                    
                    Text("Language")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.gray)
                            .frame(width: 44, height: 44)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 20)
                .background(Color.white)
                
                ScrollView {
                    VStack(spacing: 24) {
                        VStack(spacing: 16) {
                            HStack {
                                Text("Select Language")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            VStack(spacing: 0) {
                                ForEach(languages, id: \.self) { language in
                                    HStack {
                                        SettingsRow(icon: "globe", title: language, subtitle: "", isDestructive: false, showArrow: false, action: {})
                                        Spacer()
                                        if selectedLanguage == language {
                                            Image(systemName: "checkmark")
                                                .foregroundColor(.slingBlue)
                                                .font(.caption)
                                                .scaleEffect(0.8)
                                        }
                                    }
                                    if language != languages.last {
                                        Divider().padding(.leading, 56)
                                    }
                                }
                            }
                            .background(Color.white)
                            .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
            .onAppear {
                loadCurrentUserSettings()
            }
        }
    }
    
    private func saveLanguage() {
        print("🔧 Saving language preference")
        
        // Save language preference to Firestore
        firestoreService.updateLanguageSetting(language: selectedLanguage) { success in
            DispatchQueue.main.async {
                if success {
                    print("✅ Language preference saved to Firestore")
                    self.dismiss()
                } else {
                    print("❌ Failed to save language preference")
                    // You could show an error alert here
                }
            }
        }
    }
    
    private func loadCurrentUserSettings() {
        guard let user = firestoreService.currentUser else { return }
        
        // Load current language setting
        if let language = user.language {
            selectedLanguage = language
            print("🔧 Loaded language setting from Firestore: \(language)")
        }
    }
}

// MARK: - Contact Us View
struct ContactSupportView: View {
    @Environment(\.dismiss) private var dismiss
    @ObservedObject var firestoreService: FirestoreService
    @State private var messageText = ""
    @State private var subject = ""
    @State private var isSubmitting = false
    @State private var showSuccessAlert = false
    @State private var showErrorAlert = false
    @State private var errorMessage = ""
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                            .frame(width: 44, height: 44)
                    }
                    
                    Button(action: {
                        submitContactRequest()
                    }) {
                        Text("Submit")
                            .font(.subheadline)
                            .fontWeight(.medium)
                            .foregroundColor(.slingBlue)
                    }
                    .disabled(isSubmitting)
                    
                    Spacer()
                    
                    Text("Contact Us")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.gray)
                            .frame(width: 44, height: 44)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 20)
                .background(Color.white)
                
                ScrollView {
                    VStack(spacing: 24) {
                        VStack(spacing: 16) {
                            HStack {
                                Text("Send us a message")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            VStack(spacing: 16) {
                                VStack(alignment: .leading, spacing: 8) {
                                    Text("Subject")
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                        .foregroundColor(.black)
                                    
                                    TextField("Enter subject", text: $subject)
                                        .textFieldStyle(RoundedBorderTextFieldStyle())
                                        .padding(.horizontal, 16)
                                        .padding(.vertical, 12)
                                        .background(Color.white)
                                        .cornerRadius(8)
                                }
                                
                                VStack(alignment: .leading, spacing: 8) {
                                    Text("Message")
                                        .font(.subheadline)
                                        .fontWeight(.medium)
                                        .foregroundColor(.black)
                                    
                                    TextEditor(text: $messageText)
                                        .frame(minHeight: 120)
                                        .padding(.horizontal, 16)
                                        .padding(.vertical, 12)
                                        .background(Color.white)
                                        .cornerRadius(8)
                                        .overlay(
                                            RoundedRectangle(cornerRadius: 8)
                                                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                        )
                                }
                                
                                Button(action: submitContactRequest) {
                                    HStack {
                                        if isSubmitting {
                                            ProgressView()
                                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                                .scaleEffect(0.8)
                                        } else {
                                            Text("Submit Request")
                                                .font(.headline)
                                                .fontWeight(.semibold)
                                        }
                                    }
                                    .foregroundColor(.white)
                                    .frame(maxWidth: .infinity)
                                    .padding(.vertical, 16)
                                    .background(Color.slingBlue)
                                    .cornerRadius(12)
                                }
                                .disabled(messageText.isEmpty || subject.isEmpty || isSubmitting)
                                .opacity(messageText.isEmpty || subject.isEmpty ? 0.6 : 1.0)
                            }
                            .padding(.horizontal, 16)
                            .padding(.vertical, 20)
                            .background(Color.white)
                            .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
            .alert("Success", isPresented: $showSuccessAlert) {
                Button("OK") {
                    dismiss()
                }
            } message: {
                Text("Your message has been sent successfully. We'll get back to you soon!")
            }
            .alert("Error", isPresented: $showErrorAlert) {
                Button("OK") { }
            } message: {
                Text(errorMessage)
            }
        }
    }
    
    private func submitContactRequest() {
        guard !messageText.isEmpty && !subject.isEmpty else { return }
        
        isSubmitting = true
        
        // Create contact request data
        let _: [String: Any] = [
            "subject": subject,
            "message": messageText,
            "timestamp": Date(),
            "status": "pending",
            "deviceInfo": getDeviceInfo(),
            "consoleLogs": getConsoleLogs()
        ]
        
        // Here you would save to Firestore "Contact" collection
        // For now, we'll simulate the submission
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
            isSubmitting = false
            showSuccessAlert = true
        }
    }
    
    private func getDeviceInfo() -> String {
        let device = UIDevice.current
        return "\(device.model) - \(device.systemName) \(device.systemVersion)"
    }
    
    private func getConsoleLogs() -> String {
        // In a real app, you might want to capture console logs
        // For now, return a placeholder
        return "Console logs captured at \(Date())"
    }
}

struct RateAppView: View {
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                            .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                    
                    Text("Rate App")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.gray)
                            .frame(width: 44, height: 44)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 20)
                .background(Color.white)
                
                ScrollView {
                    VStack(spacing: 24) {
                        VStack(spacing: 16) {
                            HStack {
                                Text("Rate SlingApp")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            VStack(spacing: 16) {
                                HStack {
                                    Spacer()
                                    VStack(spacing: 8) {
                                        Image(systemName: "star.fill")
                                            .font(.largeTitle)
                                            .foregroundColor(.yellow)
                                        Text("Rate us on the App Store")
                                            .font(.headline)
                                            .fontWeight(.semibold)
                                            .foregroundColor(.black)
                                        Text("Your feedback helps us improve")
                .font(.subheadline)
                                            .foregroundColor(.gray)
                                    }
                                    Spacer()
                                }
                                
                                Button(action: {
                                    // TODO: Open App Store rating
                                    print("Open App Store rating")
                                }) {
                                    Text("Rate Now")
                                        .font(.headline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(.white)
                                        .frame(maxWidth: .infinity)
                                        .frame(height: 50)
                                        .background(Color.slingBlue)
                                        .cornerRadius(12)
                                }
                            }
                            .padding(20)
                            .background(Color.white)
                            .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
        }
    }
    

}

struct TermsOfServiceView: View {
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                            .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                    
                    Text("Terms of Service")
                        .font(.title2)
                        .fontWeight(.bold)
                .foregroundColor(.black)
            
            Spacer()
            
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.gray)
                            .frame(width: 44, height: 44)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 20)
                .background(Color.white)
                
                ScrollView {
                    VStack(spacing: 24) {
                        VStack(spacing: 16) {
                            HStack {
                                Text("Terms & Conditions")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            Text("By using SlingApp, you agree to our terms of service...")
                                .font(.body)
                                .foregroundColor(.black)
                                .padding(20)
                                .frame(maxWidth: .infinity, alignment: .leading)
                                .background(Color.white)
                                .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
        }
    }
}

struct PrivacyPolicyView: View {
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                            .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                    
                    Text("Privacy Policy")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.gray)
                            .frame(width: 44, height: 44)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 20)
                .background(Color.white)
                
                ScrollView {
                    VStack(spacing: 24) {
                        VStack(spacing: 16) {
                            HStack {
                                Text("Privacy Information")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            Text("SlingApp is committed to protecting your privacy...")
                                .font(.body)
                                .foregroundColor(.black)
                                .padding(20)
                                .frame(maxWidth: .infinity, alignment: .leading)
                                .background(Color.white)
                                .cornerRadius(12)
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
        }
    }
}

struct AboutAppView: View {
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                            .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                    
                    Text("About SlingApp")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.gray)
                            .frame(width: 44, height: 44)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 20)
                .background(Color.white)
                
                ScrollView {
                    VStack(spacing: 24) {
                        VStack(spacing: 16) {
                            HStack {
                                Text("App Information")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            VStack(spacing: 16) {
                                HStack {
                                    Spacer()
                                    VStack(spacing: 8) {
                                        Image(systemName: "bolt.fill")
                                            .font(.largeTitle)
                                            .foregroundColor(.slingBlue)
                                        Text("SlingApp")
                                            .font(.title)
                                            .fontWeight(.bold)
                                            .foregroundColor(.black)
                                        Text("Version 1.0.0")
                .font(.subheadline)
                                            .foregroundColor(.gray)
                                    }
                                    Spacer()
                                }
                                
                                VStack(spacing: 12) {
                                    SettingsRow(icon: "doc.text", title: "Build Number", subtitle: "2024.1.0", isDestructive: false, action: {})
                                    Divider().padding(.leading, 56)
                                    SettingsRow(icon: "calendar", title: "Release Date", subtitle: "January 2024", isDestructive: false, action: {})
                                    Divider().padding(.leading, 56)
                                    SettingsRow(icon: "person.2", title: "Developer", subtitle: "SlingApp Team", isDestructive: false, action: {})
                                }
                                .background(Color.white)
                                .cornerRadius(12)
                            }
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
        }
    }
}

struct DeleteAccountView: View {
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                            .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                    
                    Text("Delete Account")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.red)
                    
                    Spacer()
                    
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.gray)
                            .frame(width: 44, height: 44)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 20)
                .background(Color.white)
                
                ScrollView {
                    VStack(spacing: 24) {
                        VStack(spacing: 16) {
                            HStack {
                                Text("⚠️ Warning")
                                    .font(.headline)
                .fontWeight(.semibold)
                                    .foregroundColor(.red)
                                Spacer()
                            }
                            
                            Text("This action cannot be undone. All your data, bets, and community memberships will be permanently deleted.")
                                .font(.body)
                .foregroundColor(.black)
                                .padding(20)
                                .frame(maxWidth: .infinity, alignment: .leading)
                                .background(Color.white)
                                .cornerRadius(12)
                            
                            Button(action: {
                                // TODO: Implement account deletion
                                print("Delete account")
                            }) {
                                Text("Delete Account")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.white)
                                    .frame(maxWidth: .infinity)
                                    .frame(height: 50)
                                    .background(Color.red)
                                    .cornerRadius(12)
                            }
                        }
        }
        .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
        }
    }
}

struct SignOutView: View {
    @Environment(\.dismiss) private var dismiss
    @ObservedObject var firestoreService: FirestoreService
    @State private var isSigningOut = false
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                HStack {
                    Button(action: { dismiss() }) {
                        Image(systemName: "arrow.left")
                            .font(.title2)
                            .foregroundColor(.slingBlue)
                            .frame(width: 44, height: 44)
                    }
                    
                    Spacer()
                    
                    Text("Sign Out")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Spacer()
                    
                    Button(action: { dismiss() }) {
                        Image(systemName: "xmark")
                            .font(.title2)
                            .foregroundColor(.gray)
                            .frame(width: 44, height: 44)
                    }
                }
                .padding(.horizontal, 16)
                .padding(.top, 12)
                .padding(.bottom, 20)
                .background(Color.white)
                
                ScrollView {
                    VStack(spacing: 24) {
                        VStack(spacing: 16) {
                            HStack {
                                Text("Sign Out Confirmation")
                                    .font(.headline)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.black)
                                Spacer()
                            }
                            
                            Text("Are you sure you want to sign out? You'll need to sign in again to access your account.")
                                .font(.body)
                                .foregroundColor(.black)
                                .padding(20)
                                .frame(maxWidth: .infinity, alignment: .leading)
        .background(Color.white)
        .cornerRadius(12)
                            
                            Button(action: {
                                // Implement actual sign out
                                isSigningOut = true
                                firestoreService.signOut()
                                
                                // Add a small delay to ensure auth state change propagates
                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                                    // The auth state change should have already triggered navigation
                                    // If for some reason it hasn't, we can manually dismiss
                                    if firestoreService.isAuthenticated {
                                        dismiss()
                                    }
                                }
                            }) {
                                HStack {
                                    if isSigningOut {
                                        ProgressView()
                                            .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                            .scaleEffect(0.8)
                                    }
                                    Text(isSigningOut ? "Signing Out..." : "Sign Out")
                                        .font(.headline)
                                        .fontWeight(.semibold)
                                        .foregroundColor(.white)
                                }
                                .frame(maxWidth: .infinity)
                                .frame(height: 50)
                                .background(isSigningOut ? Color.gray : Color.slingBlue)
                                .cornerRadius(12)
                            }
                            .disabled(isSigningOut)
                        }
                    }
                    .padding(.horizontal, 16)
                    .padding(.vertical, 20)
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
        }
    }
}

struct MemberManagementView: View {
    let community: FirestoreCommunity
    let firestoreService: FirestoreService
    let isAdmin: Bool
    @Environment(\.dismiss) private var dismiss
    @State private var members: [CommunityMemberInfo] = []
    @State private var isLoading = false
    @State private var showingKickAlert = false
    @State private var selectedMember: CommunityMemberInfo?
    @State private var showingPromoteAlert = false
    @State private var showingDemoteAlert = false
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                HStack {
                    Button("Cancel") {
                        dismiss()
                    }
                    .foregroundColor(.slingBlue)
                    
                    Spacer()
                    
                    Text("Member Management")
                        .font(.headline)
                        .fontWeight(.semibold)
                    
                    Spacer()
                    
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(.slingBlue)
                }
                .padding()
                .background(Color.white)
                .overlay(
                    Rectangle()
                        .frame(height: 0.5)
                        .foregroundColor(Color.gray.opacity(0.3)),
                    alignment: .bottom
                )
                
                if isLoading {
                    Spacer()
                    ProgressView()
                        .scaleEffect(1.5)
                    Spacer()
                } else {
                    List {
                        ForEach(members, id: \.id) { member in
                            MemberManagementRowView(
                                member: member,
                                isAdmin: isAdmin,
                                onKick: { showKickAlert(for: member) },
                                onPromote: { showPromoteAlert(for: member) },
                                onDemote: { showDemoteAlert(for: member) }
                            )
                        }
                    }
                    .listStyle(PlainListStyle())
                }
            }
            .navigationBarHidden(true)
        }
        .onAppear {
            loadMembers()
        }
        .alert("Kick Member", isPresented: $showingKickAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Kick", role: .destructive) {
                if let member = selectedMember {
                    kickMember(member)
                }
            }
        } message: {
            if let member = selectedMember {
                Text("Are you sure you want to kick \(member.name) from the community?")
            }
        }
        .alert("Promote to Admin", isPresented: $showingPromoteAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Promote") {
                if let member = selectedMember {
                    promoteMember(member)
                }
            }
        } message: {
            if let member = selectedMember {
                Text("Are you sure you want to promote \(member.name) to admin?")
            }
        }
        .alert("Demote from Admin", isPresented: $showingDemoteAlert) {
            Button("Cancel", role: .cancel) { }
            Button("Demote") {
                if let member = selectedMember {
                    demoteMember(member)
                }
            }
        } message: {
            if let member = selectedMember {
                Text("Are you sure you want to demote \(member.name) from admin?")
            }
        }
    }
    
    private func loadMembers() {
        isLoading = true
        firestoreService.fetchCommunityMembers(communityId: community.id ?? "") { fetchedMembers in
            DispatchQueue.main.async {
                self.members = fetchedMembers
                self.isLoading = false
            }
        }
    }
    
    private func showKickAlert(for member: CommunityMemberInfo) {
        selectedMember = member
        showingKickAlert = true
    }
    
    private func showPromoteAlert(for member: CommunityMemberInfo) {
        selectedMember = member
        showingPromoteAlert = true
    }
    
    private func showDemoteAlert(for member: CommunityMemberInfo) {
        selectedMember = member
        showingDemoteAlert = true
    }
    
    private func kickMember(_ member: CommunityMemberInfo) {
        firestoreService.kickMemberFromCommunity(communityId: community.id ?? "", memberEmail: member.email) { success in
            if success {
                DispatchQueue.main.async {
                    // Remove member from local array
                    self.members.removeAll { $0.id == member.id }
                }
            }
        }
    }
    
    private func promoteMember(_ member: CommunityMemberInfo) {
        firestoreService.promoteMemberToAdmin(communityId: community.id ?? "", memberEmail: member.email) { success in
            if success {
                DispatchQueue.main.async {
                    // Update member in local array
                    if let index = self.members.firstIndex(where: { $0.id == member.id }) {
                        self.members[index] = CommunityMemberInfo(
                            id: member.id,
                            email: member.email,
                            name: member.name,
                            isActive: member.isActive,
                            joinDate: member.joinDate,
                            isAdmin: true
                        )
                    }
                }
            }
        }
    }
    
    private func demoteMember(_ member: CommunityMemberInfo) {
        firestoreService.demoteAdminToMember(communityId: community.id ?? "", memberEmail: member.email) { success in
            if success {
                DispatchQueue.main.async {
                    // Update member in local array
                    if let index = self.members.firstIndex(where: { $0.id == member.id }) {
                        self.members[index] = CommunityMemberInfo(
                            id: member.id,
                            email: member.email,
                            name: member.name,
                            isActive: member.isActive,
                            joinDate: member.joinDate,
                            isAdmin: false
                        )
                    }
                }
            }
        }
    }
}

struct CommunitySettingsDetailView: View {
    let community: FirestoreCommunity
    let firestoreService: FirestoreService
    let isAdmin: Bool
    @Environment(\.dismiss) private var dismiss
    @State private var communityName: String
    @State private var communityDescription: String
    @State private var isPrivate: Bool
    @State private var isEditing = false
    @State private var isSaving = false
    @State private var errorMessage = ""
    
    init(community: FirestoreCommunity, firestoreService: FirestoreService, isAdmin: Bool) {
        self.community = community
        self.firestoreService = firestoreService
        self.isAdmin = isAdmin
        self._communityName = State(initialValue: community.name)
        self._communityDescription = State(initialValue: community.description ?? "")
        self._isPrivate = State(initialValue: community.is_private ?? false)
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 0) {
                // Header
                HStack {
                    Button("Cancel") {
                        dismiss()
                    }
                    .foregroundColor(.slingBlue)
                    
                    Spacer()
                    
                    Text("Community Settings")
                        .font(.headline)
                        .fontWeight(.semibold)
                    
                    Spacer()
                    
                    if isAdmin {
                        Button(isEditing ? "Save" : "Edit") {
                            if isEditing {
                                saveChanges()
                            } else {
                                isEditing = true
                            }
                        }
                        .foregroundColor(.slingBlue)
                        .disabled(isSaving)
                    } else {
                        Button("Done") {
                            dismiss()
                        }
                        .foregroundColor(.slingBlue)
                    }
                }
                .padding()
                .background(Color.white)
                .overlay(
                    Rectangle()
                        .frame(height: 0.5)
                        .foregroundColor(Color.gray.opacity(0.3)),
                    alignment: .bottom
                )
                
                ScrollView {
                    VStack(spacing: 20) {
                        // Community Name
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Community Name")
                                .font(.headline)
                                .fontWeight(.semibold)
                            
                            if isEditing && isAdmin {
                                TextField("Community Name", text: $communityName)
                                    .textFieldStyle(RoundedBorderTextFieldStyle())
                            } else {
                                Text(communityName)
                                    .font(.subheadline)
                                    .foregroundColor(.gray)
                                    .padding()
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .background(Color(.systemGray6))
                                    .cornerRadius(8)
                            }
                        }
                        
                        // Community Description
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Description")
                                .font(.headline)
                                .fontWeight(.semibold)
                            
                            if isEditing && isAdmin {
                                TextField("Description", text: $communityDescription, axis: .vertical)
                                    .textFieldStyle(RoundedBorderTextFieldStyle())
                                    .lineLimit(3...6)
                            } else {
                                Text(communityDescription.isEmpty ? "No description" : communityDescription)
                                    .font(.subheadline)
                                    .foregroundColor(.gray)
                                    .padding()
                                    .frame(maxWidth: .infinity, alignment: .leading)
                                    .background(Color(.systemGray6))
                                    .cornerRadius(8)
                            }
                        }
                        
                        // Privacy Setting
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Privacy")
                                .font(.headline)
                                .fontWeight(.semibold)
                            
                            if isEditing && isAdmin {
                                Toggle("Private Community", isOn: $isPrivate)
                                    .padding()
                                    .background(Color(.systemGray6))
                                    .cornerRadius(8)
                            } else {
                                HStack {
                                    Text(isPrivate ? "Private" : "Public")
                                        .font(.subheadline)
                                        .foregroundColor(.gray)
                                    
                                    Spacer()
                                    
                                    Image(systemName: isPrivate ? "lock.fill" : "globe")
                                        .foregroundColor(isPrivate ? .orange : .green)
                                }
                                .padding()
                                .background(Color(.systemGray6))
                                .cornerRadius(8)
                            }
                        }
                        
                        // Invite Code (Read-only)
                        VStack(alignment: .leading, spacing: 8) {
                            Text("Invite Code")
                                .font(.headline)
                                .fontWeight(.semibold)
                            
                            HStack {
                                Text(community.invite_code)
                                    .font(.title2)
                                    .fontWeight(.bold)
                                    .foregroundColor(.black)
                                
                                Spacer()
                                
                                Button(action: {
                                    UIPasteboard.general.string = community.invite_code
                                }) {
                                    Image(systemName: "doc.on.clipboard")
                                        .font(.title3)
                                        .foregroundColor(.slingBlue)
                                }
                            }
                            .padding()
                            .background(Color(.systemGray6))
                            .cornerRadius(8)
                        }
                        
                        if !errorMessage.isEmpty {
                            Text(errorMessage)
                                .font(.caption)
                                .foregroundColor(.red)
                                .padding()
                                .background(Color.red.opacity(0.1))
                                .cornerRadius(8)
                        }
                    }
                    .padding(20)
                }
            }
            .navigationBarHidden(true)
        }
    }
    
    private func saveChanges() {
        isSaving = true
        errorMessage = ""
        
        let group = DispatchGroup()
        var hasError = false
        
        // Update community name if changed
        if communityName != community.name {
            group.enter()
            firestoreService.updateCommunityName(communityId: community.id ?? "", newName: communityName) { success in
                if !success {
                    hasError = true
                    errorMessage = "Failed to update community name"
                }
                group.leave()
            }
        }
        
        // Update community description if changed
        if communityDescription != (community.description ?? "") {
            group.enter()
            firestoreService.updateCommunityDescription(communityId: community.id ?? "", newDescription: communityDescription) { success in
                if !success {
                    hasError = true
                    errorMessage = "Failed to update community description"
                }
                group.leave()
            }
        }
        
        // Update privacy setting if changed
        if isPrivate != (community.is_private ?? false) {
            group.enter()
            firestoreService.toggleCommunityPrivacy(communityId: community.id ?? "", isPrivate: isPrivate) { success in
                if !success {
                    hasError = true
                    errorMessage = "Failed to update privacy setting"
                }
                group.leave()
            }
        }
        
        group.notify(queue: .main) {
            isSaving = false
            if !hasError {
                isEditing = false
            }
        }
    }
}
            /*
            VStack(spacing: 0) {
                // Header
                HStack {
                    Button("Cancel") {
                        dismiss()
                    }
                    .foregroundColor(.slingBlue)
                    
                    Spacer()
                    
                    Text("Admin Controls")
                        .font(.headline)
                        .fontWeight(.semibold)
                    
                    Spacer()
                    
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(.slingBlue)
                }
                .padding()
                .background(Color.white)
                .overlay(
                    Rectangle()
                        .frame(height: 0.5)
                        .foregroundColor(Color.gray.opacity(0.3)),
                    alignment: .bottom
                )
                
                ScrollView {
                    VStack(spacing: 20) {
                        // Admin Statistics
                        VStack(alignment: .leading, spacing: 12) {
                            Text("Admin Statistics")
                                .font(.headline)
                                .fontWeight(.semibold)
                            
                            VStack(spacing: 8) {
                                HStack {
                                    Text("Total Members")
                                    Spacer()
                                    Text("\(community.member_count)")
                                        .fontWeight(.medium)
                                }
                                
                                HStack {
                                    Text("Total Bets")
                                    Spacer()
                                    Text("\(community.total_bets)")
                                        .fontWeight(.medium)
                                }
                                
                                HStack {
                                    Text("Community Status")
                                    Spacer()
                                    HStack(spacing: 4) {
                                        Circle()
                                            .fill(community.is_active == true ? Color.green : Color.red)
                                            .frame(width: 8, height: 8)
                                        Text(community.is_active == true ? "Active" : "Inactive")
                                            .fontWeight(.medium)
                                    }
                                }
                            }
                            .font(.subheadline)
                            .padding()
                            .background(Color(.systemGray6))
                            .cornerRadius(12)
                        }
                        
                        // Quick Actions
                        VStack(alignment: .leading, spacing: 12) {
                            Text("Quick Actions")
                                .font(.headline)
                                .fontWeight(.semibold)
                            
                            VStack(spacing: 8) {
                                Button(action: {
                                    // Toggle community status
                                    _ = !(community.is_active ?? true)
                                    // TODO: Implement toggle community status
                                }) {
                                    HStack {
                                        Image(systemName: "power")
                                            .foregroundColor(.slingBlue)
                                        Text("Toggle Community Status")
                                        Spacer()
                                        Image(systemName: "chevron.right")
                                            .foregroundColor(.gray)
                                    }
                                    .padding()
                                    .background(Color.white)
                                    .cornerRadius(8)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 8)
                                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                    )
                                }
                                .buttonStyle(PlainButtonStyle())
                                
                                Button(action: {
                                    // Regenerate invite code
                                    // TODO: Implement regenerate invite code
                                }) {
                                    HStack {
                                        Image(systemName: "arrow.clockwise")
                                            .foregroundColor(.slingBlue)
                                        Text("Regenerate Invite Code")
                                        Spacer()
                                        Image(systemName: "chevron.right")
                                            .foregroundColor(.gray)
                                    }
                                    .padding()
                                    .background(Color.white)
                                    .cornerRadius(8)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 8)
                                            .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                    )
                                }
                                .buttonStyle(PlainButtonStyle())
                            }
                        }
                    }
                    .padding(20)
                }
            }
            .navigationBarHidden(true)
        }
        .onAppear {
            loadMembers()
        }
    }
    
    private func loadMembers() {
        isLoading = true
        firestoreService.fetchCommunityMembers(communityId: community.id ?? "") { fetchedMembers in
            DispatchQueue.main.async {
                self.members = fetchedMembers
                self.isLoading = false
            }
        }
    }
            */

struct MemberManagementRowView: View {
    let member: CommunityMemberInfo
    let isAdmin: Bool
    let onKick: () -> Void
    let onPromote: () -> Void
    let onDemote: () -> Void
    
    var body: some View {
        HStack(spacing: 12) {
            // Profile Picture
            Circle()
                .fill(Color.slingGradient)
                .frame(width: 40, height: 40)
                .overlay(
                    Text(String(member.name.prefix(1)).uppercased())
                        .font(.subheadline)
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                )
            
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(member.name)
                        .font(.subheadline)
                        .fontWeight(.medium)
                        .foregroundColor(.black)
                    
                    if member.isAdmin {
                        HStack(spacing: 4) {
                            Image(systemName: "crown.fill")
                                .font(.caption)
                                .foregroundColor(.slingPurple)
                            Text("Admin")
                                .font(.caption)
                                .fontWeight(.medium)
                                .foregroundColor(.slingPurple)
                        }
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.slingPurple.opacity(0.1))
                        .cornerRadius(6)
                    }
                }
                
                Text(member.email)
                    .font(.caption)
                    .foregroundColor(.gray)
            }
            
            Spacer()
            
            if isAdmin && !member.isAdmin {
                // Show promote button for regular members
                Button(action: onPromote) {
                    Image(systemName: "arrow.up.circle")
                        .font(.title3)
                        .foregroundColor(.slingBlue)
                }
            } else if isAdmin && member.isAdmin {
                // Show demote button for other admins
                Button(action: onDemote) {
                    Image(systemName: "arrow.down.circle")
                        .font(.title3)
                        .foregroundColor(.orange)
                }
            }
            
            if isAdmin && !member.isAdmin {
                // Show kick button for regular members
                Button(action: onKick) {
                    Image(systemName: "xmark.circle")
                        .font(.title3)
                        .foregroundColor(.red)
                }
            }
        }
        .padding(.vertical, 8)
    }
}

struct MemberRowView: View {
    let memberWithPoints: CommunityMemberWithPoints
    let rank: Int
    let onTap: () -> Void
    @State private var userFullName: String?
    @State private var isLoadingUserData = false
    @State private var userProfileImageUrl: String?
    @State private var userFirstName: String?
    @State private var userLastName: String?
    
    var body: some View {
        Button(action: onTap) {
            HStack(spacing: 12) {
                // Ranking number
                Text("\(rank)")
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .foregroundColor(.gray)
                    .frame(width: 16, alignment: .center)
                
                // Profile Picture
                if let profileImageUrl = userProfileImageUrl, !profileImageUrl.isEmpty {
                    AsyncImage(url: URL(string: profileImageUrl)) { image in
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                    } placeholder: {
                        Circle()
                            .fill(AnyShapeStyle(Color.slingGradient))
                            .overlay(
                                Text(getUserInitials())
                                    .font(.caption)
                                    .fontWeight(.semibold)
                                    .foregroundColor(.white)
                            )
                    }
                    .frame(width: 40, height: 40)
                    .clipShape(Circle())
                } else {
                Circle()
                    .fill(AnyShapeStyle(Color.slingGradient))
                    .frame(width: 40, height: 40)
        .overlay(
                            Text(getUserInitials())
                            .font(.caption)
                            .fontWeight(.semibold)
                            .foregroundColor(.white)
                    )
                }
                
                VStack(alignment: .leading, spacing: 2) {
                    HStack(spacing: 6) {
                        if isLoadingUserData {
                            Text("Loading...")
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.gray)
                        } else {
                            Text(userFullName ?? memberWithPoints.name)
                                .font(.subheadline)
                                .fontWeight(.medium)
                                .foregroundColor(.black)
                        }
                        
                        // Admin badge
                        if memberWithPoints.isAdmin {
                            HStack(spacing: 2) {
                                Image(systemName: "crown.fill")
                                    .font(.caption2)
                                    .foregroundColor(.purple)
                                Text("Admin")
                                    .font(.caption2)
                                    .fontWeight(.medium)
                                    .foregroundColor(.purple)
                            }
                            .padding(.horizontal, 6)
                            .padding(.vertical, 2)
                            .background(Color.purple.opacity(0.1))
                            .cornerRadius(6)
                        }
                    }
                }
                
                Spacer()
                
                // Net points on the right
                HStack(spacing: 4) {
                    Image(systemName: "bolt.fill")
                        .font(.caption)
                        .foregroundColor(memberWithPoints.netPoints >= 0 ? .green : .red)
                    
                    Text("\(String(format: "%.0f", memberWithPoints.netPoints))")
                        .font(.subheadline)
                        .fontWeight(.bold)
                        .foregroundColor(memberWithPoints.netPoints >= 0 ? .green : .red)
                }
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(
                    (memberWithPoints.netPoints >= 0 ? Color.green : Color.red).opacity(0.1)
                )
                .cornerRadius(8)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .background(Color.white)
            .cornerRadius(12)
        }
        .buttonStyle(PlainButtonStyle())
        .onAppear {
            loadUserFullName()
        }
    }
    
    private func loadUserFullName() {
        guard userFullName == nil && !isLoadingUserData else { return }
        
        isLoadingUserData = true
        
        Task {
            do {
                let user = try await FirestoreService().getUser(userId: memberWithPoints.email)
                await MainActor.run {
                    self.userFullName = user.full_name
                    self.userProfileImageUrl = user.profile_picture_url
                    self.userFirstName = user.first_name
                    self.userLastName = user.last_name
                    self.isLoadingUserData = false
                }
            } catch {
                print("❌ Error loading user full name for \(memberWithPoints.email): \(error)")
                await MainActor.run {
                    self.isLoadingUserData = false
                }
            }
        }
    }
    
    private func getUserInitials() -> String {
        // Prioritize first and last name if available
        if let firstName = userFirstName, let lastName = userLastName, !firstName.isEmpty, !lastName.isEmpty {
            let firstInitial = String(firstName.prefix(1)).uppercased()
            let lastInitial = String(lastName.prefix(1)).uppercased()
            return "\(firstInitial)\(lastInitial)"
        }
        
        // Fallback to parsing the full name
        if let fullName = userFullName, !fullName.isEmpty {
            let components = fullName.components(separatedBy: " ")
            if components.count >= 2 {
                let firstInitial = String(components[0].prefix(1)).uppercased()
                let lastInitial = String(components[1].prefix(1)).uppercased()
                return "\(firstInitial)\(lastInitial)"
            } else if components.count == 1 {
                return String(components[0].prefix(1)).uppercased()
            }
        }
        
        // Fallback to member name
        let components = memberWithPoints.name.components(separatedBy: " ")
        if components.count >= 2 {
            let firstInitial = String(components[0].prefix(1)).uppercased()
            let lastInitial = String(components[1].prefix(1)).uppercased()
            return "\(firstInitial)\(lastInitial)"
        } else {
            return String(memberWithPoints.name.prefix(1)).uppercased()
        }
    }
}

struct BetHistoryRow: View {
    let title: String
    let amount: String
    let status: String
    let date: String
    
    var body: some View {
        HStack(spacing: 12) {
            VStack(alignment: .leading, spacing: 4) {
                Text(title)
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .foregroundColor(.black)
                
                Text(date)
                    .font(.caption)
                    .foregroundColor(.gray)
            }
            
            Spacer()
            
            VStack(alignment: .trailing, spacing: 4) {
                Text(amount)
                    .font(.subheadline)
                    .fontWeight(.semibold)
                    .foregroundColor(.black)
                
                Text(status)
                    .font(.caption)
                    .fontWeight(.medium)
                    .foregroundColor(status == "Won" ? .green : .red)
            }
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .background(Color.white)
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(Color.gray.opacity(0.2), lineWidth: 1)
        )
    }
}

struct BetLoadingRow: View {
    var body: some View {
        HStack(spacing: 12) {
            RoundedRectangle(cornerRadius: 8)
                .fill(Color.gray.opacity(0.3))
                .frame(width: 40, height: 40)
            
            VStack(alignment: .leading, spacing: 4) {
                RoundedRectangle(cornerRadius: 4)
                    .fill(Color.gray.opacity(0.3))
                    .frame(width: 150, height: 16)
                
                RoundedRectangle(cornerRadius: 4)
                    .fill(Color.gray.opacity(0.3))
                    .frame(width: 100, height: 12)
            }
            
            Spacer()
            
            RoundedRectangle(cornerRadius: 8)
                .fill(Color.gray.opacity(0.3))
                .frame(width: 60, height: 24)
        }
        .padding(12)
        .background(Color.white)
        .cornerRadius(12)
    }
}

struct PerformanceCard: View {
    let icon: String
    let value: String
    let label: String
    let color: Color
    
    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: icon)
                .font(.title3)
                .foregroundColor(color)
            
            Text(value)
                .font(.headline)
                .fontWeight(.bold)
                .foregroundColor(color)
            
            Text(label)
                .font(.caption)
                .foregroundColor(.gray)
        }
        .frame(width: 120, height: 100)
        .padding(.vertical, 16)
        .background(Color.white)
        .cornerRadius(12)
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(Color.gray.opacity(0.2), lineWidth: 1)
        )
    }
}

struct RecentBetRow: View {
    let bet: FirestoreBet
    
    var body: some View {
        HStack(spacing: 12) {
            // Bet Image or Fallback Icon
            if let imageUrl = bet.image_url, !imageUrl.isEmpty {
                AsyncImage(url: URL(string: imageUrl)) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    RoundedRectangle(cornerRadius: 8)
                        .fill(Color.gray.opacity(0.2))
                        .overlay(
                            ProgressView()
                                .scaleEffect(0.8)
                        )
                }
                .frame(width: 40, height: 40)
                .clipShape(RoundedRectangle(cornerRadius: 8))
            } else {
                // Fallback icon based on bet type
                RoundedRectangle(cornerRadius: 8)
                    .fill(Color.gray.opacity(0.2))
                    .frame(width: 40, height: 40)
                    .overlay(
                        Image(systemName: getBetTypeIcon(bet.bet_type))
                            .font(.caption)
                            .foregroundColor(.gray)
                    )
            }
            
            VStack(alignment: .leading, spacing: 2) {
                Text(bet.title)
                    .font(.subheadline)
                    .fontWeight(.medium)
                    .foregroundColor(.black)
                    .lineLimit(1)
                
                Text("Deadline: \(formatDeadline(bet.deadline))")
                    .font(.caption)
                    .foregroundColor(.gray)
            }
            
            Spacer()
            
            Text(bet.status.uppercased())
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(.white)
                .padding(.horizontal, 8)
                .padding(.vertical, 4)
                .background(bet.status == "open" ? Color.green : Color.gray)
                .cornerRadius(8)
        }
        .padding(12)
        .background(Color.white)
        .cornerRadius(12)
    }
    
    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d"
        return formatter.string(from: date)
    }
    
    // Helper function to format deadline
    private func formatDeadline(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d, yyyy"
        return formatter.string(from: date)
    }
    
    private func getBetTypeIcon(_ betType: String) -> String {
        switch betType.lowercased() {
        case "sports":
            return "sportscourt.fill"
        case "politics":
            return "building.columns.fill"
        case "entertainment":
            return "tv.fill"
        case "weather":
            return "cloud.sun.fill"
        case "finance":
            return "chart.line.uptrend.xyaxis"
        case "technology":
            return "laptopcomputer"
        case "health":
            return "heart.fill"
        case "education":
            return "book.fill"
        default:
            return "questionmark.circle.fill"
        }
    }
}

// MARK: - Community Settings Views

struct NotificationSettingsView: View {
    let community: FirestoreCommunity
    let firestoreService: FirestoreService
    let isAdmin: Bool
    @Environment(\.dismiss) private var dismiss
    @State private var isNotificationsMuted = false
    @State private var isLoading = false
    
    var body: some View {
        NavigationView {
            VStack(spacing: 20) {
                // Header
                VStack(spacing: 8) {
                    Image(systemName: "bell")
                        .font(.system(size: 40))
                        .foregroundColor(.slingBlue)
                    
                    Text("Notification Settings")
                        .font(.title2)
                        .fontWeight(.bold)
                    
                    Text("Manage how you receive notifications for \(community.name)")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                        .multilineTextAlignment(.center)
                }
                .padding(.top, 20)
                
                // Settings
                VStack(spacing: 16) {
                    // Mute Notifications Toggle
                    HStack {
                        VStack(alignment: .leading, spacing: 4) {
                            Text("Mute Notifications")
                                .font(.headline)
                                .fontWeight(.medium)
                            Text("Stop receiving notifications from this community")
                                .font(.caption)
                                .foregroundColor(.gray)
                        }
                        
                        Spacer()
                        
                        Toggle("", isOn: $isNotificationsMuted)
                            .onChange(of: isNotificationsMuted) { _, newValue in
                                updateNotificationPreferences(muted: newValue)
                            }
                    }
                    .padding()
                    .background(Color(.systemGray6))
                    .cornerRadius(12)
                    
                    // Additional settings for admins
                    if isAdmin {
                        VStack(alignment: .leading, spacing: 12) {
                            Text("Admin Notifications")
                                .font(.headline)
                                .fontWeight(.medium)
                            
                            VStack(spacing: 8) {
                                HStack {
                                    Text("New member joins")
                                    Spacer()
                                    Image(systemName: "checkmark")
                                        .foregroundColor(.green)
                                }
                                
                                HStack {
                                    Text("New bet created")
                                    Spacer()
                                    Image(systemName: "checkmark")
                                        .foregroundColor(.green)
                                }
                                
                                HStack {
                                    Text("Bet settled")
                                    Spacer()
                                    Image(systemName: "checkmark")
                                        .foregroundColor(.green)
                                }
                            }
                            .font(.subheadline)
                            .padding()
                            .background(Color(.systemGray6))
                            .cornerRadius(12)
                        }
                    }
                }
                .padding(.horizontal, 20)
                
                Spacer()
                
                // Done Button
                Button("Done") {
                    dismiss()
                }
                .font(.headline)
                .foregroundColor(.white)
                .frame(maxWidth: .infinity)
                .padding()
                .background(Color.slingGradient)
                .cornerRadius(12)
                .padding(.horizontal, 20)
                .padding(.bottom, 20)
            }
            .navigationBarHidden(true)
        }
        .onAppear {
            loadNotificationPreferences()
        }
    }
    
    private func loadNotificationPreferences() {
        guard let userEmail = firestoreService.currentUser?.email else { return }
        
        isLoading = true
        firestoreService.getNotificationPreferences(communityId: community.id ?? "", userEmail: userEmail) { isMuted in
            DispatchQueue.main.async {
                self.isNotificationsMuted = isMuted
                self.isLoading = false
            }
        }
    }
    
    private func updateNotificationPreferences(muted: Bool) {
        guard let userEmail = firestoreService.currentUser?.email else { return }
        
        firestoreService.updateNotificationPreferences(communityId: community.id ?? "", userEmail: userEmail, isMuted: muted) { success in
            if success {
                print("✅ Notification preferences updated")
            } else {
                print("❌ Failed to update notification preferences")
                // Revert the toggle if update failed
                DispatchQueue.main.async {
                    self.isNotificationsMuted.toggle()
                }
            }
        }
    }
}

// MARK: - Community Image Picker Component

struct CommunityImagePicker: View {
    let community: FirestoreCommunity
    @ObservedObject var firestoreService: FirestoreService
    @Environment(\.dismiss) private var dismiss
    
    @State private var selectedItem: PhotosPickerItem? = nil
    @State private var selectedImage: UIImage? = nil
    @State private var isUploading = false
    @State private var showingCamera = false
    @State private var showingErrorAlert = false
    @State private var errorMessage = ""
    
    private var uploadButton: some View {
        Button(action: uploadImage) {
            HStack(spacing: 8) {
                if isUploading {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        .scaleEffect(1.2)
                } else {
                    Text("Update Profile Picture")
                        .font(.headline)
                        .fontWeight(.semibold)
                        .foregroundColor(.white)
                }
            }
        }
        .frame(maxWidth: .infinity)
        .frame(height: 56)
        .background(Color.slingGradient)
        .cornerRadius(16)
        .shadow(color: Color.slingBlue.opacity(0.3), radius: 8, x: 0, y: 4)
        .disabled(isUploading)
        .padding(.horizontal, 24)
        .padding(.bottom, 20)
    }
    
    private var headerSection: some View {
                VStack(spacing: 16) {
                    Text("Change Community Icon")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Text("Choose a new profile picture for \(community.name)")
                        .font(.body)
                        .foregroundColor(.gray)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal, 20)
                }
                .padding(.top, 20)
    }
                
    private var imagePreviewSection: some View {
                VStack(spacing: 16) {
                    if let selectedImage = selectedImage {
                        // Show selected image
                        Image(uiImage: selectedImage)
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .frame(width: 120, height: 120)
                            .clipShape(Circle())
                            .overlay(
                                Circle()
                                    .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                            )
                    } else if let profileImageUrl = community.profile_image_url {
                        // Show current community image
                        AsyncImage(url: URL(string: profileImageUrl)) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                        } placeholder: {
                            Circle()
                                .fill(Color.gray.opacity(0.2))
                                .overlay(
                                    ProgressView()
                                        .progressViewStyle(CircularProgressViewStyle(tint: .gray))
                                )
                        }
                        .frame(width: 120, height: 120)
                        .clipShape(Circle())
                        .overlay(
                            Circle()
                                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                        )
                    } else {
                        // Show community initials
                        Circle()
                            .fill(Color.slingLightBlue)
                            .frame(width: 120, height: 120)
                            .overlay(
                                Text(String(community.name.prefix(1)).uppercased())
                                    .font(.title)
                                    .fontWeight(.bold)
                                    .foregroundColor(.slingBlue)
                            )
                            .overlay(
                                Circle()
                                    .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                            )
                    }
                    
                    Text("Current Profile Picture")
                        .font(.caption)
                        .foregroundColor(.gray)
        }
                }
                
    private var imageSelectionSection: some View {
                VStack(spacing: 16) {
                    // Photo Library Button
                    PhotosPicker(
                        selection: $selectedItem,
                        matching: .images,
                        photoLibrary: .shared()
                    ) {
                        HStack(spacing: 16) {
                            Image(systemName: "photo.on.rectangle")
                                .font(.title2)
                                .foregroundColor(.slingBlue)
                                .frame(width: 24, height: 24)
                            
                            Text("Choose from Photo Library")
                                .font(.headline)
                                .fontWeight(.medium)
                                .foregroundColor(.slingBlue)
                            
                            Spacer()
                            
                            Image(systemName: "chevron.right")
                                .font(.headline)
                                .foregroundColor(.gray.opacity(0.6))
                        }
                        .padding(.horizontal, 20)
                        .padding(.vertical, 16)
                        .background(Color.white)
                        .cornerRadius(12)
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                        )
                    }
                    
                    // Camera Button
                    Button(action: {
                        showingCamera = true
                    }) {
                        HStack(spacing: 16) {
                            Image(systemName: "camera")
                                .font(.title2)
                                .foregroundColor(.slingBlue)
                                .frame(width: 24, height: 24)
                            
                            Text("Take a Photo")
                                .font(.headline)
                                .fontWeight(.medium)
                                .foregroundColor(.slingBlue)
                            
                            Spacer()
                            
                            Image(systemName: "chevron.right")
                                .font(.headline)
                                .foregroundColor(.gray.opacity(0.6))
                        }
                        .padding(.horizontal, 20)
                        .padding(.vertical, 16)
                        .background(Color.white)
                        .cornerRadius(12)
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                        )
                    }
                }
                .padding(.horizontal, 24)
    }
    
    var body: some View {
        NavigationView {
            VStack(spacing: 24) {
                headerSection
                imagePreviewSection
                imageSelectionSection
                
                Spacer()
                
                // Upload Button
                if selectedImage != nil {
                    uploadButton
                }
            }
            .background(Color.gray.opacity(0.05))
            .navigationBarHidden(true)
            .overlay(
                // Custom navigation bar
                VStack {
                    HStack {
                        Button(action: {
                            dismiss()
                        }) {
                            Image(systemName: "xmark")
                                .font(.title2)
                                .foregroundColor(.black)
                                .frame(width: 44, height: 44)
                        }
                        
                        Spacer()
                    }
                    .padding(.horizontal, 16)
                    .padding(.top, 12)
                    
                    Spacer()
                },
                alignment: .top
            )
        }
        .onChange(of: selectedItem) { newItem in
            Task {
                if let newItem = newItem {
                    if let data = try? await newItem.loadTransferable(type: Data.self),
                       let uiImage = UIImage(data: data) {
                        selectedImage = uiImage
                    }
                }
            }
        }
        .sheet(isPresented: $showingCamera) {
            CameraView(
                onImageCaptured: { image in
                selectedImage = image
                showingCamera = false
                },
                onError: { error in
                    print("Camera error: \(error)")
                showingCamera = false
            }
            )
        }
        .alert("Error", isPresented: $showingErrorAlert) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
    }
    
    private func uploadImage() {
        guard let image = selectedImage,
              let communityId = community.id else { return }
        
        isUploading = true
        
        firestoreService.uploadCommunityImage(image, communityId: communityId) { success, error in
            DispatchQueue.main.async {
                isUploading = false
                
                if success {
                    dismiss()
                } else {
                    errorMessage = error ?? "Failed to upload image"
                    showingErrorAlert = true
                }
            }
        }
    }
}

// MARK: - Camera View

struct CameraView: UIViewControllerRepresentable {
    let onImageCaptured: (UIImage) -> Void
    let onError: (String) -> Void
    
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        
        // Check if camera is available
        guard UIImagePickerController.isSourceTypeAvailable(.camera) else {
            onError("Camera is not available on this device")
            return picker
        }
        
        picker.sourceType = .camera
        picker.delegate = context.coordinator
        picker.allowsEditing = true
        return picker
    }
    
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
    
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    
    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
        let parent: CameraView
        
        init(_ parent: CameraView) {
            self.parent = parent
        }
        
        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            if let image = info[.editedImage] as? UIImage {
                parent.onImageCaptured(image)
            } else if let image = info[.originalImage] as? UIImage {
                parent.onImageCaptured(image)
            }
            picker.dismiss(animated: true)
        }
        
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            picker.dismiss(animated: true)
        }
    }
}

// MARK: - User Image Picker

struct UserImagePicker: View {
    @Binding var selectedImage: UIImage?
    @Environment(\.dismiss) private var dismiss
    
    @State private var selectedItem: PhotosPickerItem? = nil
    @State private var showingCamera = false
    @State private var showingErrorAlert = false
    @State private var errorMessage = ""
    
    var body: some View {
        NavigationView {
            VStack(spacing: 32) {
                // Header
                VStack(spacing: 16) {
                    Image(systemName: "person.crop.circle.fill")
                        .font(.system(size: 60))
                        .foregroundColor(.slingBlue)
                    
                    Text("Choose Profile Picture")
                        .font(.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.black)
                    
                    Text("Select from your photos or take a new picture")
                        .font(.subheadline)
                        .foregroundColor(.gray)
                        .multilineTextAlignment(.center)
                }
                .padding(.horizontal, 20)
                
                // Preview section
                if let selectedImage = selectedImage {
                    VStack(spacing: 16) {
                        Text("Preview")
                            .font(.headline)
                            .foregroundColor(.black)
                        
                        Image(uiImage: selectedImage)
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .frame(width: 120, height: 120)
                            .clipShape(Circle())
                            .overlay(
                                Circle()
                                    .stroke(Color.slingBlue, lineWidth: 3)
                            )
                    }
                }
                
                // Action buttons
                VStack(spacing: 16) {
                    // Photo Library Button
                    PhotosPicker(selection: $selectedItem, matching: .images, photoLibrary: .shared()) {
                        HStack(spacing: 12) {
                            Image(systemName: "photo.on.rectangle")
                                .font(.title3)
                                .foregroundColor(.slingBlue)
                            
                            Text("Choose from Photos")
                                .font(.headline)
                                .fontWeight(.medium)
                                .foregroundColor(.slingBlue)
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 56)
                        .background(
                            RoundedRectangle(cornerRadius: 28)
                                .fill(Color.slingLightBlue)
                        )
                    }
                    
                    // Camera Button
                    Button(action: {
                        showingCamera = true
                    }) {
                        HStack(spacing: 12) {
                            Image(systemName: "camera")
                                .font(.title3)
                                .foregroundColor(.white)
                            
                            Text("Take Photo")
                                .font(.headline)
                                .fontWeight(.medium)
                                .foregroundColor(.white)
                        }
                        .frame(maxWidth: .infinity)
                        .frame(height: 56)
                        .background(
                            RoundedRectangle(cornerRadius: 28)
                                .fill(Color.slingBlue)
                        )
                    }
                }
                .padding(.horizontal, 20)
                
                Spacer()
            }
            .padding(.top, 20)
            .background(Color.white)
            .navigationBarHidden(true)
            .overlay(
                // Close button
                VStack {
                    HStack {
                        Spacer()
                        Button(action: { dismiss() }) {
                            Image(systemName: "xmark")
                                .font(.title3)
                                .fontWeight(.medium)
                                .foregroundColor(.gray)
                                .frame(width: 32, height: 32)
                                .background(Circle().fill(Color.gray.opacity(0.1)))
                        }
                        .padding(.trailing, 20)
                        .padding(.top, 20)
                    }
                    Spacer()
                },
                alignment: .top
            )
        }
        .onChange(of: selectedItem) { _ in
            Task {
                if let newItem = selectedItem {
                    do {
                        if let data = try await newItem.loadTransferable(type: Data.self),
                           let image = UIImage(data: data) {
                            await MainActor.run {
                                selectedImage = image
                                dismiss()
                            }
                        }
                    } catch {
                        await MainActor.run {
                            errorMessage = "Failed to load image"
                            showingErrorAlert = true
                        }
                    }
                }
            }
        }
        .sheet(isPresented: $showingCamera) {
            CameraView(
                onImageCaptured: { image in
                selectedImage = image
                showingCamera = false
                dismiss()
                },
                onError: { error in
                    print("Camera error: \(error)")
                    showingCamera = false
            }
            )
        }
        .alert("Error", isPresented: $showingErrorAlert) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
    }
}

// MARK: - Photos Picker Sheet
struct PhotosPickerSheet: View {
    @Binding var selectedItem: PhotosPickerItem?
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        NavigationView {
            VStack {
                PhotosPicker(
                    selection: $selectedItem,
                    matching: .images,
                    photoLibrary: .shared()
                ) {
                    VStack(spacing: 20) {
                        Image(systemName: "photo.on.rectangle")
                            .font(.system(size: 60))
                            .foregroundColor(.slingBlue)
                        
                        Text("Choose from Photos")
                            .font(.title2)
                            .fontWeight(.semibold)
                            .foregroundColor(.black)
                        
                        Text("Select a photo from your library")
                            .font(.subheadline)
                            .foregroundColor(.gray)
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                    .background(Color.clear)
                    .contentShape(Rectangle())
                }
                .onChange(of: selectedItem) { newItem in
                    if newItem != nil {
                        dismiss()
                    }
                }
            }
            .navigationTitle("Select Photo")
            .navigationBarTitleDisplayMode(.inline)
            .navigationBarBackButtonHidden(true)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
        }
    }
}

// MARK: - DateFormatter Extension

extension DateFormatter {
    static let timeFormatter: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "h:mm a"
        return formatter
    }()
}


